{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#burak-rustemogullar-robotics-programming-notes","title":"\ud83c\udfe0 Burak R\u00fcstemo\u011fullar\u0131 \u2014 Robotics &amp; Programming Notes","text":"<p>Welcome! This documentation contains my personal notes on robotics, programming languages, algorithms, and embedded systems.</p>"},{"location":"#sections","title":"Sections","text":""},{"location":"#c-programming","title":"C programming","text":""},{"location":"c/1_programming_and_c/","title":"Programming and C","text":""},{"location":"c/1_programming_and_c/#programming-and-c","title":"Programming and C","text":""},{"location":"c/1_programming_and_c/#what-is-software","title":"What is Software?","text":"<p>Software is the name given to programming and the general body of related subjects. When software is mentioned, programming languages, source programs written using these languages, and various files created come to mind.</p>"},{"location":"c/1_programming_and_c/#what-is-hardware","title":"What is Hardware?","text":"<p>Hardware is the name given to the electronic part and structure of the computer.</p>"},{"location":"c/1_programming_and_c/#classification-of-software","title":"Classification of Software","text":"<p>Software can be divided into various groups according to its application areas:</p> <ol> <li> <p>Scientific and Engineering Software     Software used in solving problems in scientific fields and engineering applications. In this type of software, the amount of data is relatively low, but mathematical and statistical algorithms are used intensively. Such programs predominantly contain computation-oriented operations and intensively use the computer's Central Processing Unit (CPU). Examples of such programs include programs that analyze electronic circuits and statistical analysis packages.</p> </li> <li> <p>Application Software     Primarily database-oriented software. It generally deals with the creation, processing, and storage of data in files. Examples of this type of program include stock control programs, customer tracking programs, and accounting programs.</p> </li> <li> <p>Artificial Intelligence (AI) Software     Software that mimics human intellectual or learning behavior. Examples include robot software, programs that play chess or bridge, etc.</p> </li> <li> <p>Graphical Software     Programs where graphical operations and algorithms are used very intensively. Examples include games and animation software. These programs predominantly use the computer's graphical interface.</p> </li> <li> <p>Simulation Software     Software used to simulate a system in a computer environment.</p> </li> <li> <p>System Software     Software that manages the electronic structure of the computer. Compilers, communication programs, and operating systems are system software. For example, a word processing program is also system software. They perform lower-level operations compared to application programs.</p> </li> </ol>"},{"location":"c/1_programming_and_c/#evaluation-criteria-for-programming-languages","title":"Evaluation Criteria for Programming Languages","text":"<p>Sources mention the existence of approximately 1000 - 1500 programming languages currently in use. Why are there so many programming languages? Despite this abundance, why are new programming languages still being designed? What characteristics might make one programming language different from the other(s)? Which qualifiers can be used if one were to define a programming language? To answer these questions, there must be criteria that allow for evaluation. These criteria are briefly examined below:</p>"},{"location":"c/1_programming_and_c/#level","title":"Level","text":"<p>The level of a programming language is the measure of that programming language's proximity to human perception or the machine. A programming language is considered high-level the closer it is to human perception. Conversely, a programming language is considered low-level the closer it is to the electronic structure and operation of the computer.</p> <p>The computer's processor has an instruction set that it understands. The processor can only execute the instructions within its own instruction set. The text written in the programming language is converted into instructions in the computer processor's instruction set through some processes.</p> <p>Working with high-level languages is easy for the programmer and does not require extensive algorithm knowledge. In these languages, only what needs to be done is communicated to the program, but not how it should be done. Generally, as the level of a programming language increases, it becomes easier to learn that language and write programs in it.</p> <p>Machine language is the natural language of the computer, dependent on the computer's hardware design. Machine languages were the first languages used to get computers to perform tasks, coinciding with the development of computers. That is why machine languages are also called first-generation languages.</p> <p>Two fundamental problems were encountered when using machine language in programs. Code written in machine language consists of commands given directly to the machine's processor and hardware components. If a different CPU is used, or if the memory organization is done differently, the program no longer works; the program must be rewritten. This is because machine language is only applicable to a specific CPU or CPU series. Machine language is not portable. The other significant problem is that writing code in machine language is very cumbersome. Besides being very time-consuming and tedious to write, reading or understanding the written program is equally difficult. Especially when the program size increases, developing and expanding programs written in machine language become quite complex.</p> <p>Initially, there was only machine language. That is why machine languages are also referred to as 1st generation languages. Within the historical development of software and hardware, there is a process that extends from machine language to very high-level languages close to human perception (4th generation languages).</p> <p>In the early 1950s, efforts to eliminate the problems associated with using machine language intensified. During these years, programs written in machine language were loaded into the computer's very limited memory and executed in this way. First, a step was taken that partially eliminated the difficulty of perceiving and understanding machine language: Symbolic machine languages were developed. Symbolic machine languages (Assembly Languages) consisted of certain abbreviation words and commands that bundled a few machine instructions. The use of symbolic machine languages quickly became widespread. However, symbolic machine languages had a major disadvantage compared to machine languages. Programs written in these languages were loaded into the computer's memory like programs written in machine language, but during the execution phase, the commands of the symbolic language were translated into machine language one command at a time with the help of an interpreter program, and the resulting machine code was executed. That is, the computer first translated the program into machine language by interpreting it during the execution phase, and then executed the translated machine code. When programs were executed this way, they slowed down by almost 30 times.</p> <p>During this period, two interpreter programs notably emerged: John Mauchly's interpreter for UNIVAC 1 (1950) and the \"Speedcoding\" interpretation system written by John Backus for the IBM 701 in 1953. Although these interpreters ran very slowly compared to machine code, they increased programmer productivity. However, especially old machine language programmers argued that interpreters were too slow and that only programs written in machine language could be called real programs.</p> <p>This problem was also overcome. The idea, which was considered brilliant for its time, was: Instead of the written code being translated into machine language every time it is run, another program to be developed should translate the code written in symbolic language into machine language once, and then whenever the program is to be run, the computer should execute only the machine code without interpretation. Grace Hopper developed this idea. Grace Hopper's invention was named \"compiler.\" (Grace Hopper was also part of the team that developed the Cobol language, and she was the first to use the word \"bug.\") Programmers were now using Assembly programming languages consisting of symbolic words, the programs they wrote were converted to machine code by the compiler, and the machine code ran at full speed without losing any of its previous speed. Assembly languages took their place in history as 2nd generation languages.</p> <p>With the adoption of Assembly languages, computer usage rapidly increased. However, the fact that many commands were required to perform even the simplest operations on the computer initiated a quest to speed up and simplify the programming process, and as a result, higher-level programming languages began to be developed.</p> <p>Languages developed later than Assembly languages in the historical process and at a higher level are considered 3rd generation languages. These languages are all algorithmic languages. Few of the hundreds of high-level programming languages developed to date have survived. Almost all 3rd generation languages are derived from three main languages. These three languages, the first of the 3rd generation languages, are still in existence:</p> <p>FORTRAN (FORmula TRANslator) was developed by John Backus for IBM between 1954 and 1957 for use in engineering and scientific applications requiring complex mathematical calculations. The FORTRAN language is still used in scientific applications requiring intensive mathematical calculations. The FORTRAN language has two important versions: FORTRAN IV and FORTRAN 77. ISO and ANSI standards were accepted for a version named FORTRAN-90 in the early nineties. The FORTRAN language is considered the oldest of the 3rd generation languages.</p> <p>COBOL (COmmon Business Oriented Language) was developed in 1959 by a group consisting of computer manufacturers, private sector, and government sector computer users in America. The purpose of developing COBOL was to use a portable programming language for commercial applications requiring data management. The COBOL language is still widely used.</p> <p>ALGOL (The ALGOritmick Language) was developed by a consortium in Europe in 1958. Since IBM adopted the FORTRAN language as the common programming language to be used on its hardware, Europeans also wanted to develop an alternative language. Many design features developed in the ALGOL language are used in all modern programming languages.</p> <p>In the early 60s, work on programming languages brought the concept of structured programming to the agenda. The PASCAL language was developed by Professor Niclaus Wirth in 1971 to introduce the concept of structured programming to academic circles. The creator of the language named it after the mathematician and philosopher Blaise Pascal. This language quickly became the programming language used in universities. The fact that the Pascal language lacked some features necessary to support commercial and industrial applications limited its use. The Modula and Modula-2 languages were developed based on the Pascal language.</p> <p>The BASIC language was developed by John Kemeney and Thomas Kurtz in the mid-1960s. It is said that the name BASIC was formed from the initial letters of \"Beginner's All Purpose Symbolic Instruction Code.\" It is one of the oldest and simplest of the high-level languages. Despite all its simplicity, it has been used in many commercial applications. The BASIC language has also been standardized by ANSI. However, there are versions of the BASIC language that include additional features. For example, many features related to object-oriented programming were added to the Visual Basic language released by Microsoft. This language later took the name Visual Basic .NET. In addition, some versions of the BASIC language were generally accepted as the programming language used for writing macros that users would write for customization and automation purposes in application programs, for example, in MS Excel and MS Word programs.</p> <p>The ADA language, on the other hand, was developed starting from the 70s with the support of the U.S. Department of Defense (DoD). DoD is one of the largest computer users in the world. This institution was using a large number of different programming languages to meet different software requirements and began searching for a single language that would meet all its needs. An international competition was organized to design the language. The winning company (CII-Honeywell Bull of France) developed the Ada language as a result of its work based on the Pascal language. The documentation for the Ada language was published in 1983. The name Ada is a reference to the name of Lady Ada Lovelace, the daughter of the philosopher Lord Byron. Ada Lovelace was the assistant of Charles Babbage, who first used punched cards in calculating machines. Charles Babbage worked throughout his life on the construction of machines named \"Difference Engine\" and \"Analytical Machine\" but died before realizing these projects. Nevertheless, the designs he developed are considered the ancestors of modern computers. Ada Lovelace prepared the punched cards and algorithms to be used for Charles Babbage's machine. Lovelace is considered to have written the first computer program in the early 1800s. Ada is a general-purpose language, used in many different fields, from commercial applications to guiding rockets. One of the important features of the language is its support for real-time applications (embedded systems). Another feature is that it facilitates the writing of large programs due to its highly modular structure. However, the need for large, complex compilers has made its competition against C, Modula-2, and C++ languages difficult.</p> <p>Very high-level languages and languages where programs, generally not containing algorithmic structures, are written in a visual environment are called 4th generation languages. They are usually abbreviated as 4GL (fourth generation language). They are the languages closest to human perception. The RPG language can be considered the first of the 4th generation languages. It was developed by IBM at the request of companies, especially users of small IBM machines, who wanted an easy language for report generation.</p> <p>Programming languages can be grouped according to their levels:</p> <ul> <li>Very high-level languages or visual languages/environments (visual languages): Access, Foxpro, Paradox, Xbase, Visual Basic, Oracle Forms.</li> <li>High-level languages: Fortran, Pascal, Basic, Cobol.</li> <li>Mid-level programming languages: Ada, C. (Mid-level languages run faster because they can be translated into machine language with less loss.)</li> <li>Low-level programming languages: Symbolic machine language (Assembly language).</li> <li>Machine language: The lowest-level programming language. Pure machine language consists entirely of 1s and 0s.</li> </ul>"},{"location":"c/1_programming_and_c/#readability","title":"Readability","text":"<p>Readability is a term that means the source code can be quickly and well understood. When the readability of the source code is in question, the responsibility lies largely with the programmer who writes the program. However, as with efficiency, this feature also depends to some extent on the design of the programming language, as some languages contain structures and tools that enhance readability. The best program code is not the one \"most cleverly written but which no one can understand.\" In many cases, good programmers are unwilling to sacrifice readability for anything. This is because a readable program allows for updating even years later due to its easy comprehensibility. Readability becomes even more important in large-scale projects where many programmers work on shared code.</p> <p>Readability is one of the most emphasized concepts in C. You will see frequent mentions of readability in many subsequent sections.</p>"},{"location":"c/1_programming_and_c/#portability","title":"Portability","text":"<p>Portability means that source code written for one system can be compiled without errors and run correctly when transferred to another system. Portability also means standardization. Programming languages are standardized by ISO (International Standard Organization) and ANSI (American National Standard Institute). The C Language, whose standards were first established in 1989, is a more portable programming language than other programming languages.</p>"},{"location":"c/1_programming_and_c/#efficiency","title":"Efficiency","text":"<p>Efficiency is the characteristic of a program running fast and using less memory. The running speed and the amount of memory used by a program depend on many factors. Undoubtedly, the algorithm used also has an effect on speed and memory usage. The computer on which the program is run naturally also has an effect on speed. Efficiency can be considered a criterion related to the memory area used and the running speed when a program written in a programming language is run. When other factors that may play a role in efficiency are kept constant, it can be said that the design of the programming language used is also effective on efficiency. Viewed from this perspective, C is an efficient language.</p>"},{"location":"c/1_programming_and_c/#usage-area","title":"Usage Area","text":"<p>Some languages are designed for a specific application area. There are programming languages designed and used for system programming, artificial intelligence applications, simulation applications, database queries, and writing game programs. Other languages have a wider scope of use. For example, a language designed for use in database queries can also be used in engineering applications.</p> <p>Although the C language originated as a system programming language, its powerful structure quickly made it a general-purpose language. Pascal and BASIC, on the other hand, are much more general-purpose languages.</p> <p>C is a language whose main application area is \"system programming.\" However, programs have been written in the C language for almost all application areas.</p>"},{"location":"c/1_programming_and_c/#classification-by-application-area","title":"Classification by Application Area","text":"<p>We can also group programming languages according to their application areas:</p> <ol> <li>Scientific and Engineering Application Languages: Pascal, C, FORTRAN. The C Programming language is also used intensively in academic work at universities.</li> <li>Database Languages: XBASE (Foxpro, Dbase, CA-Clipper), Oracle Forms, Visual Foxpro.</li> <li>General-Purpose Programming Languages: Pascal, C, Basic.</li> <li>Artificial Intelligence Languages: Prolog, Lisp.</li> <li>Simulation Languages: GPSS, Simula 67.</li> <li>Macro Languages (Scripting languages): awk, Perl, Python, Tcl, JavaScript.</li> <li>System Programming Languages: Symbolic machine languages, BCPL, C, C++, occam.</li> </ol> <p>Today, we can say that almost all system software is written in the C language. For example, 80% of the UNIX operating system is written in the C language, and the rest is written in symbolic machine language. This operating system was first created at BELL Laboratories. Its source codes were not kept secret, making it possible to develop it from various branches. UNIX-based operating system applications developed later were given different names.</p> <p>C is a general-purpose system programming language that can be used in scientific and engineering fields.</p>"},{"location":"c/1_programming_and_c/#subprogramming-capability","title":"Subprogramming Capability","text":"<p>The method of breaking down problems that are difficult to solve as a whole into parts, solving these parts separately, and then connecting the parts is a frequently used method in programming. If a programming language has tools that allow this, it can be said that the programming language has subprogramming capability. Subprogramming capability means that a programming language supports writing the program in parts.</p> <p>Subprogramming is also an indispensable part of the Structured Programming Technique. Subprogramming brings some significant benefits. Subprograms reduce the size of the source code. Writing frequently repeated operations using subprograms reduces the size of the executable program code. This is because subprograms are written into the executable code only once. The program code can be made to jump to the location of the subprogram, allowing this segment to be executed multiple times.</p> <p>Subprogramming facilitates comprehension, increases readability, and also makes source code easier to test and update more easily. One of the most important benefits of subprogramming is the reusability of the created subprograms in multiple projects.</p> <p>C is a language with high subprogramming capability. Subprograms in C are called functions. Functions are the building blocks of the C language.</p>"},{"location":"c/1_programming_and_c/#ease-of-learning-and-teaching","title":"Ease of Learning and Teaching","text":"<p>The difficulty level of learning each programming language and developing applications in the learned programming language is not the same. Generally, as the level of programming languages increases, it becomes easier to learn and teach that programming language to others. An important reason for the popularity of widely used high-level programming languages today is that these languages are very easy to learn. However, gaining proficient skill by learning high-level languages often involves other difficulties. Such languages contain a large number of ready-made tools. For example, in a high-level programming environment, dozens of options may be presented to change the properties of a ready-made menu bar related to the GUI. In this case, the programmer has to learn the meaning of each option. That is, in some cases, although the increase in the level of the programming language brings a perceived convenience to the programmer, it also brings a learning burden to the programmer, especially regarding ready-made tools.</p>"},{"location":"c/1_programming_and_c/#supports-provided-for-programming-techniques","title":"Supports Provided for Programming Techniques","text":"<p>In the historical development process of programming, certain programming techniques (paradigms) have emerged. Since the sizes of programs written in the early days of programming were very small, there was little need to use a special technique when writing programs. This is because a program was small and simple enough for a single programmer to handle all aspects of it. There was no serious cost to changing a program or adding to a program.</p> <p>Technical developments in computer hardware, increased user expectations from computer programs, and the effective use of graphical interfaces have led to a gradual increase in program sizes. With the growth of programs, different techniques and methods for writing programs have been developed. Examples of these techniques include \"procedural programming,\" \"modular programming,\" \"object-based programming,\" \"object-oriented programming,\" and \"generic programming.\"</p> <p>\"Procedural programming\" and \"structured programming\" are often used interchangeably. Structured programming is a programming technique. Today, almost all programming languages are designed to support structured programming to a greater or lesser extent. The idea of structured programming was developed in the 1960s. The structured programming technique is based on four main principles:</p> <ol> <li>Divide and conquer     Programs that are difficult to write as a single whole are divided into smaller, more manageable pieces. That is, the program is divided into its smallest possible components (functional decomposition). These components are called subprograms, functions, procedures, etc. The benefits of subprogramming were explained earlier.</li> <li>Data hiding     In the structured programming technique, variables that cannot be accessed from other parts of the program and that have a limited scope, i.e., variables to be used only in a certain part of the code, can be defined. These types of variables are generally called \"local variables.\" Limiting the scope of variables reduces the risk of making errors, and also allows programs to be modified more easily and program segments to be reused in other programs. Information about how a subprogram or module performs a task is hidden from the user (client) of that subprogram or module. For the user (client), what the subprogram or module does is important, not how it does the task.</li> <li>Single entry, single exit     In languages that support the structured programming technique, there is a single entry and a single exit mechanism to enter each subprogram segment. This tool is in harmony with the top-to-bottom flow of the program. Program segments can only be entered from a single point.</li> <li>Loops, other control structures     Loops and other control statements are frequently used in the structured programming technique.</li> </ol> <p>Almost all programming languages in use today support the structured programming technique to a greater or lesser extent.</p> <p>Object-oriented programming (OOP) is also a programming technique. While the structured programming technique came to the fore in the 1960s, the object-oriented programming technique became widespread in the 1980s. This technique was developed due to the need arising from the excessive growth of source code. In the years when the C language was designed, the source codes of the largest imaginable programs were only a few thousand lines. With developments in computer hardware, increased user expectations from computer programs, and the effective use of graphical interfaces, the size of computer programs grew significantly. The size of many programs in use is measured in hundreds of thousands or even millions of lines.</p> <p>The object-oriented programming technique is designed, first and foremost, as a technique for writing large programs better. When the C language was created, the emergence of such a technique was not possible because programs were already very small by today's standards.</p> <p>In the object-oriented programming technique, the data related to the program and the code that processes this data are combined under a unit called an object. That is, the building blocks of this technique are objects. The most important difference of this technique from procedural programming is that the programmer thinks and constructs the program directly on the plane of the problem itself, rather than on the plane of the programming language. This allows a problem related to real life to be modeled much better in software.</p> <p>With the widespread adoption of the object-oriented programming technique, new versions of many programming languages have been created by adding tools that facilitate the application of this technique to their structures. For example, the C++ language was developed by making additions to the C language to enable the object-oriented programming technique to be applied. For similar purposes, the Delphi language was developed by making additions to the Pascal language, Oocobol by renewing the Cobol language, and Ada 95 by renewing the Ada language.</p> <p>Some programming languages have been designed and developed to directly support the object-oriented programming technique. Such languages are also called pure object-oriented languages. For example, Java, Eiffel, and C# are pure object-oriented languages.</p> <p>In summary, one of the most important questions to be asked about a programming language is perhaps whether that programming language has the tools to support a particular programming technique.</p> <p>The C language is a language that fully supports the procedural programming technique with its existing tools.</p>"},{"location":"c/1_programming_and_c/#inputoutput-ease","title":"Input/Output Ease","text":"<p>The ability to access sequential, indexed, and random files, and to retrieve, update, and query database records. The database programming languages (DBASE, PARADOX, etc.) have superior capabilities in this regard compared to others. This constitutes their most typical feature. However, C is a language with weak input/output ease. Special libraries must be used in C for the management of databases.</p>"},{"location":"c/1_programming_and_c/#what-kind-of-programming-language-is-c","title":"What Kind of Programming Language is C?","text":"<p>After examining the criteria, the C language can be placed in a specific position:</p> <p>C is a mid-level programming language. The level of the C language is lower compared to other structured programming languages. The C language has both the advantages of high-level languages, such as control statements and data structures, and operators that reflect machine code statements, such as bitwise operators. That is, C is a language close to both the machine's perception and human perception. This is one of the main reasons why it is preferred.</p> <p>Writing a program using the C language is much easier than writing the same program in machine language, but the efficiency of a program written in C does not decrease proportionally. C is preferable to machine language directly for many applications in terms of efficiency. Programming in the C language instead of machine language does not significantly reduce the efficiency of the created program.</p> <p>The main application area of the C language is \"System programming.\" What does system programming mean? Programs written for the management, direction, and control of hardware, which interact directly with the machine's hardware, are called system programs. For example, operating systems, compilers, interpreters, device drivers, programs related to computer communication, and automation programs are system programs.</p> <p>Before C, system programs were written in Assembly languages. Today, it can be said that the C language is almost the only option for writing system programs. Today, C codes are running everywhere, from mobile phones to airplanes.</p> <p>C is an algorithmic language. To write programs in the C language, it is not enough to know only the syntax and semantic structure of the language; general algorithm knowledge is also required.</p> <p>C is a highly portable language compared to other languages. This is because it has had generally accepted standards since 1989.</p> <p>C is a language with high expressive power and strong readability characteristics. The high readability of a text written in the C language is not due to it being a verbal language or a language close to the language used by humans.</p> <p>C is a very flexible language. It does not impose restrictions on the programmer like other languages. It better reflects the capabilities of the machine to the programmer.</p> <p>C is a powerful language, designed very well. Many of the operators and structures related to C have been adopted by other programming languages later.</p> <p>C is an efficient language. Programs written in C run fast due to the low level of the language. It can compete with Assembly languages in terms of efficiency.</p> <p>C is a natural language. C is compatible with the computer system.</p> <p>C is a small language. Writing a compiler for new systems is not difficult.</p> <p>C has a standard library. This library provides a common interface for frequently performed operations.</p> <p>Learning C is more difficult compared to other computer languages.</p> <p>The C language is integrated with the UNIX operating system. Some tools used in the UNIX operating system assume that the user knows the C language.</p> <p>Like all other computer programming languages, the C language also has its weak sides. Being a flexible and powerful language increases the programmer's risk of making errors. Mistakes made in code written in the C language can be more difficult to find than in other languages.</p>"},{"location":"c/2_number_systems/","title":"Number Systems","text":""},{"location":"c/2_number_systems/#number-systems-in-c","title":"Number Systems in C","text":""},{"location":"c/2_number_systems/#1-introduction-to-number-systems","title":"1. Introduction to Number Systems","text":"<p>Computers process data in the binary system. Each number system uses different symbols according to its base:</p> System Base Symbols Binary 2 0, 1 Octal 8 0\u20137 Decimal 10 0\u20139 Hexadecimal 16 0\u20139, A\u2013F <p>representing number systems </p><pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int decimal_num = 255;\n\n    // Octal (prefixed with '0')\n    int octal_num = 0377; \n\n    // Hexadecimal (prefixed with '0x' or '0X')\n    int hex_num = 0xFF; \n\n    printf(\"Decimal (10)   : %d\\n\", decimal_num);\n    printf(\"Octal (8)      : %o\\n\", octal_num);\n    printf(\"Hexadecimal(16): %X\\n\", hex_num);\n\n    // Binary literal support came with the C23 standard but is not widely adopted.\n    // printf(\"Binary (2)   : %b\\n\", 0b11111111); // Does not work in pre-C23 compilers\n\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#2-bit-byte-and-other-units","title":"2. Bit, Byte, and Other Units","text":"<ul> <li>Bit (binary digit): Smallest unit of information (0 or 1)  </li> <li>Nibble: 4 bits </li> <li>Byte: 8 bits   </li> <li>Word: 16 bits  </li> <li>Double Word (DWORD): 32 bits  </li> <li>Quad Word (QWORD): 64 bits  </li> </ul>"},{"location":"c/2_number_systems/#memory-capacity-units","title":"Memory Capacity Units","text":"Unit Equivalent Description 1 KB 1024 Bytes 2\u00b9\u2070 1 MB 1024 KB 2\u00b2\u2070 1 GB 1024 MB 2\u00b3\u2070 1 TB 1024 GB 2\u2074\u2070"},{"location":"c/2_number_systems/#memory-capacity-of-basic-data-types","title":"Memory Capacity of Basic Data Types","text":"<p>Note: The <code>sizeof</code> operator in C allows us to learn how many bytes any data type or variable occupies in memory. the return type is <code>size_t</code> (unsigned int). so i use <code>%zu</code> format for print the occupied byte. This is essential for obtaining hardware-dependent information programmatically. </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;limits.h&gt; // For CHAR_BIT\n\nint main() {\n    // CHAR_BIT gives the number of bits in a byte (usually 8).\n    printf(\"1 Byte = %d Bit\\n\", CHAR_BIT); \n\n    // Prints memory capacity in bytes\n    printf(\"Size of char: %zu Bytes\\n\", sizeof(char));\n    printf(\"Size of int: %zu Bytes\\n\", sizeof(int));\n    printf(\"Size of long long: %zu Bytes\\n\", sizeof(long long));\n\n    // Assuming a 32-bit system: int = 4 Bytes = Double Word (DWORD)\n    printf(\"Size of 4 Byte (DWORD) int: %zu Bytes\\n\", sizeof(int));\n\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#3-binary-decimal-conversions","title":"3. Binary \u2194 Decimal Conversions","text":""},{"location":"c/2_number_systems/#binary-decimal","title":"Binary \u2192 Decimal","text":"<p>Each bit is multiplied by powers of 2 and summed: 1011\u2082 = 1\u00d72\u00b3 + 0\u00d72\u00b2 + 1\u00d72\u00b9 + 1\u00d72\u2070 = 11\u2081\u2080</p>"},{"location":"c/2_number_systems/#decimal-binary","title":"Decimal \u2192 Binary","text":"<p>Divide the number by 2 repeatedly and write the remainders in reverse order: 87\u2081\u2080 \u2192 0101 0111\u2082</p> <p>Alternative method: Subtract the largest power of 2 and continue with the remainder.</p>"},{"location":"c/2_number_systems/#binary-to-decimal-conversion","title":"Binary to Decimal Conversion","text":"<p>This relies on checking an integer using bitwise AND (&amp;) and bitwise Shift (&gt;&gt;) operators. </p><pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    unsigned char binary_num = 0b10110011; // 179\n    int decimal_val = 0;\n    int power = 1;\n\n    // Convert to decimal by checking each bit\n    for (int i = 0; i &lt; 8; i++) {\n        // Check the rightmost bit (LSD) with Bitwise AND\n        if (binary_num &amp; 1) { \n            decimal_val += power;\n        }\n\n        // Shift the number one bit to the right (makes the next bit the LSB)\n        binary_num &gt;&gt;= 1; \n\n        // Increase the power of 2\n        power *= 2; \n    }\n\n    printf(\"1011 0011 (Binary) = %d (Decimal)\\n\", decimal_val); // Output: 179\n\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#4-msd-and-lsd","title":"4. MSD and LSD","text":"<ul> <li>MSD (Most Significant Digit): Leftmost bit, highest value </li> <li>LSD (Least Significant Digit): Rightmost bit, lowest value</li> </ul> <p>Example: 0101 1101 MSD = 0 LSD = 1</p> <p>For an 8-bit number: - Bit 0: LSD (rightmost) - Bit 7: MSD (leftmost)</p> <p>check the LSD </p><pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    unsigned char x = 0b01011101; // 93\n    printf(\"MSD: %d\\n\", (x &gt;&gt; 7) &amp; 1);\n    printf(\"LSD: %d\\n\", x &amp; 1);\n    return 0;\n}\n</code></pre> <p>To access the LSD (Bit 0) of an int variable, the bitwise AND operator is commonly used: </p><pre><code>int num = 87; // ...0101 0111\n// LSD check: Is the number odd or even?\nif (num &amp; 1) { // 87 &amp; 1 = 1 (Odd)\n    // LSD is 1.\n}\n</code></pre>"},{"location":"c/2_number_systems/#5-unsigned-and-signed-numbers","title":"5. Unsigned and Signed Numbers","text":""},{"location":"c/2_number_systems/#unsigned","title":"Unsigned","text":"<p>Represents only positive numbers: 0000 0000 \u2192 0 1111 1111 \u2192 255</p>"},{"location":"c/2_number_systems/#signed","title":"Signed","text":"<p>The leftmost bit is the sign bit: - 0 \u2192 Positive - 1 \u2192 Negative  </p> <p>Note: Integer types in C (e.g., int) are signed by default. Declaring them as unsigned doubles the number's range because the leftmost bit (MSB/MSD) is used as a value bit instead of a sign bit.</p> <p>Signed and Unsigned Undefined Behavior </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;limits.h&gt; // For INT_MAX\n\nint main() {\n    // Assuming a 4-byte (32-bit) system\n\n    int signed_max = INT_MAX; \n    unsigned int unsigned_num = signed_max;\n\n    // Signed int has reached its positive maximum value: 0111...111\n    printf(\"Signed Max: %d\\n\", signed_max);\n\n    // Adding 1 to Signed Max causes an overflow (Section 9: Overflow)\n    int overflow_num = signed_max + 1;\n    printf(\"Signed Overflow: %d\\n\", overflow_num); // Output: -2147483648 (Minimum negative number)\n\n    // For Unsigned int (no sign bit), this is just a value increase: 1000...000\n    printf(\"Unsigned Max + 1: %u\\n\", unsigned_num + 1); \n\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#6-ones-complement","title":"6. One\u2019s Complement","text":"<p>The one\u2019s complement of a number is obtained by inverting all its bits:</p> Original One\u2019s Complement 1011 0100 1100 0011 0011 1100 <p>1 \u2192 0, 0 \u2192 1  </p> <p>The one\u2019s complement of a number\u2019s one\u2019s complement is the number itself. </p><pre><code>#include &lt;stdio.h&gt;\n\nvoid onesComplement(unsigned char x) {\n    unsigned char result = ~x;\n    printf(\"Original: 0x%X, One's Complement: 0x%X\\n\", x, result);\n}\n\nint main() {\n    onesComplement(0b10101100);\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#7-twos-complement","title":"7. Two\u2019s Complement","text":"<p>Definition: Add 1 to the one\u2019s complement of a number.</p> Number One\u2019s Complement +1 Two\u2019s Complement 0101 1000 1010 0111 +1 1010 1000 <p>Alternative shortcut: - Go from right to left, - Copy bits until the first 1 is encountered, - Invert the remaining bits.</p> <p>Example: 1110 0100 \u2192 0001 1100</p> <p>The two\u2019s complement of a number\u2019s two\u2019s complement is the number itself.</p>"},{"location":"c/2_number_systems/#calculating-ones-and-twos-complement","title":"Calculating One's and Two's Complement","text":"<p>Note: The Bitwise NOT (~) operator in C easily calculates the One's Complement of a number. To obtain the Two's Complement, simply add 1 to the result. </p><pre><code>#include &lt;stdio.h&gt;\n\nvoid twosComplement(unsigned char x) {\n    unsigned char ones = ~x;\n    unsigned char twos = ones + 1;\n    printf(\"Original: 0x%X, Two's Complement: 0x%X\\n\", x, twos);\n}\n\nint main() {\n    twosComplement(0b01011000);\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#8-representation-of-negative-numbers","title":"8. Representation of Negative Numbers","text":"<p>Negative numbers are represented using two\u2019s complement.</p> <p>Example: Represent <code>-27</code> in 8-bit signed binary:</p> <ol> <li>Binary of 27 \u2192 <code>0001 1011</code> </li> <li>One\u2019s complement \u2192 <code>1110 0100</code> </li> <li>Add 1 \u2192 <code>1110 0101</code></li> </ol> <p>Result: -27 \u2192 1110 0101</p>"},{"location":"c/2_number_systems/#examples","title":"Examples","text":"Decimal Binary (8-bit) Description 127 0111 1111 Maximum positive -128 1000 0000 Minimum negative -1 1111 1111 All bits are 1 <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    signed char pos = 27;\n    signed char neg = -27;\n\n    printf(\"27 binary: %d\\n\", pos);\n    printf(\"-27 binary (two's complement): %d\\n\", neg);\n    printf(\"Raw bytes: 0x%X and 0x%X\\n\", (unsigned char)pos, (unsigned char)neg);\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#9-number-overflow","title":"9. Number Overflow","text":"<p>In signed systems, adding 1 to the maximum positive number wraps into the negative range:</p> <p>0111 1111 (127) +1 1000 0000 (-128)</p> <p>Similarly, subtracting 1 from -128 wraps to 127.</p>"},{"location":"c/2_number_systems/#undefined-behavior-signed-overflow","title":"Undefined Behavior (Signed Overflow)","text":"<p>Note: In C, operations that exceed the range of an integer type (e.g., a value greater than 2^31 - 1 for signed int) can lead to undefined behavior. However, the value typically wraps into the type's negative range. For unsigned integers, overflow is guaranteed and wraps back from the lowest value using modulus arithmetic.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;limits.h&gt;\n\nint main() {\n    int max_val = INT_MAX; \n\n    // The compiler is not required to follow a specific rule in the case of signed int overflow.\n    // On most systems, it wraps to the value -2147483648 (INT_MIN).\n    int result = max_val + 1; \n\n    printf(\"INT_MAX + 1 = %d\\n\", result); \n\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#10-hexadecimal-system","title":"10. Hexadecimal System","text":"<p>Each hex digit represents 4 bits:</p> Hex Binary Decimal 0 0000 0 1 0001 1 2 0010 2 ... ... ... A 1010 10 F 1111 15 <p>Example: 2ADF\u2081\u2086 = 0010 1010 1101 1111\u2082</p> <p>To check if a number is negative, look at the leftmost hex digit: If it is in [8\u2013F], the number is negative. </p><pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int x = 0x2ADF;  // hexadecimal literal\n    printf(\"Hex: 0x%X, Decimal: %d, Binary: \", x, x);\n\n    for (int i = 15; i &gt;= 0; i--)\n        printf(\"%d\", (x &gt;&gt; i) &amp; 1);\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#11-octal-system","title":"11. Octal System","text":"<p>Each octal digit is represented by 3 bits:</p> Octal Binary 0 000 1 001 2 010 3 011 4 100 5 101 6 110 7 111 <p>Example: 765\u2088 = 111 110 101\u2082</p> <p>ex: output formatting Note: In the printf function, we can output hexadecimal values using %x or %X, and octal values using %o. </p><pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int num = 450; // 0x1C2 in Hex, 0702 in Octal\n\n    printf(\"Decimal: %d\\n\", num);\n\n    // Hexadecimal output format\n    printf(\"Hexadecimal (Lower): %x\\n\", num); \n    printf(\"Hexadecimal (Upper): %X\\n\", num);\n\n    // Octal output format\n    printf(\"Octal: %o\\n\", num); \n\n    // Formatting with prefix 0x\n    printf(\"Hex with prefix: %#X\\n\", num); \n\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#12-representation-of-real-numbers-in-memory-ieee-754","title":"12. Representation of Real Numbers in Memory (IEEE 754)","text":"<p>Real numbers are stored in memory according to the IEEE 754 standard.</p>"},{"location":"c/2_number_systems/#single-precision-32-bit","title":"Single Precision (32-bit)","text":"<p>S EEEEEEEE FFFFFFFFFFFFFFFFFFFFFFF</p> Field Bits Description S 1 Sign bit E 8 Exponent F 23 Fraction (mantissa) <p>Formula: V = (-1)^S \u00d7 2^(E - 127) \u00d7 (1.F) Example: 0 10000001 10100000000000000000000 \u2192 +6.5</p>"},{"location":"c/2_number_systems/#double-precision-64-bit","title":"Double Precision (64-bit)","text":"<p>S EEEEEEEEEEE FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF Formula: V = (-1)^S \u00d7 2^(E - 1023) \u00d7 (1.F)</p>"},{"location":"c/2_number_systems/#13-ieee-754-special-cases","title":"13. IEEE 754 Special Cases","text":"Case E F Result 255/2047 \u22600 \u22600 NaN (Not a Number) 255/2047 =0, S=1 -\u221e 255/2047 =0, S=0 +\u221e 0 =0 +0 / -0 0 \u22600 Denormalized number <pre><code>#include &lt;stdio.h&gt;\n\nvoid printFloatBits(float f) {\n    unsigned int bits = *(unsigned int *)&amp;f;\n    printf(\"Float: %.2f\\nBits : \", f);\n    for (int i = 31; i &gt;= 0; i--) {\n        printf(\"%d\", (bits &gt;&gt; i) &amp; 1);\n        if (i == 31 || i == 23) printf(\" \");\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    float x = 6.5f;\n    float y = -6.5f;\n    printFloatBits(x);\n    printFloatBits(y);\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#additional-examples","title":"Additional examples:","text":""},{"location":"c/2_number_systems/#1-ieee-754-inspection","title":"1. IEEE 754 Inspection","text":"<p>The following code uses Pointer and Union structures to inspect how a float number is represented in memory according to the IEEE 754 standard (bit-by-bit). This is one of examples of C's low-level access power. </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt; // For uint32_t\n\n// Union is used to define different types sharing the same memory location\ntypedef union {\n    float f;\n    uint32_t u; // IEEE 754 single precision = 32 bits (4 bytes)\n} FloatConverter;\n\nvoid display_ieee754(float number) {\n    FloatConverter converter;\n    converter.f = number;\n\n    uint32_t bits = converter.u;\n\n    printf(\"Input Number (Float): %.6f\\n\", number);\n\n    // 1. Sign Bit - Bit 31\n    uint32_t sign = (bits &gt;&gt; 31) &amp; 1;\n    printf(\"1. Sign Bit (S): %u\\n\", sign);\n\n    // 2. Exponent - Bits 30 to 23 (8 bits)\n    uint32_t exponent = (bits &gt;&gt; 23) &amp; 0xFF;\n    printf(\"2. Exponent (E): %u (Hex: 0x%X)\\n\", exponent, exponent);\n\n    // 3. Fraction (Mantissa) - Bits 22 to 0 (23 bits)\n    uint32_t fraction = bits &amp; 0x7FFFFF;\n    printf(\"3. Fraction (F): 0x%X\\n\", fraction);\n\n    // Note: This operation is critical for understanding data representation at the hardware level in the C language.\n}\n\nint main() {\n    // The value 6.5f (S=0, E=10000001, F=101000...)\n    display_ieee754(6.5f); \n\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#2-binary-to-decimal","title":"2. binary to decimal","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint binary_to_decimal(const char *binary) {\n    int len = strlen(binary);\n    int decimal = 0;\n    for (int i = 0; i &lt; len; i++) {\n        if (binary[len - 1 - i] == '1') {\n            decimal += pow(2, i);\n        }\n    }\n    return decimal;\n}\n\nint main(){\n    char binary[] = \"1101\"; // Example binary number\n    printf(\"Binary %s = Decimal %d\\n\", binary,binary_to_decimal(binary) );\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#3-decimal-to-binary","title":"3. decimal to binary","text":"<pre><code>#include &lt;stdio.h&gt;\n\nvoid decimalToBinary(int decimal){\n    int bits[32];\n    int index = 0;\n    while (decimal &gt; 0){\n        bits[index++] = decimal % 2;\n        decimal /= 2;\n    }\n    for (int i = index - 1; i &gt;= 0; i--){\n        printf(\"%d\", bits[i]);\n    }\n}\n\n\nint main() {\n    int n = 87;\n    printf(\"%d in binary: \", n);\n    decimalToBinary(n);\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#4-endianness-control-and-byte-order-swapping","title":"4. Endianness Control and Byte Order Swapping","text":"<p>This code demonstrates how to check a system's Endianness (byte order) using a Union and provides a portable function to swap the byte order of a 32-bit integer using Bitwise Operators. </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\n// Function to check system Endianness\n// Return 1 for Little-Endian, 0 for Big-Endian\nint check_endianness() {\n    // Union allows accessing the 32-bit integer as an array of 8-bit bytes\n    union {\n        uint32_t value; // 4-byte integer\n        uint8_t bytes[4]; // 4 1-byte integers\n    } test;\n\n    test.value = 0x01020304; // Assign a known pattern (MSB=0x01, LSB=0x04)\n\n    // Little-Endian: The least significant byte (0x04) is stored first (at index 0/lowest address).\n    // Big-Endian: The most significant byte (0x01) is stored first (at index 0/lowest address).\n\n    // Check the value of the first byte (lowest address)\n    if (test.bytes[0] == 0x04) {\n        return 1; // Little-Endian\n    } else {\n        return 0; // Big-Endian (or exotic system)\n    }\n}\n\n// Function to swap the byte order of a 32-bit integer (Endian Swap)\nuint32_t swap_endian(uint32_t val) {\n    // Uses bitwise shifts and AND masks for a portable swap operation\n\n    return ((val &amp; 0xFF000000) &gt;&gt; 24) | // Move Byte 3 (MSB) to Byte 0 (LSB) position\n           ((val &amp; 0x00FF0000) &gt;&gt; 8) |  // Move Byte 2 to Byte 1 position\n           ((val &amp; 0x0000FF00) &lt;&lt; 8) |  // Move Byte 1 to Byte 2 position\n           ((val &amp; 0x000000FF) &lt;&lt; 24); // Move Byte 0 (LSB) to Byte 3 (MSB) position\n}\n\n\nint main() {\n    uint32_t original_value = 0x1A2B3C4D; // Example value\n    uint32_t swapped_value;\n\n    printf(\"Original Value: 0x%X\\n\", original_value);\n\n    // 1. Check Endianness\n    if (check_endianness()) {\n        printf(\"System Endianness: Little-Endian\\n\");\n    } else {\n        printf(\"System Endianness: Big-Endian\\n\");\n    }\n\n    // 2. Perform Endian Swap\n    swapped_value = swap_endian(original_value);\n    printf(\"Swapped Value : 0x%X\\n\", swapped_value);\n\n    // Expected Swapped Result: 0x1A2B3C4D becomes 0x4D3C2B1A \n\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#5-interpreting-signedunsigned-integers-via-bit-pattern","title":"5. Interpreting Signed/Unsigned Integers via Bit Pattern","text":"<p>This example illustrates the difference between implicit type conversion (which may cause sign extension) and pointer casting (which reinterprets the bits in memory) for signed and unsigned integers, demonstrating how the same bit pattern can represent vastly different values. </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\nvoid analyze_conversion() {\n    // 1. Small, Negative Signed Number (8-bit)\n    int8_t signed_char_val = -10; // 8-bit Two's Complement: 1111 0110\n\n    // 2. Implicit Conversion to Wider Unsigned Type\n    // C rule: signed_char_val is first promoted to int (with sign extension), then converted to unsigned int.\n    uint32_t unsigned_int_val = signed_char_val; \n\n    // 3. Illustrating Sign Extension in Conversion\n    // The bit pattern of signed_char_val (which is 0xFFFFFFF6 as a 32-bit int) is interpreted as a uint32_t.\n    // Result is the large positive number (4294967286)\n\n    printf(\"--- Implicit Conversion of Negative Number to Wider Unsigned Type ---\\n\");\n    printf(\"Original Value (int8_t): %d\\n\", signed_char_val);\n    printf(\"Unsigned Value (uint32_t): %u\\n\", unsigned_int_val);\n\n    // Rationale: C performed sign extension:\n    // 1111 0110 (-10) -&gt; 1111 1111 1111 1111 1111 1111 1111 0110 (32-bit int)\n    // This bit pattern, when interpreted as uint32_t, becomes a large positive number.\n\n    // 4. Interpreting Bit Pattern via Pointer Casting\n    int32_t signed_int_val = -1; // 32-bit: 1111...1111\n\n    // Pointer cast: Changes the type of the memory address, does not copy the data, only reinterprets it.\n    // The bit pattern in memory remains the same.\n    uint32_t *unsigned_ptr = (uint32_t *)&amp;signed_int_val;\n\n    printf(\"\\n--- Interpretation via Pointer Casting ---\\n\");\n    printf(\"Original Value (int32_t): %d\\n\", signed_int_val);\n    // The bit pattern 0xFFFFFFFF, when interpreted as uint32_t, equals the maximum unsigned value.\n    printf(\"Pointer Interpretation (uint32_t): %u\\n\", *unsigned_ptr); \n\n    // Note: Casting the pointer provides a guaranteed way to get the unsigned counterpart of a negative number's bit pattern.\n}\n\nint main() {\n    analyze_conversion();\n    return 0;\n}\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/","title":"General Concepts and Terms","text":""},{"location":"c/3_general_concepts_and_terms/#general-concepts-and-terms","title":"General Concepts and Terms","text":""},{"location":"c/3_general_concepts_and_terms/#1-tokens-and-their-types","title":"1. Tokens and Their Types","text":"<p>The smallest meaningful parts of a source file written in a programming language are called tokens. Before a C program is compiled, it is broken down into tokens (tokenizing / lexical analysis).</p> <p>Tokens are divided into 6 basic groups:</p>"},{"location":"c/3_general_concepts_and_terms/#11-keywords","title":"1.1 Keywords","text":"<p>These are words with predefined special meanings in the C language. These words cannot be used for any other purpose (e.g., as variable names).</p>"},{"location":"c/3_general_concepts_and_terms/#c89-standard-keywords-32-in-total","title":"C89 Standard Keywords (32 in total)","text":"<pre><code>auto break case char const continue default do double else enum extern \nfloat for goto if int long register return short signed sizeof static \nstruct switch typedef union unsigned void volatile while\n</code></pre> <p>Note: - The C language is case-sensitive. - Therefore, <code>register</code> is a keyword, but <code>REGISTER</code> or <code>Register</code> can be used.</p>"},{"location":"c/3_general_concepts_and_terms/#12-identifiers","title":"1.2 Identifiers","text":"<p>These are the names given to variables, functions, macros, or constants. The validity of identifiers is defined by specific rules (for example, they must start with a letter and cannot contain spaces).</p> <pre><code>int counter;\nfloat average;\nchar name[20];\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#13-operators","title":"1.3 Operators","text":"<p>These are symbols that perform predefined operations. For example, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&gt;=</code>, <code>&lt;=</code> are operators. There are 45 operators in the C language.</p> <p>Some operators consist of two characters and do not contain spaces: <code>++</code>, <code>--</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code></p> <p>For example, exponentiation (<code>^</code>) is not an operator in C; instead, the pow() function is used.</p> <pre><code>#include &lt;math.h&gt;\nint main() {\n    double result = pow(2, 3); // 2 to the power of 3\n}\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#14-constants","title":"1.4 Constants","text":"<p>These are atoms whose values do not change throughout the program.</p> <pre><code>int a = 10;       // 10 is an integer constant\nfloat pi = 3.14;  // 3.14 is a real number constant\nchar c = \u2018A\u2019;     // Character constant\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#15-strings","title":"1.5 Strings","text":"<p>These are fixed character sequences enclosed in double quotes. A string is treated as a single atom in a program.</p> <pre><code>printf(\u201cHello World!\u201d);\n</code></pre> <p><code>\u201cSTRINGS ARE ALSO ATOMS\u201d</code> is a string.</p>"},{"location":"c/3_general_concepts_and_terms/#16-delimiters-and-punctuation-marks","title":"1.6 Delimiters and Punctuation Marks","text":"<p>Used to separate atoms from each other. Examples: </p><pre><code>( ) , ; { } [ ] &lt; &gt; # \" '\n</code></pre> <p>Translated with DeepL.com (free version)</p>"},{"location":"c/3_general_concepts_and_terms/#2-breaking-down-a-c-program-into-its-building-blocks","title":"2. Breaking Down a C Program into Its Building Blocks","text":"<p>Example program:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int number, k;\n    int total = 0;\n\n    printf(\u201cPlease enter a number\\n\u201d);\n    scanf(\u201c%d\u201d, &amp;number);\n\n    for (k = 1; k &lt;= number; ++k)\n        total += k;\n\n    printf(\u201cTotal = %d\\n\u201d, total);\n    return 0;\n}\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#the-atoms-of-this-program","title":"The atoms of this program:","text":"Type Examples Keywords include, int, for, return Names main, number, total, printf, scanf Operators =, &lt;=, ++, += Constants 0, 1 Strings \u201cplease enter a number\\n\u201d, \u201c%d\u201d, \u201ctotal = %d\\n\u201d Delimiters &lt;, &gt;, (, ), {, }, ;, ,"},{"location":"c/3_general_concepts_and_terms/#3-object","title":"3. Object","text":"<p>These are areas that occupy space in memory and whose contents can be accessed. For an expression to be considered an object, it must have a physical address in memory.</p> <pre><code>int a = 10;\nint b = 20;\nint result = a + b;\n</code></pre> <ul> <li><code>a</code>, <code>b</code>, <code>result</code> \u2192 are objects.  </li> <li><code>10</code>, <code>20</code> \u2192 are constants (not objects).</li> </ul>"},{"location":"c/3_general_concepts_and_terms/#properties-of-objects","title":"Properties of Objects","text":"Property Description Name The name given by the programmer. Value The information stored in memory by the object. Type The length and interpretation format of the object in memory. <p>Each type occupies a different amount of space in memory. For example, <code>int</code> is 4 bytes, <code>char</code> is 1 byte, <code>double</code> is 8 bytes.</p> <p>Every variable is an object, but not every object is a variable (e.g., pointers).</p>"},{"location":"c/3_general_concepts_and_terms/#4-data-types","title":"4. Data Types","text":""},{"location":"c/3_general_concepts_and_terms/#41-built-in-types","title":"4.1 Built-in Types","text":"<p>There are 11 built-in types in the C language. Examples: <code>int</code>, <code>float</code>, <code>double</code>, <code>char</code>, <code>void</code>, <code>short</code>, <code>long</code>, <code>signed</code>, <code>unsigned</code>, <code>enum</code>, <code>struct</code></p>"},{"location":"c/3_general_concepts_and_terms/#42-user-defined-types","title":"4.2 User-Defined Types","text":"<p>Programmers can define their own types using <code>struct</code>, <code>union</code>, or <code>enum</code>.</p> <pre><code>typedef struct {\n    char name[20];\n    int age;\n} Person;\n</code></pre> <p>There is no <code>bool</code> type in C89. Logical values are typically represented using <code>int</code> (<code>0</code> = false, <code>1</code> = true).</p>"},{"location":"c/3_general_concepts_and_terms/#5-scope","title":"5. Scope","text":"<p>The program area where a name can be recognized by the compiler.</p> <pre><code>int x = 10; // global scope\n\nvoid func() {\n    int y = 20; // local scope\n    printf(\u201c%d %d\u201d, x, y);\n}\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#6-storage-duration","title":"6. Storage Duration","text":"<p>The time interval during which an object exists while the program is running.</p> Type Description Automatic (auto) Defined within a function, disappears when the function ends. Static (static) Remains in memory for the duration of the program. Dynamic (malloc/free) Managed by the programmer. <pre><code>void f() {\n    static int count = 0;\n    count++;\n    printf(\u201c%d\\n\u201d, count);\n}\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#7-linkage","title":"7. Linkage","text":"<p>The ability of an object to be recognized in other modules of the program.</p> <pre><code>// file1.c\nint globalVar = 42;\n\n// file2.c\nextern int globalVar;\nprintf(\u201c%d\u201d, globalVar);\n</code></pre> <p>The <code>extern</code> keyword indicates that the variable is defined in another file.</p>"},{"location":"c/3_general_concepts_and_terms/#8-expression","title":"8. Expression","text":"<p>It is a combination of variables, operators, and constants.</p> <pre><code>a + b / 2\nc * 2\nd = h + 34\n</code></pre> <p>Every expression produces a value.</p>"},{"location":"c/3_general_concepts_and_terms/#9-left-hand-side-value-l-value-expression","title":"9. Left-Hand Side Value (L-Value expression)","text":"<p>These are expressions that represent an object in memory. They can be found on the left side of an assignment.</p> <pre><code>int a, b;\na = 17;     // \u2018a\u2019 is an l-value\nb = a + 2;  // \u2018b\u2019 is an l-value, (a + 2) is an r-value\n</code></pre> <p><code>a + b = 25;</code> \u2192 invalid because <code>(a + b)</code> does not refer to an object.</p>"},{"location":"c/3_general_concepts_and_terms/#10-right-hand-side-value-r-value-expression","title":"10. Right-Hand Side Value (R-Value expression)","text":"<p>These are expressions that do not refer to an object, but only produce a value. They can be placed on the right side of an assignment.</p> <pre><code>int a = 10;\nint b = a + 5; // (a + 5) is an r-value\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#11-constant-expressions","title":"11. Constant Expressions","text":"<p>These are expressions consisting only of constants. They can be evaluated by the compiler during the compilation phase.</p> <pre><code>#define SIZE 10\nint arr[SIZE + 5]; // the compiler can calculate this\n</code></pre> <p>Examples: </p><pre><code>10\n3.5\n10 + 20\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#12-statement","title":"12. Statement","text":"<p>In C, it means a complete command and ends with <code>;</code>.</p> <pre><code>result = number1 * number2;\n</code></pre> <p>Some statements only provide information: - Declaration statements \u2192 provide information to the compiler. - Executable statements \u2192 perform an operation.</p> <pre><code>int x;            // declaration\nx = 5;            // executable statement\nprintf(\u201c%d\u201d, x);  // executable statement\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#additional-codes","title":"Additional Codes","text":""},{"location":"c/3_general_concepts_and_terms/#1-basic-l-value-and-r-value-assignment","title":"1. Basic L-value and R-value Assignment","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int x = 10;\n    int y = 5;\n\n    // L-value: x (persistent memory location)\n    // R-value: y + 2 (temporary value calculated on the fly)\n    x = y + 2; \n\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#2-modifying-memory-via-pointer-dereference-l-value","title":"2. Modifying Memory via Pointer Dereference (L-value)","text":"<pre><code>#include &lt;stdio.h&gt;\n/*\nIf you can take the address of an expression using '&amp;', it is an **L-value**.\n*/\nint main() {\n    int x = 10;\n    // &amp;x is valid because x is an L-value\n    printf(\"Address of x: %p\\n\", (void*)&amp;x); \n\n    // printf(\"%p\", &amp;(x + 1)); // \u274c Error: (x + 1) is an R-value (temporary result)\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int a = 10;\n    int *p = &amp;a; // p stores the address of a\n\n    *p = 25;  // *p is an L-value because it refers to memory location 'a'\n    printf(\"a = %d\\n\", a);\n    return 0;\n}\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#3-function-return-values-as-l-values-or-r-values","title":"3. Function Return Values as L-values or R-values","text":"<pre><code>#include &lt;stdio.h&gt;\n\n// Returns an R-value (a copy of the static value)\nint func1() {\n    static int x = 5;\n    return x;  \n}\n\n// Returns a pointer (an L-value address)\nint* func2() {\n    static int y = 10;\n    return &amp;y; // Returns the persistent address of 'y'\n}\n\nint main() {\n    // func1() = 20; \u274c Error: func1 returns an R-value (a temporary value)\n\n    // *func2() is an L-value because it dereferences a persistent address (the address of static int y)\n    *func2() = 30;   // \u2705 Valid: Modifies the static variable 'y'\n\n    printf(\"Value pointed to by func2(): %d\\n\", *func2()); // Output: 30\n    return 0;\n}\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#4-counter","title":"4. counter","text":"<pre><code>// counter_module.c\n\n#include &lt;stdio.h&gt;\n\n// Global 'count' variable with internal linkage (only visible in this file)\n// Static Storage Duration guaranteed.\nstatic int private_counter = 0; \n\n// Function with external linkage (visible to other files via header)\n// Increments the internal static counter\nvoid increment_counter(void) {\n    private_counter++;\n}\n\n// Function with external linkage\n// Returns the internal counter's value (R-value)\nint get_counter_value(void) {\n    return private_counter;\n}\n\n// Advanced: Returns a pointer to a static local L-value\n// The L-value itself (the static variable) has persistent storage duration.\nint* get_static_local_lvalue(void) {\n    // Static local variable: Block scope, but Static Storage Duration\n    static int persistent_config = 99; \n    return &amp;persistent_config; // Returns the address of the L-value\n}\n</code></pre> <pre><code>// counter_module.h\n\n#ifndef COUNTER_MODULE_H\n#define COUNTER_MODULE_H\n\n// Declarations (External Linkage assumed by default for functions)\nvoid increment_counter(void);\nint get_counter_value(void);\n\n// Declaration for the advanced L-value return function\nint* get_static_local_lvalue(void); \n\n// Note: The variable 'private_counter' itself is NOT declared here, \n// ensuring internal linkage and data hiding.\n\n#endif // COUNTER_MODULE_H\n</code></pre> <pre><code>// main.c\n\n#include &lt;stdio.h&gt;\n#include \"counter_module.h\" // Includes function prototypes\n\nint main() {\n    printf(\"--- Module Access and Linkage Test ---\\n\");\n\n    // 1. Storage Duration &amp; Scope Test\n\n    // Call the function to increment the hidden counter\n    increment_counter();\n    increment_counter();\n\n    // Access the value using the public getter function\n    printf(\"Counter value after 2 increments: %d\\n\", get_counter_value()); // Output: 2\n\n    // 2. L-value Manipulation Test (Advanced)\n\n    // Get the address of the static local L-value from the module\n    int *config_ptr = get_static_local_lvalue(); \n\n    // *config_ptr is an L-value expression; its address is persistent.\n    // We can directly modify the value stored at that persistent memory location.\n    *config_ptr = 500; \n\n    printf(\"Static local variable modified to: %d\\n\", *config_ptr); // Output: 500\n\n    // 3. Linkage Failure Attempt (Illustrative Note)\n\n    /* // int check_counter = private_counter; \n    // \u274c ERROR: private_counter has internal linkage and is NOT accessible here.\n    // The extern keyword would not work unless the variable was defined globally \n    // without 'static' in counter_module.c.\n    */\n\n    return 0;\n}\n</code></pre>"},{"location":"c/4_creating_a_c_program/","title":"Creating a C Program","text":""},{"location":"c/4_creating_a_c_program/#creating-a-c-program","title":"Creating a C Program","text":""},{"location":"c/4_creating_a_c_program/#1-creating-the-source-file","title":"1. Creating the Source File","text":"<p>C programs are written as text-based source files. These files are usually created using a text editor.</p> <ul> <li>Files are written according to the syntax rules of the C language.  </li> <li>Traditionally, C source files have the extension <code>.c</code>.</li> </ul> <p>For example: </p><pre><code>main.c\nmathutils.c\n</code></pre> <p>The source file contains only plain text; it cannot be run before compilation.</p>"},{"location":"c/4_creating_a_c_program/#2-compilation-stage","title":"2. Compilation Stage","text":"<p>Programs that translate a program written in one programming language into another language are called translators. In the C language, the translator that does this job is called a compiler.</p>"},{"location":"c/4_creating_a_c_program/#compilation-process","title":"Compilation Process","text":"<ul> <li>The compiler takes the source file.  </li> <li>It checks whether it complies with the syntax rules.  </li> <li>If successful, it produces an object file.  </li> <li>If unsuccessful, it gives an error or warning message.</li> </ul>"},{"location":"c/4_creating_a_c_program/#compile-time","title":"Compile Time","text":"<p>The stage during which the compiler processes the source file is called compile time. During this stage, the following types of messages may be generated:</p> Type Description Result Error message Syntax or language rule violation Compilation fails, object file is not created Warning message Potential logical error Compilation may complete, object file is produced <p>According to C standards, compilers report not only syntax errors but also potential logical errors as warnings.</p>"},{"location":"c/4_creating_a_c_program/#3-object-files","title":"3. Object Files","text":"<p>Files produced during the compilation phase are files that have been translated into machine language but cannot yet be run independently.</p> Operating System Extension Example UNIX / Linux <code>.o</code> <code>main.o</code> Windows / DOS <code>.obj</code> <code>main.obj</code> <p>Object files are usually combined during the linking phase.</p>"},{"location":"c/4_creating_a_c_program/#4-linker-program","title":"4. Linker Program","text":"<p>The linker combines one or more compiled object files to create an executable file.</p>"},{"location":"c/4_creating_a_c_program/#result-files","title":"Result Files","text":"Operating System Extension Example UNIX / Linux (usually no extension) <code>program</code> Windows <code>.exe</code> <code>program.exe</code> <p>\ud83d\udd39 The linker also incorporates external libraries (such as <code>stdio.h</code>, <code>math.h</code>) into the program.</p>"},{"location":"c/4_creating_a_c_program/#5-compiler-programs","title":"5. Compiler Programs","text":"<p>Compilers are generally designed to be run from the command line. This allows them to be easily called by other tools or IDEs.</p> Platform Compiler Executable File Microsoft Windows MSVC <code>cl.exe</code> UNIX / Linux GNU C Compiler <code>gcc</code> or <code>clang</code>"},{"location":"c/4_creating_a_c_program/#example-compilers","title":"Example Compilers","text":"<ul> <li>GCC (GNU Compiler Collection) \u2192 popular, open source.  </li> <li>Clang \u2192 a modern and fast alternative.  </li> <li>MSVC \u2192 Microsoft Visual C/C++ compiler.</li> </ul>"},{"location":"c/4_creating_a_c_program/#6-ide-integrated-development-environment","title":"6. IDE (Integrated Development Environment)","text":"<p>An IDE is not a compiler. It is a development environment that runs the compiler in the background and facilitates software development.</p> IDE Compiler Used Dev-C++ GCC Code::Blocks GCC or Clang Visual Studio MSVC MinGW GCC (for Windows) <p>An IDE can automatically perform compilation and linking operations and present error messages to the user in an easy-to-understand manner.</p>"},{"location":"c/4_creating_a_c_program/#7-preprocessor","title":"7. Preprocessor","text":"<p>In C and C++, it is a program that runs before the compilation stage. At this stage, text-based operations are performed on the source code (e.g., <code>#include</code>, <code>#define</code>).</p> <p>Before passing to the compiler, the preprocessor: - Processes macros (<code>#define</code>), - Performs file inclusions (<code>#include</code>), - Evaluates conditional compilation directives (<code>#ifdef</code>, <code>#ifndef</code>).</p> <p>The preprocessor is a separate program, but most modern compilers (e.g., GCC) call it automatically.</p>"},{"location":"c/4_creating_a_c_program/#8-general-summary-of-the-process","title":"8. General Summary of the Process","text":"<p>The C program development process goes through the following steps:</p> <pre><code>Source Code (.c)\n      \u2193\n  [Preprocessor]\n      \u2193\n  [Compiler]\n      \u2193\n  Object File (.obj / .o)\n      \u2193\n  [Linker]\n      \u2193\nExecutable Program (.exe / program)\n</code></pre>"},{"location":"c/4_creating_a_c_program/#9-example-codes","title":"9. Example codes","text":""},{"location":"c/4_creating_a_c_program/#mainc-mathutilsc-mathutilsh","title":"main.c mathutils.c mathutils.h","text":"<pre><code>// mathutils.h\n\n#ifndef MATHUTILS_H\n#define MATHUTILS_H\n\n// Function declaration with external linkage\n// Declares that a function named 'calculate_distance' is defined elsewhere.\ndouble calculate_distance(int x1, int y1, int x2, int y2);\n\n#endif // MATHUTILS_H\n</code></pre> <pre><code>// mathutils.c\n// This module provides the mathematical implementation.\n\n#include \"mathutils.h\"\n#include &lt;math.h&gt; // Required for sqrt() and pow() function definitions\n\n// Definition of the function declared in mathutils.h\ndouble calculate_distance(int x1, int y1, int x2, int y2) {\n    // Uses the standard C math library functions\n    int dx = x2 - x1;\n    int dy = y2 - y1;\n\n    // pow(base, exponent) and sqrt() are external library functions (libm.a on Unix/Linux)\n    return sqrt(pow(dx, 2) + pow(dy, 2));\n}\n</code></pre> <pre><code>// main.c\n\n#include &lt;stdio.h&gt;\n#include \"mathutils.h\" // Includes the function prototype\n\nint main() {\n    int p1_x = 10, p1_y = 20;\n    int p2_x = 40, p2_y = 60;\n    double dist;\n\n    // Call the function defined in mathutils.c\n    dist = calculate_distance(p1_x, p1_y, p2_x, p2_y);\n\n    printf(\"Distance between (%d,%d) and (%d,%d) is: %.2lf\\n\",\n           p1_x, p1_y, p2_x, p2_y, dist);\n\n    return 0;\n}\n</code></pre>"},{"location":"c/4_creating_a_c_program/#91object-files","title":"9.1.Object files","text":"<pre><code>gcc -c main.c      # -&gt;main.o\ngcc -c mathutils.c # -&gt;mathutils.o\n</code></pre>"},{"location":"c/4_creating_a_c_program/#92linkage","title":"9.2.Linkage","text":"<pre><code>gcc main.o mathutils.o -o program\n</code></pre>"},{"location":"c/4_creating_a_c_program/#93run","title":"9.3.Run","text":"<pre><code>./program\n</code></pre>"},{"location":"c/4_creating_a_c_program/#generate-object-files-link-run","title":"Generate object files + link + run","text":"<pre><code>gcc main.c mathutils.c -o program\n./program\n</code></pre>"},{"location":"c/4_creating_a_c_program/#glossary-of-terms","title":"Glossary of Terms","text":"Term English Description Source file Source file Text file written by the programmer Compiler Compiler Converts source code to machine code Object file Object file Compiled but not yet executable code Linker Linker Combines object files Preprocessor Preprocessor Performs text processing before compilation IDE Integrated Development Environment Development environment"},{"location":"c/5_data_types/","title":"Data Types","text":""},{"location":"c/5_data_types/#data-types","title":"Data Types","text":""},{"location":"c/5_data_types/#1-what-is-a-type","title":"1. What is a Type?","text":"<p>An object's type determines how that object will be represented in memory and what operations can be performed on it. Type is an essential feature of an object. An object without a type cannot be discussed.</p> <p>Based on type information, the compiler determines: - How much space the data will occupy in memory, - How the 1s and 0s in memory will be interpreted, - Which operations can be performed on that data.</p>"},{"location":"c/5_data_types/#2-grouping-types","title":"2. Grouping Types","text":"<p>Types in the C language are divided into two main groups:</p> Type Group Description 1. Built-in Types Standard types that exist by design in the C language. (e.g., <code>int</code>, <code>float</code>, <code>char</code>) 2. User-defined Types Allows the programmer to define new types. (e.g., <code>struct</code>, <code>union</code>, <code>enum</code>) <p>If the predefined types are not sufficient, the programmer can define their own type using structures such as <code>typedef</code>, <code>struct</code>, <code>enum</code>, and <code>union</code>.</p>"},{"location":"c/5_data_types/#3-integer-types","title":"3. Integer Types","text":"<p>In the C language, integer types represent negative or positive integers. There are a total of 8 integer types (including signed and unsigned versions).</p>"},{"location":"c/5_data_types/#signed-and-unsigned","title":"Signed and Unsigned","text":"<ul> <li>Signed: Can hold negative and positive values.  </li> <li>Unsigned: Holds only positive values (and zero).</li> </ul>"},{"location":"c/5_data_types/#integer-types","title":"Integer Types","text":"Type Size (byte) Value Range Description <code>signed char</code> 1 -128 \u2192 +127 1 byte, signed character type <code>unsigned char</code> 1 0 \u2192 255 1 byte, unsigned character type <code>char</code> 1 Compiler-dependent May be signed or unsigned <code>short int</code> / <code>signed short int</code> 2 -32,768 \u2192 +32,767 Short integer <code>unsigned short int</code> 2 0 \u2192 65,535 Unsigned short integer <code>int</code> / <code>signed int</code> 2 or 4 -32,768 \u2192 +32,767 (2B) or -2,147,483,648 \u2192 +2,147,483,647 (4B) System-dependent <code>unsigned int</code> 2 or 4 0 \u2192 65,535 (2B) or 0 \u2192 4,294,967,295 (4B) System dependent <code>long int</code> / <code>signed long int</code> 4 -2,147,483,648 \u2192 +2,147,483,647 Long integer <code>unsigned long int</code> 4 0 \u2192 4,294,967,295 Long unsigned integer <code>long long int</code> (C99) 8 -9,223,372,036,854,775,808 \u2192 +9,223,372,036,854,775,807 Very large integers <code>unsigned long long int</code> (C99) 8 0 \u2192 18,446,744,073,709,551,615 <p>The <code>char</code> type must be 1 byte according to the C standard.</p>"},{"location":"c/5_data_types/#4-floating-point-types","title":"4. Floating-Point Types","text":"<p>There are 3 basic types for real numbers (floating-point numbers):</p> Type Size (byte) Precision Range (approx.) Description <code>float</code> 4 6 digits 1.17 \u00d7 10\u207b\u00b3\u2078 \u2192 3.40 \u00d7 10\u00b3\u2078 Single precision <code>double</code> 8 15 digits 2.22 \u00d7 10\u207b\u00b3\u2070\u2078 \u2192 1.17 \u00d7 10\u00b3\u2070\u2078 Double precision <code>long double</code> 8 / 10 / 12 System-dependent Not portable Extended precision"},{"location":"c/5_data_types/#ieee-754-standard","title":"IEEE 754 Standard","text":"<p>In the C language, the <code>float</code> and <code>double</code> types are generally maintained according to the IEEE 754 standard.</p> Component float (32 bits) double (64 bits) Sign bit 1 bit 1 bit Exponent 8 bits 11 bits Fraction / Mantissa 23 bits 52 bits <p>This provides approximately 6 digits of precision for <code>float</code> and 15 digits for <code>double</code>.</p>"},{"location":"c/5_data_types/#5-new-types-introduced-with-c99","title":"5. New Types Introduced with C99","text":"<p>The C99 standard added complex numbers and the bool type.</p> Type Size (byte) Description <code>_Bool</code> 1 Boolean type (<code>true</code> or <code>false</code>) <code>float _Complex</code> 8 Complex number (real and imaginary parts) <code>double _Complex</code> 16 <code>long double _Complex</code> 24 <code>float _Imaginary</code> 4 Imaginary part only <code>double _Imaginary</code> 8 <code>long double _Imaginary</code> 12"},{"location":"c/5_data_types/#6-ansi-c-portability-rules","title":"6. ANSI C Portability Rules","text":"<p>According to ANSI C standards, only certain type lengths are guaranteed:</p> <ul> <li>The <code>char</code> type must always be 1 byte.  </li> <li>The <code>short</code> \u2264 <code>int</code> \u2264 <code>long</code> rule always applies. </li> <li>Each type may have a different length depending on the system's processor architecture.</li> </ul>"},{"location":"c/5_data_types/#7-processor-architecture-examples","title":"7. Processor Architecture Examples","text":""},{"location":"c/5_data_types/#in-16-bit-systems","title":"In 16-bit systems","text":"Type Size <code>char</code> 1 byte <code>int</code> 2 bytes <code>short</code> 2 bytes <code>long</code> 4 bytes"},{"location":"c/5_data_types/#in-32-bit-systems","title":"In 32-bit systems","text":"Type Size <code>char</code> 1 byte <code>int</code> 4 bytes <code>short</code> 2 bytes <code>long</code> 4 bytes"},{"location":"c/5_data_types/#8-performance-and-usage-recommendations","title":"8. Performance and Usage Recommendations","text":"<ul> <li>Integers are faster to process than floating-point numbers.   This is because floating-point numbers are encoded in memory in a special format.  </li> <li>Unnecessary use of <code>float</code> or <code>double</code> can slow down the program.</li> <li>If integers are sufficient, <code>int</code> should be preferred.  </li> <li>If a larger range is required, <code>long</code> or <code>long long</code> can be used.  </li> <li>For real numbers, <code>double</code> should generally be the default choice.</li> </ul>"},{"location":"c/5_data_types/#additional-codes","title":"Additional codes","text":""},{"location":"c/5_data_types/#1-precision-and-speed-test","title":"1. precision and speed test","text":"<p>This code demonstrates the difference in precision between float and double and measures how much faster integer arithmetic is compared to floating-point arithmetic in a simple loop. </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;time.h&gt; // For performance measurement (clock_t)\n#include &lt;limits.h&gt; // For loop limits\n\n// Test parameters\n#define ITERATIONS 100000000\n#define CLOCK_UNIT CLOCKS_PER_SEC // Defined in &lt;time.h&gt;\n\nvoid analyze_float_precision() {\n    float f = 123456789.0f; \n    double d = 123456789.0;\n\n    printf(\"--- 1. Precision Test ---\\n\");\n    // float has around 6-7 digits of precision. The last digits are lost.\n    printf(\"Float (low precision): %.2f\\n\", f); \n    // Double retains higher precision.\n    printf(\"Double (high precision): %.2f\\n\", d); \n    printf(\"\\n\");\n}\n\nvoid analyze_performance_difference() {\n    clock_t start, end;\n    double time_used;\n    long i;\n\n    printf(\"--- 2. Performance Test (Iteration Count: %d) ---\\n\", ITERATIONS);\n\n    // Integer Arithmetic Test (Fast)\n    long int_sum = 0;\n    start = clock();\n    for (i = 0; i &lt; ITERATIONS; i++) {\n        int_sum += (i &amp; 0x0F); // Simple bitwise operation to ensure constant work\n    }\n    end = clock();\n    time_used = ((double)(end - start)) / CLOCK_UNIT;\n    printf(\"Integer Time (int_sum): %.4f seconds\\n\", time_used);\n\n\n    // Floating-Point Arithmetic Test (Slower)\n    double float_sum = 0.0;\n    start = clock();\n    for (i = 0; i &lt; ITERATIONS; i++) {\n        float_sum += (i * 1.0) / 10.0; // Floating point division and addition\n    }\n    end = clock();\n    time_used = ((double)(end - start)) / CLOCK_UNIT;\n    printf(\"Float Time (float_sum): %.4f seconds\\n\", time_used);\n\n    // Note: The integer operations are expected to be significantly faster due to the CPU architecture.\n}\n\nint main() {\n    analyze_float_precision();\n    analyze_performance_difference();\n    return 0;\n}\n</code></pre>"},{"location":"c/5_data_types/#2-defining-a-portable-structure","title":"2. Defining a Portable Structure","text":"<p>This code shows that the types in C are not portable (like the size of int) and, therefore, how we construct structures with known sizes using typedef and sizeof. This is critically important, especially in Data Structures and network programming. </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt; // For fixed-width integer types (e.g., int32_t, uint16_t)\n\n// Define a type whose size is strictly guaranteed for portability\n// This is crucial for Data Structures that rely on fixed sizes (like network packets or file storage).\ntypedef struct {\n    // We use types from stdint.h to ensure fixed sizes regardless of the system architecture.\n    uint16_t id;    // Guaranteed 2 bytes (short)\n    int32_t count;  // Guaranteed 4 bytes (int/long)\n    double price;   // Standard 8 bytes\n} ProductData;\n\n\nint main() {\n    ProductData item;\n\n    printf(\"--- Portable Type Analysis ---\\n\");\n\n    // 1. Check fixed sizes guaranteed by stdint.h\n    printf(\"Size of uint16_t (ID): %zu bytes\\n\", sizeof(uint16_t)); \n    printf(\"Size of int32_t (Count): %zu bytes\\n\", sizeof(int32_t));\n\n    // 2. Check the size of the structure itself (may include padding/alignment)\n    printf(\"Size of ProductData Structure: %zu bytes\\n\", sizeof(ProductData));\n\n    // 3. Robustly calculate array size using sizeof (as taught in the previous section)\n    int my_array[] = {10, 20, 30, 40, 50};\n    size_t array_length = sizeof(my_array) / sizeof(my_array[0]);\n    printf(\"Calculated Array Length (Robust): %zu\\n\", array_length);\n\n    // Note: Using int32_t instead of plain int ensures the structure layout is consistent \n    // across 16-bit, 32-bit, and 64-bit systems, which is vital for DSA and I/O.\n\n    return 0;\n}\n</code></pre>"},{"location":"c/5_data_types/#3-same-bit-in-different-data-type","title":"3. same bit in different data type","text":"<pre><code>#include &lt;stdio.h&gt;\n/*\n01000001 -&gt; 65 -&gt; 'A'\nthis bit pattern can represent different data types\n*/\n\nint main() {\n    int i = 65;\n    char c = 'A';\n\n    printf(\"int olarak: %d\\n\", i);\n    printf(\"char olarak: %c\\n\", c);\n    printf(\"Bellekte ayn\u0131 de\u011feri farkl\u0131 t\u00fcrle yorumlama: %c\\n\", (char)i);\n    return 0;\n}\n</code></pre>"},{"location":"c/5_data_types/#4-for-your-computer-sizeof","title":"4. for your computer sizeof","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;limits.h&gt;\n\nint main() {\n    printf(\"char: %zu byte, [%d, %d]\\n\", sizeof(char), CHAR_MIN, CHAR_MAX);\n    printf(\"short: %zu byte, [%d, %d]\\n\", sizeof(short), SHRT_MIN, SHRT_MAX);\n    printf(\"int: %zu byte, [%d, %d]\\n\", sizeof(int), INT_MIN, INT_MAX);\n    printf(\"long: %zu byte, [%ld, %ld]\\n\", sizeof(long), LONG_MIN, LONG_MAX);\n    printf(\"long long: %zu byte, [%lld, %lld]\\n\", sizeof(long long), LLONG_MIN, LLONG_MAX);\n    return 0;\n}\n</code></pre>"},{"location":"c/5_data_types/#5-signed-unsigned","title":"5. signed unsigned","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    signed char a = -1;\n    unsigned char b = -1;\n\n    printf(\"signed char a = %d\\n\", a);\n    printf(\"unsigned char b = %u\\n\", b);\n    return 0;\n}\n</code></pre>"},{"location":"c/5_data_types/#6-float-and-double","title":"6. float and double","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    float f = 1.0 / 3.0;\n    double d = 1.0 / 3.0;\n\n    printf(\"float = %.10f\\n\", f);\n    printf(\"double = %.20lf\\n\", d);\n    return 0;\n}\n</code></pre>"},{"location":"c/5_data_types/#7-ieee-754","title":"7. IEEE 754","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    float f = -6.5f;\n    unsigned int *p = (unsigned int*)&amp;f;\n\n    printf(\"float: %f\\nbinary: \", f);\n    for (int i = 31; i &gt;= 0; i--) {\n        printf(\"%d\", (*p &gt;&gt; i) &amp; 1);\n        if (i == 31 || i == 23) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"c/5_data_types/#8-c99-bool-complex","title":"8. C99 bool complex","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;complex.h&gt;\n\nint main() {\n    bool flag = true;\n    double complex z = 2.0 + 3.0 * I;\n\n    printf(\"bool \u00f6rne\u011fi: %d\\n\", flag);\n    printf(\"complex \u00f6rne\u011fi: %.1f + %.1fi\\n\", creal(z), cimag(z));\n    return 0;\n}\n</code></pre>"},{"location":"c/5_data_types/#9-data-types-and-performance","title":"9. data types and performance","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n\nint main() {\n    clock_t start, end;\n    int i;\n    double t;\n\n    start = clock();\n    for (i = 0; i &lt; 100000000; ++i) { int x = i * 2; }\n    end = clock();\n    t = ((double)(end - start)) / CLOCKS_PER_SEC;\n    printf(\"int i\u015flemleri: %.3f saniye\\n\", t);\n\n    start = clock();\n    for (i = 0; i &lt; 100000000; ++i) { double x = i * 2.0; }\n    end = clock();\n    t = ((double)(end - start)) / CLOCKS_PER_SEC;\n    printf(\"double i\u015flemleri: %.3f saniye\\n\", t);\n    return 0;\n}\n</code></pre>"},{"location":"c/6_declarations_and_definitions/","title":"Declarations and Definitions","text":""},{"location":"c/6_declarations_and_definitions/#declaration-and-definition","title":"Declaration and Definition","text":""},{"location":"c/6_declarations_and_definitions/#1-declaration","title":"1. Declaration","text":"<p>A declaration statement provides information to the compiler at compile time. This information relates to the type, name, and existence of the variable or function.</p> <p>Example: </p><pre><code>extern int count;\nvoid printCount();\n</code></pre> It informs the compiler that \u201cthere is an integer variable named <code>count</code> and a function named <code>printCount()</code>.\u201d However, it does not allocate memory."},{"location":"c/6_declarations_and_definitions/#2-definition","title":"2. Definition","text":"<p>Definition causes the compiler to allocate memory. Unlike declaration, definition creates a real object.</p> <p>Example: </p><pre><code>int count = 5; // Definition\n</code></pre> This statement allocates memory for the <code>count</code> variable. Every definition is a declaration; however, not every declaration is a definition.  Operation What the Compiler Does Declaration Receives information, does not allocate space Declaration Receives information and allocates space in memory"},{"location":"c/6_declarations_and_definitions/#3-variable-declaration","title":"3. Variable Declaration","text":"<p>In C, a variable must be declared before it is used. The compiler allocates the appropriate amount of memory for the variable, knowing its type and name.</p> <p>General Syntax: </p><pre><code>&lt;type-specifying words&gt; &lt;variable name&gt;;\n</code></pre> <p>Examples: </p><pre><code>int total;\nunsigned long counter;\nfloat average;\n</code></pre> <p>The semicolon (<code>;</code>) terminates the statement. In C, <code>;</code> is the \u201cperiod\u201d of the expression.</p>"},{"location":"c/6_declarations_and_definitions/#4-type-specifying-keywords","title":"4. Type-Specifying Keywords","text":"<p>Keywords that can be used: </p><pre><code>signed, unsigned, char, short, int, long, float, double\n</code></pre> All keywords are written in lowercase. The C language is case-sensitive."},{"location":"c/6_declarations_and_definitions/#equivalent-type-declarations","title":"\ud83d\udd38 Equivalent Type Declarations","text":"Type Equivalent Notations Signed character <code>signed char</code>, <code>char</code> Unsigned character <code>unsigned char</code> Signed short integer <code>short</code>, <code>signed short</code>, <code>short int</code> Unsigned short integer <code>unsigned short</code>, <code>unsigned short int</code> Signed integer <code>int</code>, <code>signed int</code>, <code>signed</code> Unsigned integer <code>unsigned</code>, <code>unsigned int</code> Long integer <code>long</code>, <code>long int</code>, <code>signed long int</code> Unsigned long integer <code>unsigned long</code>, <code>unsigned long int</code> Floating point numbers <code>float</code>, <code>double</code>, <code>long double</code>"},{"location":"c/6_declarations_and_definitions/#5-naming-rules-identifiers","title":"5. Naming Rules (Identifiers)","text":""},{"location":"c/6_declarations_and_definitions/#valid-characters","title":"Valid characters:","text":"<ul> <li><code>a-z</code>, <code>A-Z</code></li> <li><code>0-9</code></li> <li><code>_</code> (underscore)</li> </ul>"},{"location":"c/6_declarations_and_definitions/#invalid-characters","title":"Invalid characters:","text":"<p>Spaces, Turkish characters (<code>\u00e7, \u011f, \u00fc, \u00f6, \u015f, \u0131</code> etc.), <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>&amp;</code>, <code>$</code> etc.</p>"},{"location":"c/6_declarations_and_definitions/#rules","title":"Rules:","text":"<ul> <li>Names cannot start with a number.</li> <li>They can start with the <code>_</code> character.</li> <li>Keywords cannot be used as names.</li> <li>Case sensitivity matters (<code>var</code>, <code>Var</code>, <code>VAR</code> are different).</li> <li>At least 31 characters are guaranteed to be considered.</li> </ul>"},{"location":"c/6_declarations_and_definitions/#long-and-meaningful-names","title":"Long and Meaningful Names","text":"<p>Names should express the purpose of the variable: </p><pre><code>int tax_rate;\nint number_of_students;\n</code></pre> <code>_</code> or CamelCase is often used instead of spaces: <pre><code>int total_price;\nint TotalPrice;\n</code></pre>"},{"location":"c/6_declarations_and_definitions/#6-declaration-examples","title":"6. Declaration Examples","text":"<pre><code>int x;\nunsigned long int var;\ndouble MFCS;\nunsigned _result;\nsigned short total;\n</code></pre> <p>Multiple variables of the same type: </p><pre><code>unsigned char ch1, ch2, ch3, ch4;\nfloat fl1, fl2;\nint tax_rate, tax_base;\n</code></pre> <p>Defining different types on the same line is invalid: </p><pre><code>long x, int y; // Error\n</code></pre>"},{"location":"c/6_declarations_and_definitions/#keyword-order","title":"Keyword Order","text":"<pre><code>signed long int x;\nlong signed int x;\nint long signed x;\n</code></pre> All are valid, but <code>signed long int</code> is more readable."},{"location":"c/6_declarations_and_definitions/#7-locations-of-declarations-in-source-code","title":"7. Locations of Declarations in Source Code","text":"<p>Variable declarations can be made in 3 places:</p> Location Description Inside a block Local variable Outside blocks Global variable In the function parameter list Parameter declaration"},{"location":"c/6_declarations_and_definitions/#rule","title":"Rule","text":"<p>Declarations must be at the beginning of the block.</p> <pre><code>{\n    int x, y;     // Valid\n    x = 5;\n    float f;      // Invalid (there is an expression before it)\n}\n</code></pre> <p>But in a nested block: </p><pre><code>{\n    int a;\n    { float b; }  // Valid\n}\n</code></pre>"},{"location":"c/6_declarations_and_definitions/#8-null-statement","title":"8. Null Statement","text":"<p>A standalone <code>;</code> is an executable null statement. In this case, any subsequent declaration becomes invalid.</p> <pre><code>{\n    int x;;\n    int y; // Invalid\n}\n</code></pre> <p>An empty block <code>{ }</code> is also considered an executable statement.</p>"},{"location":"c/6_declarations_and_definitions/#9-initialization","title":"9. Initialization","text":"<p>When defining a variable, an initial value can be assigned. This is not an assignment, but a declaration.</p> <pre><code>int a = 20;\nint b = 10, c = 30;\n</code></pre> <p>Incorrect example: </p><pre><code>void func() {\n    int a;\n    a = 20;\n    int b; // Invalid (there is an expression before it)\n}\n</code></pre> Correct example: <pre><code>void func() {\n    int a = 20;\n    int b; // Valid\n}\n</code></pre>"},{"location":"c/6_declarations_and_definitions/#10-declaration-and-definition-in-multi-file-programs","title":"10. Declaration and Definition in Multi-File Programs","text":""},{"location":"c/6_declarations_and_definitions/#headerh","title":"header.h","text":"<pre><code>extern int count;\nvoid printCount();\n</code></pre> <code>extern</code> tells the compiler that \u201cthis variable will be defined in another file.\u201d"},{"location":"c/6_declarations_and_definitions/#mainc","title":"main.c","text":"<pre><code>#include \u201cheader.h\u201d\nint count = 5;\n\nint main() {\n    printCount();\n}\n</code></pre>"},{"location":"c/6_declarations_and_definitions/#utilc","title":"util.c","text":"<pre><code>#include \u201cheader.h\u201d\n#include &lt;stdio.h&gt;\n\nvoid printCount() {\n    printf(\u201c%d\\n\u201d, count);\n}\n</code></pre> <p><code>header.h</code> contains the declaration, <code>main.c</code> performs the definition, and <code>util.c</code> uses the declared <code>count</code>.</p>"},{"location":"c/6_declarations_and_definitions/#11-compilation-linking","title":"11. Compilation &amp; Linking","text":"<p>Compilation: </p><pre><code>gcc -c main.c   \u2192 main.o\ngcc -c util.c   \u2192 util.o\n</code></pre> Linking: <pre><code>gcc main.o util.o -o program\n</code></pre> Running: <pre><code>./program\n</code></pre> Output: <pre><code>5\n</code></pre>"},{"location":"c/6_declarations_and_definitions/#12-summary","title":"12. Summary","text":"Concept Definition Allocates Memory? Example Declaration Provides information to the compiler No <code>extern int x;</code> Definition Creates an object Yes <code>int x = 5;</code>"},{"location":"c/7_constants/","title":"Constants","text":""},{"location":"c/7_constants/#constants","title":"Constants","text":""},{"location":"c/7_constants/#1-what-is-a-constant","title":"1. What is a Constant?","text":"<p>Data is either stored within objects or written directly as constants. Constants are fixed values written directly by the programmer.</p> <p>Example: </p><pre><code>x = y + z;    // y and z are variables\nd = x + 10;   // 10 is a constant\n</code></pre> <p>The value of constants is known at compile time. This means the compiler places this value directly into the code.</p>"},{"location":"c/7_constants/#2-types-of-constants","title":"2. Types of Constants","text":"<p>Just as every object in C has a type, constants also have a type. The compiler determines the type of the constant based on its syntax.</p>"},{"location":"c/7_constants/#types","title":"Types","text":"<ul> <li>Integer constants  </li> <li>Character constants  </li> <li>Floating constants</li> </ul>"},{"location":"c/7_constants/#3-integer-constants","title":"3. Integer Constants","text":"<p>Integer constants can be one of the following types: - <code>signed int</code> - <code>unsigned int</code> - <code>signed long</code> - <code>unsigned long</code></p>"},{"location":"c/7_constants/#notation","title":"Notation","text":"Number System Notation Example Decimal <code>123</code> <code>456</code>, <code>7890</code> Octal <code>0...</code> (starts with zero) <code>0710</code>, <code>016</code> Hexadecimal <code>0x...</code> or <code>0X...</code> <code>0x1C8</code>, <code>0XFF</code> <p>In hexadecimal, digits greater than 9 are represented by the letters A\u2013F or a\u2013f.</p>"},{"location":"c/7_constants/#suffixes-used-in-integer-constants","title":"Suffixes Used in Integer Constants","text":"Suffix Meaning Example <code>u</code> / <code>U</code> Unsigned integer <code>123U</code> <code>l</code> / <code>L</code> Long integer (<code>long</code>) <code>456L</code> <code>ul</code> / <code>UL</code> Long unsigned integer (<code>unsigned long</code>) <code>789UL</code> <p>To avoid visual confusion, it is recommended to use <code>L</code> instead of <code>l</code>.</p>"},{"location":"c/7_constants/#type-determination-rules","title":"Type Determination Rules","text":"Notation Type Order <code>bb...b</code> <code>signed int</code>, <code>signed long</code>, <code>unsigned long</code> <code>0xbb...b</code> or <code>0bb...b</code> <code>signed int</code>, <code>unsigned int</code>, <code>signed long</code>, <code>unsigned long</code> <code>bb...bU</code> <code>unsigned int</code>, <code>unsigned long</code> <code>bb...bL</code> <code>signed long</code>, <code>unsigned long</code> <code>bb...bUL</code> <code>unsigned long</code> <p>The compiler selects the first type that can fit the value without overflowing from top to bottom.</p>"},{"location":"c/7_constants/#examples-for-2-byte-int-4-byte-long-systems","title":"Examples (for 2-byte int, 4-byte long systems)","text":"Notation Type <code>456</code> <code>signed int</code> <code>59654</code> <code>signed long</code> <code>0x1C8</code> <code>signed int</code> <code>987U</code> <code>unsigned int</code> <code>0XBCE1C53C</code> <code>unsigned long</code> <code>062000L</code> <code>signed long</code> <code>890765UL</code> <code>unsigned long</code>"},{"location":"c/7_constants/#4-character-constants","title":"4. Character Constants","text":"<p>They are written within single quotes <code>\u2018 \u2019</code>.</p> <p>Examples: </p><pre><code>\u2018a\u2019\n'J'\n\u20188\u2019\n':'\n\u2018\u00c7\u2019\n</code></pre> <p>A character constant is actually an integer representing the ASCII code number of that character.</p> <pre><code>char ch = \u2018a\u2019;  // ASCII 97\nch = \u2018a\u2019 + 3;   // 100 \u2192 'd'\n</code></pre>"},{"location":"c/7_constants/#escape-sequence-characters","title":"Escape Sequence Characters","text":"Constant Meaning <code>\u2018\\\\0\u2019</code> Null character <code>\u2018\\\\a\u2019</code> Bell sound <code>\u2018\\\\b\u2019</code> Backspace <code>\u2018\\\\t\u2019</code> Tab <code>\u2018\\\\n\u2019</code> Newline <code>\u2018\\\\v\u2019</code> Vertical tab <code>\u2018\\\\f\u2019</code> Form feed <code>\u2018\\\\r\u2019</code> Carriage return <code>\u2018\\\\\u2019'</code> Single quote <code>\u2018\\\\\\\"\u2019</code> Double quote <code>\u2018\\\\\\\\\u2019</code> Backslash"},{"location":"c/7_constants/#hexadecimal-and-octal-representations","title":"Hexadecimal and Octal Representations","text":"<p>Hexadecimal: </p><pre><code>\u2018\\\\x41\u2019   // \u2018A\u2019\n'\\\\xff'   // 255\n</code></pre> <p>Octal: </p><pre><code>\u2018\\\\012\u2019   // ASCII 10 (newline)\n\u2018\\\\07\u2019    // ASCII 7 (bell)\n</code></pre> <p>The same character can be expressed in different formats: </p><pre><code>\u2018\\\\x7\u2019   // hex\n\u2018\\\\07\u2019   // octal\n\u2018\\\\a\u2019    // escape \u2014 recommended format\n</code></pre> <p>The recommended format is predefined escape sequences such as <code>\u2018\\\\a\u2019</code> because they are readable and portable.</p>"},{"location":"c/7_constants/#character-encoding-information","title":"Character Encoding Information","text":"<ul> <li>The most common character set is ASCII (7-bit).  </li> <li>Some systems use EBCDIC or Unicode (UTF-16, UTF-32).  </li> <li>Unicode is designed to cover all languages.</li> </ul>"},{"location":"c/7_constants/#5-floating-constants","title":"5. Floating Constants","text":"<p>Floating constants can be of type <code>float</code>, <code>double</code>, or <code>long double</code>.</p>"},{"location":"c/7_constants/#float","title":"float","text":"<pre><code>1.31F\n10.F\n-2.456f\n</code></pre>"},{"location":"c/7_constants/#double","title":"double","text":"<pre><code>-24.5\n</code></pre>"},{"location":"c/7_constants/#long-double","title":"long double","text":"<pre><code>1.34L\n10.2L\n</code></pre>"},{"location":"c/7_constants/#scientific-notation","title":"Scientific Notation","text":"<p>Real numbers can be written in exponential form using <code>e</code> or <code>E</code>.</p> <pre><code>2.3e+04f   // 2.3 \u00d7 10^4\n1.74e-6F   // 1.74 \u00d7 10^-6\n8.e+9f     // 8 \u00d7 10^9\n</code></pre> <p>Equivalent examples: </p><pre><code>1.34E-2f == 0.0134\n-1.2E+2F == 120.0\n</code></pre>"},{"location":"c/7_constants/#6-character-constant-type","title":"6. Character Constant Type","text":"<p>In C, character constants are actually of type <code>int</code>. They behave like <code>char</code> in operations, but are treated as <code>int</code> in type conversions.</p>"},{"location":"c/7_constants/#7-summary","title":"7. Summary","text":"Type Notation Example Type Information Integer <code>125800</code> <code>signed long</code> Integer (hex) <code>0xBCE1C53C</code> <code>unsigned long</code> Character <code>\u2018A\u2019</code>, <code>\u2018\\\\n\u2019</code>, <code>\u2018\\\\x41\u2019</code> <code>int</code> Real number <code>-24.5</code>, <code>1.34L</code>, <code>2.3e+04f</code> <code>float</code>, <code>double</code>, <code>long double</code> ---"},{"location":"c/7_constants/#code-examples","title":"Code examples","text":""},{"location":"c/7_constants/#1-basics","title":"1. basics","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Onluk: %d\\n\", 42);\n    printf(\"Sekizlik: %d\\n\", 052);   // 0 ile ba\u015flarsa sekizlik \u2192 5*8 + 2 = 42\n    printf(\"Onaltilik: %d\\n\", 0x2A); // 0x ile ba\u015flarsa onalt\u0131l\u0131k \u2192 2*16 + 10 = 42\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#2-suffix","title":"2. suffix","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"int: %zu byte\\n\", sizeof(10));\n    printf(\"long: %zu byte\\n\", sizeof(10L));\n    printf(\"unsigned long: %zu byte\\n\", sizeof(10UL));\n    printf(\"long long: %zu byte\\n\", sizeof(10LL));\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#3signed-unsigned","title":"3.signed unsigned","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    signed int a = -1;\n    unsigned int b = -1;\n    printf(\"signed a = %d\\n\", a);\n    printf(\"unsigned b = %u\\n\", b);\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#4-character-constants_1","title":"4. character constants","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char ch1 = 'A';\n    char ch2 = 65; // ayn\u0131 \u015fey\n    printf(\"%c %d\\n\", ch1, ch1);\n    printf(\"%c %d\\n\", ch2, ch2);\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#5-escape-sequences","title":"5. escape sequences","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Sat\u0131r1\\nSat\u0131r2\\n\");     // \\n yeni sat\u0131r\n    printf(\"Sekme\\tAras\u0131\\n\");       // \\t sekme\n    printf(\"Ters B\u00f6l\u00fc: \\\\\\n\");      // \\\\ bir ters b\u00f6l\u00fc\n    printf(\"T\u0131rnak: \\\"Merhaba\\\"\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#6-character-in-numeric-process","title":"6. character in numeric process","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char a = 'a';\n    char b = a + 3;\n    printf(\"'%c' + 3 = '%c'\\n\", a, b);\n    printf(\"ASCII kodlar\u0131: %d + 3 = %d\\n\", a, b);\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#7-octal-and-hex-character-constants","title":"7. octal and hex character constants","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char x = '\\x41';  // 0x41 = 65\n    char y = '\\101';  // 0101 = 65\n    printf(\"x=%c (%d), y=%c (%d)\\n\", x, x, y, y);\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#8-reel-number-constants","title":"8. reel number constants","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    float f = 1.23F;\n    double d = 1.23;\n    long double ld = 1.23L;\n    printf(\"float: %.10f\\n\", f);\n    printf(\"double: %.10lf\\n\", d);\n    printf(\"long double: %.10Lf\\n\", ld);\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#9-scientific-notation","title":"9. scientific notation","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    double a = 1.23e3;   // 1.23 \u00d7 10^3 = 1230\n    double b = 1.23e-3;  // 1.23 \u00d7 10^-3 = 0.00123\n    printf(\"a = %f\\nb = %f\\n\", a, b);\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#10-type-conversion","title":"10. type conversion","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;float.h&gt;\n\nint main() {\n    printf(\"10 -&gt; int: %zu byte\\n\", sizeof(10));\n    printf(\"10L -&gt; long: %zu byte\\n\", sizeof(10L));\n    printf(\"10.0 -&gt; double: %zu byte\\n\", sizeof(10.0));\n    printf(\"10.0f -&gt; float: %zu byte\\n\", sizeof(10.0f));\n\n    double a = 1e39;  // float s\u0131n\u0131r\u0131n\u0131 a\u015far\n    float b = 1e39f;  // ta\u015fma (overflow)\n    printf(\"a(double) = %e\\n\", a);\n    printf(\"b(float)  = %e\\n\", b);\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#11-constant-type-determination","title":"11. Constant Type Determination","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;limits.h&gt; // For INT_MAX\n\nint main() {\n    // 1. Un-suffixed decimal constant (32-bit system)\n    int a = 2000000000;  // Type: signed int\n\n    // 2. Suffix 'L' forces the constant type to signed long\n    long b = 3000000000L; // Type: signed long (needed as 3B &gt; 2B int max)\n\n    // 3. Suffix 'U' forces the constant type to unsigned int\n    unsigned int c = 500U; // Type: unsigned int\n\n    printf(\"Value of b (long): %ld\\n\", b);\n\n    // Example of overflow (assuming 32-bit int)\n    // The constant 3000000000 is too large for signed int, so its type defaults to signed long (if it fits).\n    // If it didn't fit long, it would become unsigned long.\n\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#12-character-arithmeticinteger-promotion","title":"12. Character Arithmetic(integer promotion)","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    // 'A' is an integer constant (ASCII 65)\n    char start_char = 'A'; \n    int offset = 3; \n\n    // The character constant 'A' is promoted to an int (65) for the addition.\n    // The result (68) is then assigned back to the char variable.\n    char result = start_char + offset; // 65 + 3 = 68 ('D')\n\n    printf(\"Character constant 'A' value: %d\\n\", 'A');\n    printf(\"Result of 'A' + 3: %c\\n\", result);\n\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#13-floating-constant-suffix-impact","title":"13. Floating Constant Suffix Impact","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    // 1. Unsuffixed constant: Type is double (8 bytes)\n    printf(\"Size of 3.14 (Default): %zu bytes\\n\", sizeof(3.14)); \n\n    // 2. 'F' suffix: Type is float (4 bytes)\n    printf(\"Size of 3.14F (Float): %zu bytes\\n\", sizeof(3.14F)); \n\n    // 3. 'L' suffix: Type is long double (8/10/12+ bytes)\n    printf(\"Size of 3.14L (Long Double): %zu bytes\\n\", sizeof(3.14L)); \n\n    return 0;\n}\n</code></pre>"},{"location":"c/8_operators/","title":"Operators","text":""},{"location":"c/8_operators/#operators","title":"Operators","text":""},{"location":"c/8_operators/#what-is-an-operator","title":"What is an Operator?","text":"<p>Operators are atoms that perform predefined operations on objects or literals. Operators cause the microprocessor to perform an operation and, as a result, produce a value. Each operator defined in programming languages corresponds to at least one machine instruction. Although they perform similar operations, operator atoms may differ from one programming language to another.</p> <p>In the C programming language, expressions often include operators: * <code>c = a * b / 2 + 3</code> (4 operators: <code>=</code>, <code>*</code>, <code>/</code>, <code>+</code>) * <code>++x * y--</code> (3 operators: <code>++</code>, <code>*</code>, <code>--</code>) * <code>a &gt;= b</code> (1 operator: <code>&gt;=</code>)</p>"},{"location":"c/8_operators/#what-is-an-operand","title":"What is an Operand?","text":"<p>The objects or literals that operators operate on are called operands. In C, operators can be divided into three groups based on the number of operands they take:</p>"},{"location":"c/8_operators/#1-unary-operators","title":"1. Unary Operators","text":"<p>These operators take a single operand. * Example: <code>++</code> and <code>--</code> operators (<code>++x</code>).</p>"},{"location":"c/8_operators/#2-binary-operators","title":"2. Binary Operators","text":"<p>These operators take two operands. * Example: Arithmetic operators like addition (<code>+</code>) and division (<code>/</code>) (<code>x + y</code>).</p>"},{"location":"c/8_operators/#3-ternary-operator","title":"3. Ternary Operator","text":"<p>C has only one ternary operator, which is the conditional operator (<code>? :</code>).</p> <p>Operators can also be grouped based on their position relative to their operand(s):</p> <ul> <li>Postfix Operators: Placed after their operand(s).<ul> <li>Example: Postfix <code>++</code> operator (<code>x++</code>).</li> </ul> </li> <li>Prefix Operators: Placed before their operand(s).<ul> <li>Example: Logical NOT operator (<code>!x</code>).</li> </ul> </li> <li>Infix Operators: Placed between their operands.<ul> <li>Example: Arithmetic addition operator (<code>x + y</code>).</li> </ul> </li> </ul>"},{"location":"c/8_operators/#operators-producing-a-value","title":"Operators Producing a Value","text":"<p>Operators produce a value as a result of the operation they perform. The value produced by an operator can be an operand for another operator within the same expression. The value produced by the last evaluated operator in an expression becomes the value of the expression.</p> <p>The most important feature of operators is that they produce a value as a result of their operation. The programmer may or may not use the value produced by the operator.</p> <p>The produced value can be used in the following ways: * Assigned to another variable: <code>x = y + z;</code> (The value produced by <code>+</code> is assigned to <code>x</code>). * Sent as an argument to a function: <code>func(y + z);</code> (The value produced by <code>+</code> is sent to <code>func</code>). * Used to form a function's return value: </p><pre><code>int func() {\n    return (y + z); // The return value is the value produced by '+'\n}\n</code></pre> <p>Not using the value produced by an operator is not a syntax error in C, but compilers usually issue a warning to the programmer. * Example: The expression <code>x + y;</code> produces the value 30, but since it is not used, a Borland compiler might issue the warning: <code>\"code has no effect!\"</code>.</p>"},{"location":"c/8_operators/#operator-precedence-and-associativity","title":"Operator Precedence and Associativity","text":"<p>In C, expressions have types and values. The compiler determines an expression's value by: 1. Operators producing values according to their precedence order. 2. The produced values being passed as operands to operators with lower precedence. 3. The final value remaining being the value of the expression.</p> <p>Every programming language has operator precedence. Without precedence, the results of operations would vary across machines and compilers.</p> <ul> <li>C has 45 operators across 15 distinct precedence levels.</li> <li>Associativity (Precedence Direction) defines whether operators at the same precedence level are evaluated from left-to-right or right-to-left.<ul> <li>Levels 2, 13, and 14 are right associative.</li> <li>All other levels are left associative.</li> </ul> </li> </ul> <p>A single symbol can be used for multiple operators (e.g., <code>*</code> for multiplication and the indirection operator, or <code>&amp;</code> for bitwise AND and the address-of operator).</p>"},{"location":"c/8_operators/#operator-side-effects","title":"Operator Side Effects","text":"<p>While the main function of C operators is to produce a value, some operators also change the values of their operand objects. This change, which is writing a new value to the object's memory location, is called a side effect.</p> <ul> <li>Example: The assignment operator (<code>=</code>) and the increment/decrement operators (<code>++</code>, <code>--</code>) have side effects.</li> </ul>"},{"location":"c/8_operators/#constraints-on-operators","title":"Constraints on Operators","text":"<p>Programming language rules impose certain constraints on operator usage. * Constraint Example 1: The <code>++</code> operator requires its operand to be an expression that designates an object (an lvalue); otherwise, a compile-time error occurs. * Constraint Example 2: The modulus operator (<code>%</code>) requires both operands to be of an integer type (<code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>); using real number types is invalid.</p>"},{"location":"c/8_operators/#classification-of-operators-by-function","title":"Classification of Operators by Function","text":"<p>Operators are classified based on the operations they perform:</p> <ul> <li>Arithmetic Operators: Addition, subtraction, multiplication, increment, decrement, and sign operators.</li> <li>Relational Operators (Comparison): Greater than, greater than or equal, less than, less than or equal, equal, not equal.</li> <li>Logical Operators: Logical AND, logical OR, logical NOT.</li> <li>Pointer Operators: Address-of, indirection (content), and subscript (<code>[]</code>) operators.</li> <li>Bitwise Operators: Bitwise NOT, bitwise shift, bitwise AND, OR, and XOR.</li> <li>Assignment Operators: Simple assignment and compound assignment operators.</li> <li>Special Purpose Operators: Conditional operator, <code>sizeof</code>, type cast operator.</li> </ul>"},{"location":"c/8_operators/#arithmetic-operators","title":"Arithmetic Operators","text":""},{"location":"c/8_operators/#addition-and-subtraction-operators","title":"Addition (<code>+</code>) and Subtraction (<code>-</code>) Operators","text":"<ul> <li>Binary, infix operators.</li> <li>Produce the sum or difference of their operands.</li> <li>No requirement for operands to be of the same type.</li> <li>Precedence level 4; left associative.</li> <li>No side effects.</li> </ul>"},{"location":"c/8_operators/#unary-sign-operators-and","title":"Unary Sign Operators (<code>-</code> and <code>+</code>)","text":"<ul> <li>Unary, prefix operators.</li> <li>Sign Minus (<code>-</code>): Produces the negative of its operand's value (compiler generates code to multiply the value by -1). It produces an rvalue (a value, not an object), so it cannot be assigned to.<ul> <li>Example: <code>-x</code> and <code>0 - (x)</code> are equivalent.</li> </ul> </li> <li>Sign Plus (<code>+</code>): Added for mathematical similarity; has no effect on its operand's value and produces the same value as its operand.<ul> <li>Example: <code>+x</code> and <code>0 + (x)</code> are equivalent.</li> </ul> </li> <li>Precedence level 2; right associative.</li> <li>No side effects.</li> </ul>"},{"location":"c/8_operators/#multiplication-and-division-operators","title":"Multiplication (<code>*</code>) and Division (<code>/</code>) Operators","text":"<ul> <li>Binary, infix operators.</li> <li>Multiplication (<code>*</code>): Produces the product of its operands.</li> <li>Division (<code>/</code>): Produces the quotient of the left operand divided by the right operand.<ul> <li>Note: If both operands are integer types, the result is an integer (integer division).</li> </ul> </li> <li>Precedence level 3; left associative.</li> <li>No side effects.</li> <li>The <code>*</code> symbol is also used as a pointer (indirection) operator, but they do not conflict because multiplication is binary while indirection is unary.</li> </ul>"},{"location":"c/8_operators/#modulus-operator","title":"Modulus (<code>%</code>) Operator","text":"<ul> <li>Binary, infix operator.</li> <li>Constraint: Both operands must be integer types (char, short, int, long). Real number types are invalid.</li> <li>Produces the remainder of the left operand divided by the right operand.</li> <li>No side effects.</li> </ul>"},{"location":"c/8_operators/#increment-and-decrement-operators","title":"Increment (<code>++</code>) and Decrement (<code>--</code>) Operators","text":"<ul> <li>Single-operand operators; can be used in prefix or postfix positions.</li> <li>Used to increase (<code>++</code>) or decrease (<code>--</code>) the value of a variable by 1.</li> <li>They have side effects (they change the value of the operand object in memory).</li> <li>Precedence level 2; higher than other arithmetic operators; right associative.</li> </ul>"},{"location":"c/8_operators/#usage","title":"Usage","text":"<ul> <li>Isolated use (<code>++c;</code> or <code>c++;</code>): No difference; both are equivalent to <code>c = c + 1;</code>.</li> <li>In expressions:<ul> <li>Prefix (<code>++x</code>): The value produced is the value after the increment/decrement.</li> <li>Postfix (<code>x++</code>): The value produced is the value before the increment/decrement; the actual change to the object's value happens after the entire expression is evaluated.</li> </ul> </li> </ul>"},{"location":"c/8_operators/#important-terms-in-c-standards","title":"Important Terms in C Standards","text":""},{"location":"c/8_operators/#behavior","title":"Behavior","text":"<p>The way a compiler interprets and understands a specific piece of code is called \"compiler behavior\".</p>"},{"location":"c/8_operators/#undefined-behavior","title":"Undefined Behavior","text":"<p>Expressions that lead to interpretation differences not explicitly specified in the standards, which can vary from compiler to compiler. Programmers should avoid them, as there is no guarantee of the outcome. Code with undefined behavior is syntactically valid. * <code>++</code>/<code>--</code> Related Undefined Behavior: If a variable is an operand of <code>++</code> or <code>--</code> in an expression, it should not appear again in that same expression.     * Example: <code>y = ++x + ++x;</code>, <code>y = ++x + x</code>, and <code>a = ++a;</code> all exhibit undefined behavior.</p>"},{"location":"c/8_operators/#unspecified-behavior","title":"Unspecified Behavior","text":"<p>Situations where the compiler can interpret the source code differently, but the options are limited. Compilers are not required to document which option they chose. Programmers should avoid code that leads to unspecified behavior.</p>"},{"location":"c/8_operators/#implementation-dependent-behavior","title":"Implementation-Dependent Behavior","text":"<p>Certain C features are left to the compiler writers' choice for flexibility (e.g., the length of <code>int</code>, whether default <code>char</code> is signed or unsigned). Compilers must document how these features were chosen.</p>"},{"location":"c/8_operators/#diagnostic-messages","title":"Diagnostic Messages","text":"<p>The notification given by the compiler about the cause of a problem when it encounters problematic code. * A warning or error message should be issued when syntactical or semantic rules are violated. Warnings are typically for minor issues that can be fixed, while errors are for larger mistakes.</p>"},{"location":"c/8_operators/#relational-operators-comparison","title":"Relational Operators (Comparison)","text":"<p>C has 6 relational operators: * <code>&lt;</code> (less than) * <code>&gt;</code> (greater than) * <code>&lt;=</code> (less than or equal) * <code>&gt;=</code> (greater than or equal) * <code>==</code> (equal) * <code>!=</code> (not equal)</p> <p>All are binary, infix operators.</p> <ul> <li>The first four (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) are at precedence level 6.</li> <li>The last two (<code>==</code>, <code>!=</code>) are at precedence level 7.</li> <li>They have lower precedence than arithmetic operators.</li> </ul> <p>In C (unlike C++ or Java), there is no dedicated boolean data type. Relational operators produce an <code>int</code> type value: * 1 if the proposition is True. * 0 if the proposition is False.</p>"},{"location":"c/8_operators/#logical-operators","title":"Logical Operators","text":"<p>These operators perform logical operations on their operands. They interpret their operands as True or False. C has three logical operators with different precedence levels:</p> <ul> <li><code>!</code> (logical NOT)</li> <li><code>&amp;&amp;</code> (logical AND)</li> <li><code>||</code> (logical OR)</li> </ul> <p>Since C does not have a boolean type, <code>int</code> is used, where 1 is True and 0 is False. Any expression can be an operand to a logical operator. If the expression's numeric value is non-zero, it is interpreted as True (1); if it is 0, it is interpreted as False (0).</p>"},{"location":"c/8_operators/#logical-not-operator","title":"Logical NOT Operator (<code>!</code>)","text":"<ul> <li>Unary, prefix operator.</li> <li>Produces the inverse logical value of its operand.<ul> <li>If the operand is True (non-zero), it produces 0.</li> <li>If the operand is False (0), it produces 1.</li> </ul> </li> </ul>"},{"location":"c/8_operators/#logical-and-operator","title":"Logical AND Operator (<code>&amp;&amp;</code>)","text":"<ul> <li>Lower precedence than relational operators, but higher than <code>||</code>.</li> <li>Produces 1 (True) only if both operands are True; otherwise, it produces 0 (False).</li> </ul>"},{"location":"c/8_operators/#logical-or-operator","title":"Logical OR Operator (<code>||</code>)","text":"<ul> <li>Lowest precedence logical operator.</li> <li>Produces 1 (True) if at least one operand is True; produces 0 (False) only if both are False.</li> </ul>"},{"location":"c/8_operators/#short-circuit-behavior-and","title":"Short Circuit Behavior (<code>&amp;&amp;</code> and <code>||</code>)","text":"<p>C guarantees that the left operand is evaluated first for both <code>&amp;&amp;</code> and <code>||</code>. This feature, called short circuit behavior, allows for more efficient code: * <code>&amp;&amp;</code>: If the left operand is evaluated as False (0), the right operand is never evaluated. * <code>||</code>: If the left operand is evaluated as True (non-zero), the right operand is never evaluated.</p> <p>Logical operators perform their operation by first interpreting their operands as 1 or 0, but they have no side effects on the memory values of their operands.</p>"},{"location":"c/8_operators/#assignment-operators","title":"Assignment Operators","text":"<p>Assignment operators are at precedence level 14 (second lowest, only higher than the comma operator) and are right associative.</p>"},{"location":"c/8_operators/#simple-assignment-operator","title":"Simple Assignment Operator (<code>=</code>)","text":"<ul> <li>Like other operators, the assignment operator produces a value in addition to performing the assignment.</li> <li>The value produced is the value assigned to the object.</li> <li>The value produced by the assignment is not an object; therefore, expressions like <code>(b = c) = a;</code> are invalid in C.</li> <li>Its right-to-left associativity allows chained assignments like <code>a = b = c = d = 5;</code>.</li> </ul>"},{"location":"c/8_operators/#compound-assignment-operators-etc","title":"Compound Assignment Operators (<code>+=</code>, <code>-=</code>, <code>*=</code>, etc.)","text":"<p>Used when the operand being operated on and the object receiving the result are the same. * <code>&lt;object1&gt; = &lt;object1&gt; operation &lt;operand2&gt;</code> is equivalent to <code>&lt;object1&gt; operation= &lt;operand2&gt;</code>. * They are at the same precedence level as the simple assignment operator. * Preferred for readability and brevity. * Example: <code>x += 5;</code> is equivalent to <code>x = x + 5;</code>.</p> <p>All assignment operators have side effects. The side effect is the modification of the left operand's value in memory, by assigning the value of the right operand expression to the object on the left.</p>"},{"location":"c/8_operators/#comma-operator","title":"Comma Operator (<code>,</code>)","text":"<p>The comma operator combines two separate expressions into a single expression. It has the lowest precedence in C (level 15).</p> <ul> <li>The evaluation of the left operand's expression is guaranteed to occur before the evaluation of the right operand's expression.</li> <li>The value produced by the operator is the value produced by the right-hand expression. The left operand's value does not affect the result.</li> </ul>"},{"location":"c/8_operators/#precedence-operator","title":"Precedence Operator (<code>()</code>)","text":"<p>The parentheses operator is used to increase the precedence of an expression. * It is in the highest precedence group (level 1). * It follows the left-to-right associativity rule. * If the operand expression designates an object, the expression produced by the precedence operator also designates an object.</p>"},{"location":"c/8_operators/#operator-precedence-vs-order-of-execution","title":"Operator Precedence vs. Order of Execution","text":"<p>Operator precedence does not guarantee that an operation will be performed sooner by the processor. * Example: In <code>x = func1() * func2() + func3();</code>, the higher precedence of multiplication (<code>*</code>) does not guarantee that <code>func1()</code> will be called before <code>func3()</code>.</p> <p>However, the following 4 C operators do guarantee the order of operation for their operands: 1. Logical AND (<code>&amp;&amp;</code>) 2. Logical OR (<code>||</code>) 3. Conditional (<code>? :</code>) 4. Comma (<code>,</code>)</p> <p>The order is guaranteed to ensure the short circuit behavior for <code>&amp;&amp;</code>/<code>||</code>, the required evaluation of the first operand for the conditional operator, and the left-to-right execution of the comma operator.</p>"},{"location":"c/8_operators/#c-language-operator-precedence-table","title":"C Language Operator Precedence Table","text":"Level Operator Description Associativity 1 <code>()</code>, <code>[]</code>, <code>.</code>, <code>-&gt;</code> Precedence, Subscript, Structure Access left-to-right 2 <code>+</code>, <code>-</code>, <code>++</code>, <code>--</code>, <code>~</code>, <code>!</code>, <code>*</code>, <code>&amp;</code>, <code>sizeof</code>, <code>(type)</code> Unary Signs, Inc/Dec, Bitwise/Logical NOT, Indirection, Address Of, sizeof, Type Cast right-to-left 3 <code>*</code>, <code>/</code>, <code>%</code> Multiplication, Division, Modulus left-to-right 4 <code>+</code>, <code>-</code> Addition, Subtraction left-to-right 5 <code>&lt;&lt;</code>, <code>&gt;&gt;</code> Bitwise Shift Left/Right left-to-right 6 <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> Relational Operators left-to-right 7 <code>==</code>, <code>!=</code> Equality Operators left-to-right 8 <code>&amp;</code> Bitwise AND left-to-right 9 <code>^</code> Bitwise Exclusive OR (XOR) left-to-right 10 <code>|</code> Bitwise OR left-to-right 11 <code>&amp;&amp;</code> Logical AND left-to-right 12 <code>||</code> Logical OR left-to-right 13 <code>?:</code> Conditional Operator right-to-left 14 <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code> Assignment Operators (Simple &amp; Compound) right-to-left 15 <code>,</code> Comma Operator left-to-right"},{"location":"c/8_operators/#additional-examples","title":"Additional examples","text":""},{"location":"c/8_operators/#1-arithmetic-unary-side-effects","title":"1. Arithmetic, Unary &amp; Side Effects","text":"<p>This example focuses on basic arithmetic, the difference between prefix and postfix increment/decrement, and the concept of an operator producing a value and having a side effect. </p><pre><code>#include &lt;stdio.h&gt;\n\nvoid basic_operators_demo() {\n    int a = 10;\n    int b = 3;\n    int result;\n\n    printf(\"--- 1. Basic Arithmetic (Binary Infix) ---\\n\");\n    // Binary Infix Operators: +, -, *, /, %\n    printf(\"Addition: 10 + 3 = %d\\n\", a + b);     // Produces 13\n    printf(\"Division (Integer): 10 / 3 = %d\\n\", a / b); // Produces 3 (integer division)\n    printf(\"Modulus (Remainder): 10 %% 3 = %d\\n\", a % b); // Produces 1 (Constraint: requires integer types)\n\n    // Unary Prefix Operator: - (Sign Minus)\n    printf(\"Unary Minus: -10 = %d\\n\", -a); // Produces -10\n\n    printf(\"\\n--- 2. Unary Inc/Dec Operators (Side Effects) ---\\n\");\n\n    int x = 5;\n    printf(\"Initial x: %d\\n\", x); // x is 5\n\n    // Prefix Increment: ++x\n    // Action: 1. Changes x (side effect) 2. Value produced is the NEW value\n    result = ++x; \n    printf(\"Prefix ++x: Value produced = %d, x after operation = %d\\n\", result, x); // Output: 6, 6\n\n    x = 5; // Reset x\n\n    // Postfix Increment: x++\n    // Action: 1. Value produced is the OLD value 2. Changes x (side effect)\n    result = x++;\n    printf(\"Postfix x++: Value produced = %d, x after operation = %d\\n\", result, x); // Output: 5, 6\n\n    // Note: If used in isolation (e.g., x++;), prefix and postfix are functionally identical.\n}\n\n/*\nTo compile and run:\ngcc basic_operators.c -o basic_demo\n./basic_demo\n*/\n</code></pre>"},{"location":"c/8_operators/#2-relational-logical-short-circuiting","title":"2. Relational, Logical &amp; Short-Circuiting","text":"<p>This example demonstrates how Relational and Logical operators produce integer values (1 or 0) and illustrates the crucial short-circuit behavior of &amp;&amp; and || </p><pre><code>#include &lt;stdio.h&gt;\n\nint check_function(const char* name) {\n    printf(\"-&gt; Evaluating function: %s\\n\", name);\n    return 0; // Always returns 0 (False)\n}\n\nvoid intermediate_operators_demo() {\n    int val1 = 10, val2 = 20;\n\n    printf(\"--- 1. Relational Operators (Produce 1 or 0) ---\\n\");\n    // Relational Operators: &lt;, &gt;, &lt;=, &gt;=, ==, !=\n\n    // val1 &lt; val2 (10 &lt; 20) is True, so it produces 1.\n    printf(\"10 &lt; 20: %d\\n\", val1 &lt; val2); \n\n    // val1 == val2 (10 == 20) is False, so it produces 0.\n    printf(\"10 == 20: %d\\n\", val1 == val2); \n\n    printf(\"\\n--- 2. Logical Operators (!, &amp;&amp;, ||) ---\\n\");\n\n    // Logical NOT: !\n    // ! (10 &lt; 20) -&gt; ! (1) -&gt; 0\n    printf(\"! (10 &lt; 20): %d\\n\", !(val1 &lt; val2)); \n\n    // Logical AND: &amp;&amp;\n    // (10 &lt; 20) &amp;&amp; (10 != 20) -&gt; 1 &amp;&amp; 1 -&gt; 1\n    printf(\"(10 &lt; 20) &amp;&amp; (10 != 20): %d\\n\", (val1 &lt; val2) &amp;&amp; (val1 != val2)); \n\n    printf(\"\\n--- 3. Short Circuit Behavior (&amp;&amp;) ---\\n\");\n    int x = 5;\n\n    // Condition: (x is 0/False) &amp;&amp; (Call function)\n    // The left side (x != 5) is 0 (False).\n    // The right operand is NOT evaluated. The function is NOT called.\n    if ((x != 5) &amp;&amp; check_function(\"RightOperand_AND\")) {\n        // This block is skipped\n    } else {\n        printf(\"&amp;&amp; Short Circuit: Left side was False (0), RightOperand_AND was NOT called.\\n\");\n    }\n\n    printf(\"\\n--- 4. Short Circuit Behavior (||) ---\\n\");\n\n    // Condition: (x is non-zero/True) || (Call function)\n    // The left side (x == 5) is 1 (True).\n    // The right operand is NOT evaluated. The function is NOT called.\n    if ((x == 5) || check_function(\"RightOperand_OR\")) {\n        printf(\"|| Short Circuit: Left side was True (1), RightOperand_OR was NOT called.\\n\");\n    }\n}\n\n/*\nTo compile and run:\ngcc intermediate_operators.c -o intermediate_demo\n./intermediate_demo\n*/\n</code></pre>"},{"location":"c/8_operators/#3-precedence-ternary-comma-undefined-behavior","title":"3. Precedence, Ternary, Comma &amp; Undefined Behavior","text":"<p>This example explores the more complex aspects: Precedence, the ternary operator, the low-precedence comma operator, and a demonstration of an expression with Undefined Behavior (for instructional purposes, to highlight what to avoid). </p><pre><code>#include &lt;stdio.h&gt;\n\nvoid advanced_operators_demo() {\n    int a = 20, b = 5, c = 2, d;\n\n    printf(\"--- 1. Precedence and Associativity ---\\n\");\n\n    // Expression: d = a + b * c;\n    // Precedence: * (Level 3) is higher than + (Level 4).\n    // Evaluation: d = a + (b * c) -&gt; d = 20 + 10 -&gt; 30\n    d = a + b * c;\n    printf(\"a + b * c (20 + 5 * 2) = %d\\n\", d); // Output: 30\n\n    // Expression: d = (a + b) * c;\n    // Parentheses (Level 1) force a higher precedence.\n    // Evaluation: d = (20 + 5) * 2 -&gt; d = 25 * 2 -&gt; 50\n    d = (a + b) * c;\n    printf(\"(a + b) * c ( (20 + 5) * 2 ) = %d\\n\", d); // Output: 50\n\n    printf(\"\\n--- 2. Conditional (Ternary) Operator (?:) ---\\n\");\n    // The C-only Ternary Operator: &lt;condition&gt; ? &lt;value_if_true&gt; : &lt;value_if_false&gt;\n    // Right Associative (Level 13)\n\n    int max = (a &gt; b) ? a : b; // Condition (a &gt; b) is True, max gets a (20)\n    printf(\"Max of 20 and 5 is: %d\\n\", max); \n\n    int abs_val = (b &lt; 0) ? -b : b; // Condition (b &lt; 0) is False, abs_val gets b (5)\n    printf(\"Absolute value of 5 is: %d\\n\", abs_val);\n\n    printf(\"\\n--- 3. Comma Operator (,) ---\\n\");\n    // Lowest Precedence (Level 15). Guarantees left-to-right evaluation.\n    // The value produced by the whole expression is the value of the RIGHT operand.\n\n    int e = 0;\n    // (e = 10, e + 5)\n    // 1. e = 10 (Side effect: e is now 10)\n    // 2. e + 5 -&gt; 10 + 5 -&gt; 15 (Value produced by the expression is 15)\n    d = (e = 10, e + 5); \n    printf(\"Comma Operator (e = 10, e + 5): Result = %d, e value = %d\\n\", d, e); // Output: 15, 10\n\n    printf(\"\\n--- 4. WARNING: Undefined Behavior ---\\n\");\n\n    int x = 10;\n    // **DANGER!** A variable 'x' is modified by '++' and also appears elsewhere in the expression.\n    // C Standard says: \"If a side effect on a scalar object is unsequenced relative to either \n    // a second side effect on the same scalar object or a value computation using the value \n    // of the same scalar object, the behavior is undefined.\"\n    // The outcome of the following line is NOT guaranteed and should be AVOIDED.\n    // Depending on the compiler/optimization, the result could be 22, 23, or something else.\n    int result_ub = ++x + x; \n\n    printf(\"++x + x (Initial x=10). The result is: %d (!!! Undefined Behavior !!!)\\n\", result_ub);\n    printf(\"Final x value: %d\\n\", x);\n}\n\n/*\nTo compile and run:\ngcc advanced_operators.c -o advanced_demo\n./advanced_demo\n*/\n</code></pre>"},{"location":"c/9_functions/","title":"Functions","text":""},{"location":"c/9_functions/#functions","title":"Functions","text":""},{"location":"c/9_functions/#1-what-is-a-function","title":"1. What is a Function?","text":"<p>In the C language, subprograms are called functions. Unlike the concept of a function in mathematics, a function is an independent sub-block of the program.</p> <p>A function is written to perform a specific task or produce a value.</p>"},{"location":"c/9_functions/#2-benefits-of-dividing-the-program-into-functions","title":"2. Benefits of Dividing the Program into Functions","text":"<ol> <li>The code becomes shorter, the .exe file becomes smaller. </li> <li>The code becomes more readable and easier to maintain.  </li> <li>Repetitive operations are grouped in one place.  </li> <li>Debugging becomes easier.  </li> <li>Functions become reusable.</li> </ol> <p>Every C program consists of functions and contains at least one function (<code>main</code>).</p>"},{"location":"c/9_functions/#3-function-inputs-and-outputs","title":"3. Function Inputs and Outputs","text":"<ul> <li>Input: Values sent to the function \u2192 actual parameter </li> <li>Output: The value returned by the function \u2192 return value</li> </ul> <p>The purpose of a function: 1. To perform a task 2. To calculate and return a value.</p>"},{"location":"c/9_functions/#4-return-values-of-functions","title":"4. Return Values of Functions","text":"<p>A value is returned at the end of a function using the return statement.</p>"},{"location":"c/9_functions/#purposes-of-use","title":"Purposes of use","text":"<ul> <li>To return the calculated result</li> <li>To indicate whether an operation was successful</li> <li>To convey status information</li> <li>Or to return no value (<code>void</code>)</li> </ul>"},{"location":"c/9_functions/#5-function-definition","title":"5. Function Definition","text":"<p>The body of the function is defined as follows:</p> <pre><code>[return_type] function_name([parameters]) {\n    /* code */\n}\n</code></pre> <p>Example: </p><pre><code>double func() {\n    return 3.14;\n}\n</code></pre> The <code>func</code> function takes no parameters and returns a value of type <code>double</code>."},{"location":"c/9_functions/#the-void-keyword","title":"The <code>void</code> Keyword","text":"<pre><code>void hello() {\n    printf(\u201cHello!\u201d);\n}\n</code></pre> <code>void</code> \u2192 The function does not produce a return value."},{"location":"c/9_functions/#functions-without-a-specified-type","title":"Functions Without a Specified Type","text":"<pre><code>func() { }\n</code></pre> The C compiler interprets this as <code>int func()</code>. In C++, this is invalid \u2014 the type must be specified."},{"location":"c/9_functions/#6-where-functions-are-defined","title":"6. Where Functions Are Defined","text":"<p>A function cannot be defined inside another function.</p> <pre><code>double foo() {\n    int bar() { } // Invalid\n}\n</code></pre> <p>Correct usage: </p><pre><code>double foo() { }\nint bar() { }\n</code></pre>"},{"location":"c/9_functions/#7-return-statement","title":"7. <code>return</code> Statement","text":"<p>Ends the function's execution and returns a value.</p> <pre><code>return;\nreturn x * y;\nreturn (a * b - c * d);\n</code></pre> <ul> <li>If the end is reached without a <code>return</code> statement, it returns a garbage value.</li> <li><code>void</code> functions can use <code>return;</code> on its own.</li> <li>A function can only return one value.</li> </ul>"},{"location":"c/9_functions/#8-main-function","title":"8. <code>main</code> Function","text":"<pre><code>int main() {\n    return 0;\n}\n</code></pre> <ul> <li>It is the starting point of the program.  </li> <li>The return value of <code>main</code> is passed to the operating system.  </li> <li><code>0</code> \u2192 success  </li> <li>Non-zero \u2192 error</li> </ul> <p>Although <code>void main()</code> is valid, it is not recommended.</p>"},{"location":"c/9_functions/#9-function-invocation","title":"9. Function Invocation","text":"<p>Function call operator: <code>()</code></p> <pre><code>func();\nresult = calculate();\n</code></pre> <ul> <li>The code of the called function executes, then control returns to the caller.  </li> <li>The return value is an R-value.</li> </ul> <pre><code>func() = 5; // Invalid\n</code></pre>"},{"location":"c/9_functions/#10-undefined-functions","title":"10. Undefined Functions","text":"<p>A function can be called even if it is declared but not defined. There will be no compilation error, but an error will occur during the linking phase if no definition is found.</p>"},{"location":"c/9_functions/#11-parameters","title":"11. Parameters","text":"<p>These are the input variables that functions take.</p> <p></p><pre><code>int add(int a, int b) {\n    return a + b;\n}\n</code></pre> When called: <pre><code>int z = add(x, y);\n</code></pre> The values of <code>x</code> and <code>y</code> are copied to the parameters <code>a</code> and <code>b</code>, respectively."},{"location":"c/9_functions/#12-old-style","title":"12. Old Style","text":"<pre><code>double area(x, y)\ndouble x, y;\n{\n    return x * y;\n}\n</code></pre> <p>Parameter types are declared later \u2014 no longer used.</p>"},{"location":"c/9_functions/#13-new-style","title":"13. New Style","text":"<pre><code>double area(double x, double y) {\n    return x * y;\n}\n</code></pre> <p>Types are specified in parentheses \u2014 modern C standard.</p>"},{"location":"c/9_functions/#14-functions-without-parameters","title":"14. Functions Without Parameters","text":"<pre><code>int foo() { }      // or\nint foo(void) { }\n</code></pre> Both indicate that no parameters are taken."},{"location":"c/9_functions/#15-copying-arguments","title":"15. Copying Arguments","text":"<p>Functions take parameters by value.</p> <p></p><pre><code>void func(int a) { a++; }\n\nint main() {\n    int x = 10;\n    func(x);\n    printf(\u201c%d\u201d, x); // 10\n}\n</code></pre> Demonstrates: Function parameters are copies, the original value remains unchanged."},{"location":"c/9_functions/#16-function-call-forms","title":"16. Function Call Forms","text":"<ol> <li>Void function call: <pre><code>func();\n</code></pre></li> <li>Value-returning function: <pre><code>a = foo();\n</code></pre></li> <li>Call without using the value: <pre><code>foo();\n</code></pre></li> <li>Nested call: <pre><code>z = square(add(x, y));\n</code></pre></li> <li>Another call inside return: <pre><code>return add(square(a), square(b));\n</code></pre></li> </ol>"},{"location":"c/9_functions/#17-recursive-functions","title":"17. Recursive Functions","text":"<p>A function can call itself.</p> <pre><code>int factorial(int n) {\n    if (n == 0) return 1;\n    return n * factorial(n - 1);\n}\n</code></pre> <p>This feature is called recursion.</p>"},{"location":"c/9_functions/#18-summary","title":"18. Summary","text":"Concept Explanation Function Subprogram, independent code block Definition Writing the function's code Call Executing the function Parameter Data sent to the function Return value Result produced by the function <code>void</code> Function with no return value <code>main</code> Program's starting point"},{"location":"c/9_functions/#additional-examples","title":"Additional examples","text":""},{"location":"c/9_functions/#1-square","title":"1. square","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint kare(int x) {\n    return x * x;\n}\n\nint main() {\n    printf(\"5\u2019in karesi: %d\\n\", kare(5));\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#2void","title":"2.void","text":"<pre><code>#include &lt;stdio.h&gt;\n\nvoid selamla() {\n    printf(\"Merhaba!\\n\");\n}\n\nint main() {\n    selamla();\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#3-decleration-and-call","title":"3. decleration and call","text":"<pre><code>#include &lt;stdio.h&gt;\n\n// Bildirim (prototip)\nint topla(int, int);\n\nint main() {\n    int s = topla(3, 4);\n    printf(\"Toplam = %d\\n\", s);\n    return 0;\n}\n\n// Tan\u0131mlama\nint topla(int a, int b) {\n    return a + b;\n}\n</code></pre>"},{"location":"c/9_functions/#4-return-exit","title":"4. return exit","text":"<pre><code>#include &lt;stdio.h&gt;\n\nvoid bolme(int a, int b) {\n    if (b == 0) {\n        printf(\"S\u0131f\u0131ra b\u00f6lme hatas\u0131!\\n\");\n        return; // erken \u00e7\u0131k\u0131\u015f\n    }\n    printf(\"Sonu\u00e7: %d\\n\", a / b);\n}\n\nint main() {\n    bolme(10, 2);\n    bolme(5, 0);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#5-use-funcs-as-formal-parameter","title":"5. use funcs as formal parameter","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint topla(int a, int b) { return a + b; }\nint kare(int x) { return x * x; }\n\nint main() {\n    int sonuc = kare(topla(3, 2));\n    printf(\"Sonu\u00e7: %d\\n\", sonuc); // (3+2)^2 = 25\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#6-copy-parameters","title":"6. copy parameters","text":"<pre><code>#include &lt;stdio.h&gt;\n\nvoid arttir(int a) {\n    a++;\n    printf(\"\u0130\u015flev i\u00e7inde: %d\\n\", a);\n}\n\nint main() {\n    int x = 10;\n    arttir(x);\n    printf(\"Ana programda: %d\\n\", x);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#7-function-chains","title":"7. function chains","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint kare(int x) { return x * x; }\nint topla(int a, int b) { return a + b; }\n\nint main() {\n    printf(\"%d\\n\", kare(topla(3, 4))); // (3+4)^2 = 49\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#8-recursive","title":"8. recursive","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint faktoriyel(int n) {\n    if (n == 0) return 1;\n    return n * faktoriyel(n - 1);\n}\n\nint main() {\n    printf(\"5! = %d\\n\", faktoriyel(5));\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#9-function-pointer","title":"9. function pointer","text":"<pre><code>#include &lt;stdio.h&gt;\n/*\nyou can use function pointers to select functions at runtime.\nthis is show the functions can be used like data types\n*/\n\nint topla(int a, int b) { \n    return a + b; \n}\nint carp(int a, int b) { \n    return a * b; \n}\n\nint (*secim(int islem))(int, int) {\n    if (islem == 1) return topla;\n    else return carp;\n}\n\nint main() {\n    int (*f)(int, int);\n    f = secim(1);\n    printf(\"Sonu\u00e7: %d\\n\", f(3, 4)); // 7\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#functions-2","title":"Functions 2","text":""},{"location":"c/9_functions/#1-function-return-values-and-call-chains","title":"1. Function Return Values and Call Chains","text":"<p>The return value of a function can be an argument to another function. Additionally, a function can be used in another function's <code>return</code> statement.</p> <p>Example: </p><pre><code>int add(int a, int b) {\n    return a + b;\n}\n\nint square(int x) {\n    return x * x;\n}\n\nint sum_square(int a, int b) {\n    return add(square(a), square(b));\n}\n</code></pre> <p>Explanation: - <code>sum_square</code> returns the sum of the squares of two numbers. - The return values of the <code>add</code> and <code>square</code> functions are used by nesting calls. - This is possible because every function call in C produces an R-value.</p>"},{"location":"c/9_functions/#2-standard-c-functions-standard-library-functions","title":"2. Standard C Functions (Standard Library Functions)","text":"<p>Standard C functions are predefined functions that every C compiler must support. The code for these functions comes with the compiler.</p>"},{"location":"c/9_functions/#why-use-standard-functions","title":"Why Use Standard Functions?","text":"<ul> <li>Increases code portability  </li> <li>Creates a common language  </li> <li>Reduces code repetition  </li> <li>Ensures reliability (previously tested)</li> </ul>"},{"location":"c/9_functions/#example-standard-functions","title":"Example Standard Functions","text":"<p><code>printf()</code>, <code>scanf()</code>, <code>getchar()</code>, <code>putchar()</code>, <code>abs()</code>, <code>sqrt()</code>, <code>pow()</code>, <code>strlen()</code>, <code>malloc()</code>, <code>free()</code>, <code>exit()</code></p>"},{"location":"c/9_functions/#3-libraries-and-header-files","title":"3. Libraries and Header Files","text":"Component Description Header file (.h) Contains function declarations. Library (.lib / .a) Contains function definitions (compiled code). Linker Includes compiled functions into the program. <p>Example Usage: </p><pre><code>#include &lt;stdio.h&gt;  // printf, scanf\n#include &lt;math.h&gt;   // sqrt, pow\n</code></pre>"},{"location":"c/9_functions/#4-printf-function-output","title":"4. <code>printf()</code> Function (Output)","text":"<p><code>printf()</code> \u2192 Standard output function that writes data to the screen.</p> <p>Example: </p><pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int x = 25;\n    double pi = 3.1415;\n\n    printf(\u201cx = %d\\npi = %lf\\n\u201d, x, pi);\n    return 0;\n}\n</code></pre> <p>Formatting Characters: | Format | Type | Description | |:-------|:-----|:----------| | <code>%d</code> | int | Decimal system | | <code>%ld</code> | long | Decimal system | | <code>%u</code> | unsigned int | Decimal | | <code>%x</code>, <code>%X</code> | unsigned int | Hexadecimal | | <code>%o</code> | unsigned int | Octal | | <code>%f</code> | float/double | Real number (decimal) | | <code>%e</code> | float/double | Exponential notation | | <code>%c</code> | char | Character | | <code>%s</code> | string | Text |</p> <p>Escape Sequences: | Sequence | Meaning | |:------|:--------| | <code>\\n</code> | New line | | <code>\\t</code> | Tab | | <code>\\r</code> | Carriage return | | <code>\\a</code> | Bell sound | | <code>\\\"</code> | Double quote | | <code>\\\\</code> | Backslash |</p>"},{"location":"c/9_functions/#5-the-scanf-function-input","title":"5. The <code>scanf()</code> Function (Input)","text":"<p><code>scanf()</code> \u2192 Used to get data from the keyboard. The formatting characters are the same as <code>printf</code>, but it reads the data.</p> <p>Example: </p><pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int x, y;\n    printf(\u201cEnter two numbers: \u201d);\n    scanf(\u201c%d%d\u201d, &amp;x, &amp;y);\n    printf(\u201c%d + %d = %d\\n\u201d, x, y, x + y);\n    return 0;\n}\n</code></pre> <p>Notes: - The <code>&amp;</code> operator \u2192 gives the address of the variable. - Spaces, tabs, or Enter keys don't matter; <code>scanf</code> treats them as separators.  </p>"},{"location":"c/9_functions/#6-functions-for-reading-characters-from-the-keyboard","title":"6. Functions for Reading Characters from the Keyboard","text":""},{"location":"c/9_functions/#getchar","title":"<code>getchar()</code>","text":"<ul> <li>It is a standard C function.  </li> <li>It reads one character from the keyboard.  </li> <li>The return value is the ASCII code of the character.</li> </ul> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char ch;\n    printf(\u201cEnter a character: \u201d);\n    ch = getchar();\n    printf(\u201cCharacter: %c\\nASCII: %d\\n\u201d, ch, ch);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#getch-non-standard","title":"<code>getch()</code> (non-standard)","text":"<ul> <li>Available in most compilers (especially Windows <code>conio.h</code>).  </li> <li>No need to press Enter, the character is not printed on the screen.</li> </ul> <pre><code>#include &lt;conio.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\u201cPress a key...\\n\u201d);\n    getch();\n    printf(\"Okay, let's continue \\n\"0);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#getche-non-standard","title":"<code>getche()</code> (non-standard)","text":"<ul> <li>Similar to <code>getch()</code>, but the character you press appears on the screen.</li> </ul> <pre><code>#include &lt;conio.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\u201cPress any key (character will appear): \u201d);\n    getche();\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#comparison-table","title":"Comparison Table","text":"Function Standard? Does it require Enter? Does the character appear? <code>getchar()</code> \u2705 \u2705 \u2705 <code>getch()</code> \u274c \u274c \u274c <code>getche()</code> \u274c \u274c \u2705"},{"location":"c/9_functions/#7-escape-sequence","title":"7. <code>%%</code> Escape Sequence","text":"<p>To print the <code>%</code> character itself in <code>printf</code>: </p><pre><code>printf(\u201c%%25\\n\u201d);  // Output: %25\n</code></pre>"},{"location":"c/9_functions/#8-benefits-of-using-standard-functions","title":"8. Benefits of Using Standard Functions","text":"<ol> <li>Portability: The code works on every system.  </li> <li>Readability: The code is simple and understandable.  </li> <li>Testing: Standard functions are reliable.  </li> <li>Time Savings: Using ready-made functions speeds up the developer.  </li> <li>Sustainability: The same function behaves the same way across different compilers.</li> </ol>"},{"location":"c/9_functions/#9-conversion-specifiers-variadic-functions-and-string-literals","title":"9. Conversion Specifiers, Variadic Functions, and String Literals","text":""},{"location":"c/9_functions/#printf-is-a-variadic-function","title":"<code>printf()</code> is a Variadic Function","text":"<p><code>printf()</code> takes a variable number of arguments:</p> <pre><code>int printf(const char *format, ...);\n</code></pre> <ul> <li>First parameter: format string (<code>const char*</code>)  </li> <li><code>...</code> : variable number of arguments  </li> </ul> <p>Functions such as <code>printf</code>, <code>scanf</code>, <code>fprintf</code>, and <code>sprintf</code> are variadic.  </p>"},{"location":"c/9_functions/#string-literals-and-0-null-byte-termination","title":"String Literals and <code>\u2018\\0\u2019</code> (Null Byte Termination)","text":"<p>In C, a character string ends with a <code>\u2018\\0\u2019</code> null byte:</p> <p></p><pre><code>char str[] = \u201cHello\u201d;\n</code></pre> How it is stored in memory: <pre><code>H e l l o \\0\n</code></pre> <p>In the call <code>printf(\u201c%s\u201d, str);</code>, <code>printf</code> prints the characters one by one and terminates the process when it encounters the <code>\u2018\\0\u2019</code> character.</p>"},{"location":"c/9_functions/#conversion-specifiers","title":"Conversion Specifiers","text":"<p>The <code>%</code> character in the format string specifies a conversion:</p> <pre><code>%[flags][width][.precision][length]specifier\n</code></pre> Specifier Type Description <code>%d</code>, <code>%i</code> int Decimal number <code>%u</code> unsigned int Decimal <code>%x</code>, <code>%X</code> unsigned int Hexadecimal <code>%f</code> double Decimal <code>%e</code>, <code>%E</code> double Exponential notation <code>%c</code> char Character <code>%s</code> char* String (C string) <code>%p</code> void* Memory address <code>%%</code> \u2014 The <code>%</code> character itself"},{"location":"c/9_functions/#flags-width-and-precision","title":"Flags, Width, and Precision","text":"Element Description Example Output <code>-</code> left alignment <code>%-5d</code>, 42 <code>42</code> <code>0</code> zero-fill <code>%05d</code>, 42 <code>00042</code> <code>+</code> show sign <code>%+d</code>, 42 <code>+42</code> <code>.precision</code> decimal places <code>%.2f</code>, 3.1415 <code>3.14</code> <code>width</code> minimum space <code>%8s</code>, \u201cC\u201d <code>\u201c       C\u201d</code>"},{"location":"c/9_functions/#example-complete-formatting","title":"Example: Complete Formatting","text":"<pre><code>#include &lt;stdio.h&gt;\nint main() {\n    printf(\u201c%-10s %04d %.3f\\n\u201d, \u201cC\u201d, 7, 3.14159);\n    return 0;\n}\n</code></pre> Output: <pre><code>C          0007 3.142\n</code></pre>"},{"location":"c/9_functions/#printf-return-value","title":"<code>printf</code> Return Value","text":"<p><code>printf()</code> returns the number of characters it prints to the screen:</p> <p></p><pre><code>int n = printf(\u201cHello!\u201d);\nprintf(\u201c\\nTotal %d characters printed.\\n\u201d, n);\n</code></pre> Output: <pre><code>Hello!\nTotal 6 characters printed.\n</code></pre>"},{"location":"c/9_functions/#puts-and-putchar","title":"<code>puts()</code> and <code>putchar()</code>","text":"Function Description <code>putchar(c)</code> Writes a single character <code>puts(str)</code> Writes a string and appends <code>\\n</code> to the end <p>Example: </p><pre><code>#include &lt;stdio.h&gt;\nint main() {\n    putchar(\u2018A\u2019);\n    puts(\u201c Hello\u201d);\n    return 0;\n}\n</code></pre> Output: <pre><code>A Hello\n</code></pre>"},{"location":"c/9_functions/#memory-safety","title":"Memory Safety","text":"<p><code>printf(\u201c%d\u201d, 3.14);</code> \u2192 \u274c Undefined behavior (UB) Because <code>%d</code> expects an integer, while <code>3.14</code> is a double type.  </p> <p>Compilers usually warn about such errors with the <code>-Wall</code> option.</p>"},{"location":"c/9_functions/#10-summary-table","title":"10. Summary Table","text":"Concept Description Variadic function <code>printf</code> takes a variable number of arguments String literal A constant string enclosed in double quotes, ending with <code>\u2018\\0\u2019</code> Conversion specifier <code>%d</code>, <code>%f</code>, <code>%s</code>, <code>%p</code>, etc. <code>printf</code> return value Number of characters written Memory safety Format and argument types must match"},{"location":"c/9_functions/#additional-examples_1","title":"Additional examples","text":""},{"location":"c/9_functions/#1-return","title":"1. return","text":"<pre><code>#include &lt;stdio.h&gt;\n\n// Temel \u00f6rnek: return de\u011feri d\u00f6nd\u00fcren/d\u00f6nd\u00fcrmeyen fonksiyonlar\n\nint square(int x) {\n    return x * x; // de\u011fer d\u00f6nd\u00fcr\u00fcr\n}\n\nvoid greet(void) {\n    printf(\"Merhaba!\\n\"); // hi\u00e7bir \u015fey d\u00f6nd\u00fcrmez\n}\n\nint main(void) {\n    greet();\n    printf(\"5'in karesi: %d\\n\", square(5));\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#2-definition-call","title":"2. definition call","text":"<pre><code>#include &lt;stdio.h&gt;\n\n// Bildirim (prototip)\nint topla(int, int);\n\nint main(void) {\n    int sonuc = topla(3, 4);\n    printf(\"Toplam = %d\\n\", sonuc);\n    return 0;\n}\n\n// Tan\u0131mlama\nint topla(int a, int b) {\n    return a + b;\n}\n</code></pre>"},{"location":"c/9_functions/#3-parameters","title":"3. parameters","text":"<pre><code>#include &lt;stdio.h&gt;\n\n// Parametre aktar\u0131m\u0131 (by value): kopya \u00fczerinden \u00e7al\u0131\u015f\u0131r\n\nvoid arttir(int a) {\n    a++;\n    printf(\"\u0130\u015flev i\u00e7inde: %d\\n\", a);\n}\n\nint main(void) {\n    int x = 10;\n    arttir(x);\n    printf(\"Ana programda: %d\\n\", x); // x de\u011fi\u015fmez\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#4-nested-calls","title":"4. nested calls","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint add(int a, int b) { return a + b; }\nint square(int x)     { return x * x; }\n\nint main(void) {\n    int sonuc = add(square(3), square(4));\n    printf(\"(3^2 + 4^2) = %d\\n\", sonuc);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#5-recursion","title":"5. recursion","text":"<pre><code>#include &lt;stdio.h&gt;\n\n// Klasik: fakt\u00f6riyel (\u00f6zyineleme)\n\nint factorial(int n) {\n    if (n == 0) return 1;\n    return n * factorial(n - 1);\n}\n\nint main(void) {\n    printf(\"5! = %d\\n\", factorial(5));\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#6-stdio_basics","title":"6. stdio_basics","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int x;\n    printf(\"Bir say\u0131 girin: \");\n    if (scanf(\"%d\", &amp;x) == 1) {\n        printf(\"Girdi\u011finiz say\u0131: %d\\n\", x);\n    } else {\n        printf(\"Ge\u00e7ersiz giri\u015f!\\n\");\n    }\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#7-conversion-specifiers","title":"7. conversion specifiers","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int i = 255;\n    double d = 3.14159;\n    char c = 'A';\n    const char *s = \"Merhaba\";\n\n    printf(\"int: %d, hex: %x, octal: %o\\n\", i, i, i);\n    printf(\"float: %.2f, scientific: %.3e\\n\", d, d);\n    printf(\"char: %c, string: %s\\n\", c, s);\n    printf(\"adres: %p\\n\", (void*)s);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#8-variadic","title":"8. variadic","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdarg.h&gt;\n\n// \u00c7ok basit bir mini printf: sadece %d destekli\nvoid mini_print(const char *fmt, ...) {\n    va_list args;\n    va_start(args, fmt);\n    while (*fmt) {\n        if (*fmt == '%' &amp;&amp; *(fmt + 1) == 'd') {\n            int val = va_arg(args, int);\n            printf(\"%d\", val);\n            fmt += 2;\n        } else {\n            putchar(*fmt++);\n        }\n    }\n    va_end(args);\n}\n\nint main(void) {\n    mini_print(\"Sonuc: %d + %d = %d\\n\", 2, 3, 5);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#9-strings","title":"9. strings","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char str[] = \"C dili\"; // '\\0' ile sonlan\u0131r\n    printf(\"Yaz\u0131: %s\\n\", str);\n\n    int i = 0;\n    while (str[i] != '\\0') {\n        printf(\"%c \", str[i]);\n        i++;\n    }\n    printf(\"\\nUzunluk: %d\\n\", i);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#10-escape-sequences","title":"10. escape sequences","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Yeni satir\\\\nve tab\\\\t\u00f6rne\u011fi\\n\");\n    printf(\"Ters b\u00f6l\u00fc: \\\\\\\\ ve t\u0131rnak: \\\\\\\" \\n\");\n    printf(\"Sekizlik: \\\\101 (A), Onalt\u0131l\u0131k: \\\\x41 (A)\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#11-stdlib_demo","title":"11. stdlib_demo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n#include &lt;string.h&gt;\n#include &lt;ctype.h&gt;\n\nint main(void) {\n    double x = 9.0;\n    printf(\"sqrt(%.2f) = %.2f\\n\", x, sqrt(x));\n\n    char buf[64] = \"C\";\n    const char *s2 = \" Programlama\";\n    strcat(buf, s2); // dikkat: hedef buffer yeterince b\u00fcy\u00fck olmal\u0131\n    printf(\"Birle\u015ftirme: %s\\n\", buf);\n\n    char ch = 'a';\n    printf(\"%c -&gt; %c\\n\", ch, toupper((unsigned char)ch));\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#12-printf","title":"12. printf","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"%10s\\n\", \"C\");      // sa\u011fa yasla\n    printf(\"%-10s\\n\", \"C\");     // sola yasla\n    printf(\"%04d\\n\", 7);        // s\u0131f\u0131rla doldur\n    printf(\"%+d\\n\", 42);        // i\u015faret g\u00f6ster\n    printf(\"%.3f\\n\", 3.14159);  // ondal\u0131k basamak\n    printf(\"%#x\\n\", 255);       // alternatif bi\u00e7im -&gt; 0xff\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#13-char_io","title":"13. char_io","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int ch; // getchar() int d\u00f6nd\u00fcr\u00fcr (EOF-end of file- ay\u0131rt\u0131 i\u00e7in)\n    printf(\"Bir karakter girin: \");\n    ch = getchar();\n    if (ch != EOF) {\n        printf(\"Girdi\u011finiz karakter: \");\n        putchar(ch);\n        putchar('\\n');\n    }\n    puts(\"----Program bitti.----\");\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#14-undefined-behaviour","title":"14. undefined behaviour","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    // UYARI: A\u015fa\u011f\u0131daki sat\u0131r tan\u0131ms\u0131z davran\u0131\u015ft\u0131r (UB).\n    // %d tamsay\u0131 beklerken double g\u00f6nderilirse sonu\u00e7 belirsizdir.\n    printf(\"%d\\n\", 3.14);\n\n    // Do\u011frusu:\n    printf(\"%f\\n\", 3.14);\n\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#functions-3","title":"Functions 3","text":""},{"location":"c/9_functions/#1-purpose-of-character-inputoutput-functions","title":"1. Purpose of Character Input/Output Functions","text":"<p>In the C language, character-based input/output operations are used to read a single character from the keyboard or write a single character to the screen. These functions are simpler and faster than formatted input/output (<code>printf</code>, <code>scanf</code>) operations.</p>"},{"location":"c/9_functions/#2-the-putchar-function","title":"2. The <code>putchar()</code> Function","text":"<pre><code>int putchar(int ch);\n</code></pre> <ul> <li>A standard C function.  </li> <li>Writes the character in its parameter to the location of the cursor on the screen. </li> <li>Return value: the ASCII code value of the written character. </li> <li>Its definition is in the <code>stdio.h</code> header file.</li> </ul>"},{"location":"c/9_functions/#example","title":"Example","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char ch;\n    ch = getchar();   // read a character from the keyboard\n    putchar(ch);      // write the character to the screen\n    return 0;\n}\n</code></pre> <p>The same operation could also be performed with the line <code>printf(\u201c%c\u201d, ch);</code>.</p>"},{"location":"c/9_functions/#3-the-putch-function","title":"3. The <code>putch()</code> Function","text":"<pre><code>int putch(int ch);\n</code></pre> <ul> <li>It is a non-standard function (under <code>conio.h</code>).  </li> <li>Difference from <code>putchar</code>: It writes the <code>' '</code> character only as LF (ASCII 10).</li> </ul>"},{"location":"c/9_functions/#example_1","title":"Example","text":"<pre><code>#include &lt;conio.h&gt;\nint main(void) {\n    putch(\u2018A\u2019);\n    putch(\u2018\\n\u2019);\n    putch(\u2018B\u2019);\n    return 0;\n}\n</code></pre> <p><code>A</code> and <code>B</code> appear on the screen in the same column, one below the other.</p>"},{"location":"c/9_functions/#4-the-puts-function","title":"4. The <code>puts()</code> Function","text":"<pre><code>int puts(const char *str);\n</code></pre> <ul> <li>It performs the same function as <code>printf(\u201c%s\\n\u201d, str);</code> but automatically adds <code>\\n</code>.</li> <li>It writes up to the <code>\\0</code> character.</li> </ul>"},{"location":"c/9_functions/#example_2","title":"Example","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    puts(\u201cHello World\u201d);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#5-getchar-function","title":"5. <code>getchar()</code> Function","text":"<pre><code>int getchar(void);\n</code></pre> <ul> <li>Reads one character from the keyboard.  </li> <li>Reading is completed when the Enter key is pressed.</li> <li>Return value: the ASCII value of the character (<code>int</code>).</li> </ul>"},{"location":"c/9_functions/#example_3","title":"Example","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int ch;\n    printf(\u201cEnter a character: \u201d);\n    ch = getchar();\n    printf(\u201cThe character you entered: \u201d);\n    putchar(ch);\n    putchar(\u2018\\n\u2019);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#6-getch-and-getche-functions","title":"6. <code>getch()</code> and <code>getche()</code> Functions","text":"Function Description Standard? Does it require Enter? Is the character visible? <code>getch()</code> Reads the character, does not print it to the screen \u274c \u274c \u274c <code>getche()</code> Reads the character, also prints it to the screen \u274c \u274c \u2705"},{"location":"c/9_functions/#getch-example","title":"<code>getch()</code> Example","text":"<pre><code>#include &lt;conio.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\u201cPress a key...\\n\u201d);\n    getch();\n    printf(\u201cOkay, let's continue!\\n\u201d);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#getche-example","title":"<code>getche()</code> Example","text":"<pre><code>#include &lt;conio.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\u201cPress a key (character will appear on screen): \u201d);\n    getche();\n    printf(\u201c\\nReading completed.\\n\u201d);\n    return 0;\n}\n</code></pre> <p>Both functions are located in the <code>conio.h</code> library and are not portable.</p>"},{"location":"c/9_functions/#7-gets-function-should-not-be-used","title":"7. <code>gets()</code> Function (SHOULD NOT BE USED)","text":"<pre><code>char *gets(char *str);\n</code></pre> <ul> <li>Reads a line of text from the user.  </li> <li>Takes all characters until the <code>Enter</code> key is pressed.  </li> <li>Not secure (buffer overflow risk).</li> </ul>"},{"location":"c/9_functions/#safe-alternative","title":"Safe Alternative","text":"<pre><code>fgets(str, sizeof(str), stdin);\n</code></pre>"},{"location":"c/9_functions/#safe-usage","title":"Safe Usage","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char name[20];\n    printf(\u201cEnter your name: \u201d);\n    fgets(name, sizeof(name), stdin);\n    printf(\u201cHello %s\u201d, name);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#8-function-comparison-table","title":"8. Function Comparison Table","text":"Function Task Standard Return Line Ending Note <code>putchar</code> Writes 1 character \u2705 ASCII code Manual Basic output <code>putch</code> Writes 1 character \u274c ASCII code LF (only) <code>conio.h</code> <code>puts</code> Writes string \u2705 int Automatic <code>\\n</code> Fast <code>getchar</code> Reads 1 character \u2705 ASCII code Enter required basic input <code>getch</code> Reads 1 character \u274c ASCII code Enter not required invisible on screen <code>getche</code> Reads 1 character \u274c ASCII code Enter not required visible on screen <code>gets</code> Reads string \u274c (removed in C11) pointer line end not included security risk"},{"location":"c/9_functions/#inputoutput-application","title":"Input/Output Application","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char ch;\n    printf(\u201cEnter a character (end with x): \u201d);\n    do {\n        ch = getchar();\n        putchar(ch);\n    } while (ch != \u2018x\u2019);\n    return 0;\n}\n</code></pre> Characters are printed to the screen as-is until the user enters <code>x</code>."},{"location":"c/9_functions/#10-result","title":"10. Result","text":"<ul> <li><code>putchar</code> \u2192 standard, for printing characters</li> <li><code>putch</code> \u2192 non-standard, for DOS/Windows systems  </li> <li><code>puts</code> \u2192 prints a string, adds <code>\\n</code> </li> <li><code>getchar</code> \u2192 standard, reads a character  </li> <li><code>getch</code> / <code>getche</code> \u2192 not portable  </li> <li><code>gets</code> \u2192 should not be used, use <code>fgets</code> instead</li> </ul>"},{"location":"c/9_functions/#additional-examples_2","title":"Additional examples","text":""},{"location":"c/9_functions/#1-putchar","title":"1. putchar","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char ch;\n    printf(\"Bir karakter girin: \");\n    ch = getchar();   // klavyeden tek karakter oku\n    printf(\"Ekrana yaz\u0131l\u0131yor: \");\n    putchar(ch);      // karakteri yaz\n    putchar('\\n');    // sat\u0131r sonu\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#2-puts-printf","title":"2. puts printf","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char ch;\n    printf(\"Bir karakter girin: \");\n    ch = getchar();   // klavyeden tek karakter oku\n    printf(\"Ekrana yaz\u0131l\u0131yor: \");\n    putchar(ch);      // karakteri yaz\n    putchar('\\n');    // sat\u0131r sonu\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#3-getchar","title":"3. getchar","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char ch;\n    printf(\"Bir \u015feyler yaz\u0131n (x ile \u00e7\u0131k\u0131\u015f):\\n\");\n    do {\n        ch = getchar();\n        putchar(ch);\n    } while (ch != 'x');\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#4-getch-and-getche","title":"4. getch and getche","text":"<pre><code>#include &lt;conio.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Bir tu\u015fa bas\u0131n (getch): \");\n    getch(); // Enter gerekmez\n    printf(\"\\ngetche test (karakter g\u00f6r\u00fcn\u00fcr): \");\n    getche(); // karakter g\u00f6r\u00fcn\u00fcr\n    printf(\"\\nTamamland\u0131.\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#5-putch","title":"5. putch","text":"<pre><code>#include &lt;conio.h&gt;\n\nint main(void) {\n    putch('A');\n    putch('\\n');\n    putch('B');\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#6-gets-and-gfets","title":"6. gets and gfets","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char ad1[20], ad2[20];\n\n    printf(\"Ad\u0131n\u0131z\u0131 (gets ile) girin: \");\n    gets(ad1);  // \u26a0\ufe0f TEHL\u0130KEL\u0130 \u2014 boyut kontrol\u00fc yok!\n\n    printf(\"Ad\u0131n\u0131z\u0131 (fgets ile) girin: \");\n    fgets(ad2, sizeof(ad2), stdin);\n\n    printf(\"\\ngets sonucu : %s\\n\", ad1);\n    printf(\"fgets sonucu: %s\\n\", ad2);\n\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#7-fgets","title":"7. fgets","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    char isim[30];\n    printf(\"Ad\u0131n\u0131z\u0131 girin: \");\n    fgets(isim, sizeof(isim), stdin);\n    isim[strcspn(isim, \"\\n\")] = '\\0'; // \\n karakterini sil\n    printf(\"Merhaba %s!\\n\", isim);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#8-eof_end-of-file","title":"8. EOF_end of file","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int ch;\n    printf(\"Ctrl+Z (Windows) veya Ctrl+D (Linux) ile \u00e7\u0131k\u0131n:\\n\");\n    while ((ch = getchar()) != EOF) {\n        putchar(ch);\n    }\n    printf(\"\\nEOF alg\u0131land\u0131.\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#9-getchar-ascii","title":"9. getchar ascii","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int ch;\n    printf(\"Bir karakter girin (x ile bitir): \");\n    do {\n        ch = getchar();\n        printf(\"Karakter: %c | ASCII: %d\\n\", ch, ch);\n    } while (ch != 'x');\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#10-shadow-password","title":"10. shadow password","text":"<pre><code>#include &lt;conio.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char pass[20];\n    int i = 0;\n    char ch;\n\n    printf(\"\u015eifre girin: \");\n    while (i &lt; 19 &amp;&amp; (ch = getch()) != '\\r') { // '\\r' = Enter\n        pass[i++] = ch;\n        putch('*'); // maskelenmi\u015f yazd\u0131rma\n    }\n    pass[i] = '\\0';\n    printf(\"\\nGirdi\u011finiz \u015fifre: %s\\n\", pass);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#11-write-and-read","title":"11. write and read","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c;\n    printf(\"Metin girin ('.' ile bitir):\\n\");\n    while ((c = getchar()) != '.') {\n        if (c &gt;= 'a' &amp;&amp; c &lt;= 'z')\n            c -= 32; // k\u00fc\u00e7\u00fck \u2192 b\u00fcy\u00fck\n        putchar(c);\n    }\n    printf(\"\\nTamamland\u0131.\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#12-definition-void-and-main","title":"12. Definition, <code>void</code> and <code>main</code>","text":"<pre><code>#include &lt;stdio.h&gt;\n\n// 1. VOID Function Definition (No return value, no parameters)\n// Purpose: To perform a specific task (printing)\nvoid print_separator() {\n    printf(\"\\n--------------------------\\n\");\n    // A void function can optionally use 'return;' to exit early.\n}\n\n// 2. Value-Returning Function Definition (Returns an int, takes no parameters)\n// Purpose: To calculate and return a value.\nint get_current_year() {\n    // Returns the calculated result (2025 in this example)\n    return 2025; \n}\n\n// 8. The main function - the program's starting point\nint main() {\n\n    // 9. Function Invocation (Void function call)\n    print_separator();\n    printf(\"C Functions: Basic Demo\\n\");\n    print_separator();\n\n    // 9. Function Invocation (Value-returning function, result used immediately)\n    printf(\"The current year is: %d\\n\", get_current_year());\n\n    // 9. Function Invocation (Value-returning function, result assigned to a variable)\n    int year = get_current_year();\n    printf(\"Year stored in variable 'year': %d\\n\", year);\n\n    // 8. The return value of main is passed to the OS (0 means success)\n    return 0; \n}\n</code></pre>"},{"location":"c/9_functions/#13-parameters-and-pass-by-value","title":"13. Parameters and Pass by-value","text":"<p>Please remember in pass by-value the arguments are copied, the original variable remains unchanged</p> <pre><code>#include &lt;stdio.h&gt;\n\n// 11. New Style Function Definition with Parameters\n// Takes two int parameters (copies) and returns their sum (int)\nint add_numbers(int a, int b) {\n    // 7. Returns the calculated result.\n    return a + b;\n}\n\n// 15. Demonstrating Copying Arguments (Pass-by-Value)\n// The parameter 'val' is a copy of the argument passed in.\nvoid try_to_change(int val) {\n    printf(\"  Inside function: Original value is %d\\n\", val);\n    val = 999; // Only changes the local copy 'val'\n    printf(\"  Inside function: Value changed to %d (local copy)\\n\", val);\n    return; // 7. Void function using 'return;'\n}\n\nint main() {\n    int x = 10;\n    int y = 20;\n\n    printf(\"--- 1. Using Parameters ---\\n\");\n\n    // 9. Function Invocation: x and y are the actual parameters.\n    // Their values (10 and 20) are copied to parameters a and b.\n    int sum_result = add_numbers(x, y); \n    printf(\"Sum of %d and %d is: %d\\n\", x, y, sum_result); // Output: 30\n\n    printf(\"\\n--- 2. Pass-by-Value (Copying Arguments) ---\\n\");\n\n    int original_value = 50;\n    printf(\"Before call: Original variable value is %d\\n\", original_value);\n\n    // 15. Call the function, passing a copy of 50.\n    try_to_change(original_value); \n\n    // The function's change to 'val' did not affect 'original_value'.\n    printf(\"After call: Original variable value remains %d\\n\", original_value); // Output: 50\n\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#14-recursion-and-nested-calls","title":"14. Recursion and Nested Calls","text":"<p>recursion (a function calling itself) and nested function calls (using one function's return value as another's input). </p><pre><code>#include &lt;stdio.h&gt;\n\n// Helper function for nested calls\nint square(int n) {\n    return n * n;\n}\n\n// 17. Recursive Function Definition: Calculates factorial\nint factorial(int n) {\n    // Base Case (Stops the recursion)\n    if (n == 0) {\n        printf(\"  [Base Case] Reached n=0, returning 1.\\n\");\n        return 1;\n    }\n\n    // Recursive Step\n    printf(\"  Calling factorial(%d) * %d...\\n\", n - 1, n);\n    // Function calling itself\n    return n * factorial(n - 1); \n}\n\n\n// Value-returning function with a function call inside its return\nint calculate_hypotenuse_squared(int a, int b) {\n    // 16. Another call inside return: Uses nested calls.\n    // square(a) and square(b) are evaluated first.\n    return add_numbers(square(a), square(b)); // Assuming add_numbers is available/defined\n}\n\n// A function defined earlier (from Intermediate Demo)\nint add_numbers(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    printf(\"--- 1. Nested and Return Calls ---\\n\");\n\n    int side1 = 3;\n    int side2 = 4;\n\n    // 16. Nested call: calculate_hypotenuse_squared is called.\n    // Inside it, add_numbers is called, and inside that, square is called twice.\n    int h_squared = calculate_hypotenuse_squared(side1, side2);\n    printf(\"Side 1^2 + Side 2^2 (3^2 + 4^2) = %d\\n\", h_squared); // Output: 25\n\n    printf(\"\\n--- 2. Recursive Function (Factorial) ---\\n\");\n    int number = 4;\n    printf(\"Calculating Factorial of %d:\\n\", number);\n\n    // 17. Recursive call starts here\n    int fact_result = factorial(number); \n    printf(\"Result of 4! is: %d\\n\", fact_result); // Output: 24\n\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#15-prototypes-linking-and-return-constraints","title":"15. Prototypes, Linking, and Return Constraints","text":"<p>declarations (prototypes), the linker phase, and what happens when a function's return value is ignored or misused. </p><pre><code>#include &lt;stdio.h&gt;\n\n// 1. Function Prototype (Declaration)\n// This tells the compiler the function exists, its signature, and its return type.\n// It allows us to define the function later or in a separate file.\nint calculate_something(int x, int y); \n\n// 5. Function Without a Specified Type (Old C/Pre-ANSI C)\n// The compiler automatically assumes 'int' return type. (Not recommended).\n// 10. This is defined *before* the call, so no prototype is strictly needed.\nno_type_func() {\n    printf(\"-&gt; (Warning) Function without a specified type. Assumed 'int'.\\n\");\n    return 100;\n}\n\n// 3. Main function demonstrating function calls\nint main() {\n    int a = 10, b = 5;\n\n    printf(\"--- 1. Using and Not Using Return Values ---\\n\");\n\n    // 16. Value-returning function, result assigned. (Normal use)\n    int result = calculate_something(a, b);\n    printf(\"Result used (10 * 5) = %d\\n\", result);\n\n    // 16. Call without using the value. (Can sometimes trigger a warning)\n    calculate_something(a, b);\n    printf(\"Result not used. (Compiler might issue 'code has no effect!')\\n\");\n\n    // 9. Function Invocation: func() = 5 is Invalid (R-value constraint)\n    // The value produced by a function call is an R-value, it cannot be assigned to.\n    // Error: L-value required as left operand of assignment.\n    // (If you uncomment the line below, it will cause a compile error.)\n    // calculate_something(a, b) = 100; \n\n    // Call function with implicit 'int' return type\n    printf(\"no_type_func returned: %d\\n\", no_type_func());\n\n    return 0;\n}\n\n// 5. Function Definition (Must be defined somewhere for the linker)\nint calculate_something(int x, int y) {\n    return x * y;\n}\n\n// 10. Undefined Function Example\n// If we had a prototype for 'void linker_error();' but no definition anywhere,\n// the compiler would be happy, but the *linker* would fail.\n</code></pre>"},{"location":"c/9_functions/#16-old-style-vs-new-style-and-int-foo-vs-int-foovoid","title":"16. Old Style vs. New Style and <code>int foo()</code> vs. <code>int foo(void)</code>","text":"<p>Old Style vs. New Style and int foo() vs. int foo(void) </p><pre><code>#include &lt;stdio.h&gt;\n\n// 14. Function without Parameters (Implicit 'void') - Deprecated\n// In C, an empty parenthesis means \"takes an unspecified number of arguments.\"\n// The compiler does NOT check the number of arguments passed in the function call.\nint old_style_no_param() {\n    return 1;\n}\n\n// 14. Function without Parameters (Explicit 'void') - New Style\n// This is the correct, modern way to state a function takes NO arguments.\n// The compiler WILL issue an error if arguments are passed.\nint new_style_no_param(void) {\n    return 2;\n}\n\n// 12. Old Style Parameter Declaration (Pre-ANSI C)\n// Parameter types are listed after the function header. This is obsolete.\nint old_style_params(x, y)\nint x; \nint y; // The compiler can still compile this but throws a warning.\n{\n    printf(\"  [Old Style] Parameters: %d and %d\\n\", x, y);\n    return x - y;\n}\n\n\nint main() {\n    printf(\"--- 1. New Style vs. Old Style Parameters ---\\n\");\n\n    // 13. New Style Call: Types declared in the parentheses.\n    printf(\"New Style Subtraction (10 - 5): %d\\n\", old_style_params(10, 5));\n\n    printf(\"\\n--- 2. Parameter Constraints: () vs. (void) ---\\n\");\n\n    // Using () (unspecified)\n    printf(\"old_style_no_param() returned: %d\\n\", old_style_no_param());\n\n    // DANGER: We can call the '()' function with arguments, and the compiler\n    // may not complain, leading to Unspecified Behavior! (Value is ignored/garbage)\n    printf(\"old_style_no_param(100, 200) returned: %d\\n\", old_style_no_param(100, 200));\n\n    // Using (void)\n    printf(\"new_style_no_param(void) returned: %d\\n\", new_style_no_param());\n\n    // ERROR: If you uncomment the line below, the compiler will catch it,\n    // as the (void) parameter list explicitly states no arguments are allowed.\n    // printf(\"new_style_no_param(100) returned: %d\\n\", new_style_no_param(100));\n\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#17-return-flow-and-exit","title":"17. Return flow and exit","text":"<p>function exit points, including using <code>return</code> in a <code>void</code> function, and the difference between the actual return value and the OS return value. </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt; // For EXIT_SUCCESS/EXIT_FAILURE\n\n// A value-returning function that might return a garbage value.\nint check_and_exit(int x) {\n    if (x &lt; 0) {\n        printf(\"Condition met, exiting early with status code 1.\\n\");\n        // We can use 'return' with a value here, but we are also\n        // using the standard library's exit function to terminate the *entire program* immediately.\n        exit(EXIT_FAILURE); // Terminates the program entirely, bypassing the return\n    }\n\n    // 7. If the end is reached without a return statement, it returns a garbage value.\n    // NOTE: Many modern compilers will issue a warning or error if a non-void\n    // function reaches the end without a return statement, but the C standard allows it.\n}\n\n\n// A void function demonstrating early exit\nvoid process_data(int data) {\n    if (data == 0) {\n        printf(\"Data is zero, cannot process. Exiting function early.\\n\");\n        // 7. return; used to end execution in a void function.\n        return; \n    }\n\n    printf(\"Data %d processed successfully.\\n\", data);\n}\n\nint main() {\n    printf(\"--- 1. Void Function Exit Flow ---\\n\");\n    process_data(10);\n    process_data(0); // This call triggers an early return\n    process_data(20); // This is executed after the early return\n\n    printf(\"\\n--- 2. main() Return Value ---\\n\");\n\n    // 8. The return value of main is passed to the operating system.\n    // A function call that returns a value (r-value)\n    int result = check_and_exit(5);\n\n    // 8. Convention: 0 for success.\n    return EXIT_SUCCESS; // which is usually 0\n\n    /*\n    If we had called check_and_exit(-1) instead, the program would have\n    terminated immediately inside that function with exit(EXIT_FAILURE),\n    and the 'return EXIT_SUCCESS' line here would never be reached.\n    */\n}\n</code></pre>"}]}