{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#burak-rustemogullar-robotics-programming-notes","title":"\ud83c\udfe0 Burak R\u00fcstemo\u011fullar\u0131 \u2014 Robotics &amp; Programming Notes","text":"<p>Welcome! This documentation contains my personal notes on robotics, programming languages, algorithms, and embedded systems.</p>"},{"location":"#sections","title":"Sections","text":""},{"location":"#c-programming","title":"C programming","text":""},{"location":"c/10_scope_and_lifetime/","title":"Scope and Lifetime","text":""},{"location":"c/10_scope_and_lifetime/#scope-and-storage-duration","title":"Scope and Storage Duration","text":"<p>In previous topics, the names, values, and types of objects were discussed. Objects also have three more properties that are very important in terms of the C language: scope, storage duration, and linkage.</p>"},{"location":"c/10_scope_and_lifetime/#scope","title":"Scope","text":"<p>Scope is the program region within which an identifier (name) can be recognized. Names declared to the compiler are not known everywhere by the compiler. Each name can only be recognized by the compiler within \"that name's scope.\" Scope is a concept directly related to the source code, thus it is associated with compile-time. In the C language, variables declared to the compiler are only accessible in certain parts of the source code. That is, defining a variable does not mean that the variable can be accessed from everywhere in the source file.</p> <p>C standards categorize scopes into 4 distinct groups:</p> <ol> <li>File scope: A name is known throughout the entire source file after its declaration, meaning within all defined functions.</li> <li>Block scope: A name is known only within a block after its declaration.</li> <li>Function Scope: A name is known only within a block after its declaration. This is a special definition covering only <code>goto</code> labels. This scope will be addressed in the section on the \"goto statement.\"</li> <li>Function Prototype Scope: A definition covering the recognition of names used within the function parameter list in function declarations. This scope will be addressed in the section on \"Function Declarations.\"</li> </ol> <p>Variables defined within a source file can be divided into two categories, \"local\" and \"global,\" based on their scope:</p>"},{"location":"c/10_scope_and_lifetime/#local-variables","title":"Local Variables","text":"<p>Variables defined inside blocks or within the parameter lists of functions are called local variables. In the C language, you know that definitions of variables inside blocks must be done at the very beginning of the block. Local variables are variables defined within a block; they might be declared within a function's main block or within an inner block.</p> <p>The scope of local variables is block scope. That is, local variables can only be accessed within the block in which they are defined. They cannot be accessed in a block outside the block in which they are defined.</p> <p>All variables defined in the following program are local, because the variables named \\(x\\), \\(y\\), and \\(z\\) are defined inside blocks. These variables can only be used within the block in which they are defined. Their use outside their defining block is invalid. Statements enclosed in comment lines are invalid. Variables \\(z\\) and \\(y\\) are used outside their scope.</p> <p>In the example above, since all variables are local, they conform to the block scope rule, but this does not mean that the scopes of all 3 variables are exactly the same. In the example program, variable \\(x\\) has the widest scope, while variable \\(y\\) has a smaller scope, and variable \\(z\\) has the smallest scope.</p>"},{"location":"c/10_scope_and_lifetime/#block-scope","title":"Block Scope","text":"<pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int x = 10;\n    printf(\"x = %d\\n\", x);\n    {\n        int y = 20;\n        printf(\"y = %d\\n\", y);\n        x = 30;\n        {\n            int z = 50;\n            y = 60;\n            printf(\"z = %d\\n\", z);\n            printf(\"x = %d\\n\", x);\n            printf(\"y = %d\\n\", y);\n        }\n        // z = 100; /* Invalid! */\n        y = x;\n        printf(\"x = %d\\n\", x);\n        printf(\"y = %d\\n\", y);\n    }\n    // y = 500; /* Invalid! */\n    printf(\"x = %d\\n\", x);\n    return 0;\n}\n</code></pre>"},{"location":"c/10_scope_and_lifetime/#function-parameters-and-block-scope","title":"Function Parameters and Block Scope","text":"<p>Formal parameters (function parameters) also adhere to the block scope rule. These variables are known within the function's main block. The scope of a function parameter variable ends when the main block of the function closes. That is, the scope of a function parameter variable is the function's main block. </p><pre><code>void func (int a, double b)\n{\n    /* a and b are known everywhere within this function. */\n}\n</code></pre> In the example above, the variables named <code>a</code> and <code>b</code>, which are the formal parameters of the <code>func</code> function, can be used anywhere within the <code>func</code> function."},{"location":"c/10_scope_and_lifetime/#global-variables","title":"Global Variables","text":"<p>You know that variables can also be defined outside of blocks in the C language. Variables defined outside of blocks are called global variables.</p> <p>The compilation process has a direction: it is top-down within the source code. Whether a variable is local or global, its use before its definition is invalid. Global variables are known everywhere from the point they are defined until the end of the source file: </p><pre><code>#include &lt;stdio.h&gt;\nint g; // Global variable\nvoid func()\n{\n    g = 10;\n}\nint main()\n{\n    g = 20;\n    printf(\"g = %d\\n\", g);\n    func();\n    printf(\"g = %d\\n\", g);\n    /* g = 20 */\n    /* g = 10 */\n    return 0;\n}\n</code></pre> In the example above, since the variable <code>g</code> is defined outside a block\u2014or not defined within any function\u2014it is a global variable. The scope of the variable <code>g</code> is file scope. That is, the variable <code>g</code> can be used within all functions after its definition. In the program above, the global variable <code>g</code> is first assigned the value 20. Then, this value is printed to the screen using the <code>printf</code> function. After that, the <code>func</code> function is called. When <code>func</code> is called, the flow of the code passes to the <code>func</code> function. The global variable <code>g</code> is also known within the <code>func</code> function. After the global variable <code>g</code> is assigned the value 10 within the <code>func</code> function, this value is printed to the screen again using the <code>printf</code> function."},{"location":"c/10_scope_and_lifetime/#variables-with-the-same-name","title":"Variables with the Same Name","text":"<p>More than one variable with the same name can be defined in the C language. The general rule is this: If the scopes of two variables are the same, these variables cannot have the same name. Having the same name will cause a compile-time error. What does it mean for two variables to have the same scope? If the scopes of two variables end with the same closing curly brace (<code>}</code>), then these variables have the same scope. </p><pre><code>{\n    float a;\n    int b;\n    double a; // Invalid\n    {\n        int c;\n        /*...*/\n    }\n}\n/* Invalid because both 'a' variables have the same scope. */\n</code></pre> <p>More than one variable with the same name, but with different scopes, can be defined. For the compilers, the fact that these variables have the same name is no longer important. They are stored in different places in memory. Consider the following example:</p> <p></p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int x = 100;\n    printf(\"%d\\n\", x);\n    {\n        int x = 200; // A different x\n        printf(\"%d\\n\", x);\n        {\n            int x = 300; // A third x\n            printf(\"%d\\n\", x);\n        }\n    }\n    return 0;\n}\n</code></pre> There is no error in the program snippet above because the scopes of all three \\(x\\) variables are different from each other. So, when the name \\(x\\) is used in the inner blocks in the example above, which \\(x\\) variable does the compiler associate it with? <p>If a point in the source code is within the scope of multiple variables with the same name, which of these variables is accessed at that point?</p> <p>When the compiler encounters the use of a name, it tries to find which software entity this name belongs to. This process is called \"name lookup.\" Name lookup is performed from the narrowest scope to the widest scope. That is, the compiler first searches for the name in its own block. If the name is not defined within this block, it is then searched for in the enclosing blocks. If the name cannot be found in the enclosing blocks, it is then searched for in the global name space.</p> <p>A name with a narrower scope masks or prevents the visibility of the same name in a wider scope. Consider the following program: </p><pre><code>void func1()\n{\n    int k;\n    /***/\n}\nvoid func2()\n{\n    int k;\n    /***/\n}\nvoid func3()\n{\n    int k;\n    /***/\n}\n</code></pre> <p>There is no error in the code snippet above. Although a variable named <code>k</code> is defined in all three functions, their scopes are completely different from each other.</p> <p>Can a local variable have the same name as a global variable? Since the scopes of the two variables are not the same, this does not cause an error.</p> <p>At a point where both a global variable and a local variable with the same name are accessible, the one accessed will be the local variable. This is because if there are multiple variables with the same name in the same scope, the one with the narrowest scope in that area is accessible. Examine the following code:</p> <pre><code>#include &lt;stdio.h&gt;\nint g = 20; /* g global variable */\n\nvoid func()\n{\n    /* global g variable is assigned. */\n    g = 100;\n    /* the value of the global g variable is printed. */\n    printf(\"global g = %d\\n\", g);\n}\n\nint main()\n{\n    int g; /* g local variable */\n    /* local g variable is assigned */\n    g = 200;\n    /* local g is printed. */\n    printf(\"local g = %d\\n\", g);\n    func();\n    /* local g is printed. */\n    printf(\"local g = %d\\n\", g);\n}\nreturn 0; // Note: 'return 0;' should be inside 'main' block.\n</code></pre> <p>Since functions themselves are defined outside all blocks, they are also global entities. Indeed, functions can be called from anywhere in the source code. Since there cannot be more than one variable with the same name belonging to the same scope, there also cannot be more than one function with the same name.</p> <p>[However, in C++, it is possible to define multiple functions with the same name but different parametric structures (function overloading).]</p> <p>A declared name may not be accessible everywhere within its scope. This is because a name might be masked by the same name in a narrower scope. For this reason, in addition to \"scope,\" one can also talk about the term \"visibility.\"</p> <p>[In C++, if a global name is masked by a local name, access to the global name is possible with an operator called the scope resolution operator (<code>::</code>).]</p>"},{"location":"c/10_scope_and_lifetime/#storage-duration-of-objects","title":"Storage Duration of Objects","text":"<p>Storage duration (lifespan) is a term used to describe the period during the program's runtime in which objects occupy memory space. Not all variables defined within a source code are created simultaneously when the program starts running. Entities used in programs can be divided into three groups based on their storage duration:</p> <ol> <li>Static duration entities</li> <li>Automatic duration entities</li> <li>Dynamic duration entities</li> </ol>"},{"location":"c/10_scope_and_lifetime/#i-static-duration-entities","title":"i. Static Duration Entities","text":"<p>Static duration entities (static storage class) take their place in memory when the program starts running and persist until the program finishes executing; that is, they occupy memory. Static duration entities are typically written into the object code (<code>.obj</code>). In the C language, there are three distinct groups of static duration entities:</p> <ul> <li>Global variables</li> <li>String literals (text within double quotes)</li> <li>Static local variables</li> </ul> <p>You will see string literals and static local variables later.</p> <p>Global variables are static duration entities. That is, global variables are variables that live throughout the program's execution, meaning they occupy memory throughout the program's execution.</p>"},{"location":"c/10_scope_and_lifetime/#ii-automatic-duration-entities","title":"ii. Automatic Duration Entities","text":"<p>Automatic duration objects are objects that are created at a certain time during the program's execution, remain active for a certain period, and then cease to exist\u2014that is, their lifespan ends. The lifespan of such objects is shorter than the program's total runtime.</p> <p>Local variables have automatic duration. They are created when the execution of the block in which they are defined starts during program runtime, and they are destroyed when the execution of the block ends, meaning their lifespan terminates. </p><pre><code>void func(int a, int b)\n{\n    int result;\n    /***/\n}\n</code></pre> A local variable named <code>result</code> is defined within the main block of the <code>func</code> function above. The <code>result</code> variable is created when the <code>func</code> function's code is entered during program execution. When the program flow exits the <code>func</code> function, the lifespan of the <code>result</code> variable ends. <p>There is also a difference between static duration variables and automatic duration variables in terms of initialization. Global variables, which have static duration, can be initialized just like local variables.</p> <p>A local variable that has not been initialized or assigned a value contains a garbage value. This value is the value formed by the 1s and 0s currently present in the memory location allocated for that variable.</p> <p>It is guaranteed that static duration variables that are not initialized will be initialized to a value of 0. Global variables that are not initialized or assigned a value always contain the value 0. That is, these variables are initialized to 0 with the help of code generated by the compiler.</p> <p>Compile and run the following program: </p><pre><code>#include &lt;stdio.h&gt;\nint g;\nint main()\n{\n    int y;\n    printf(\"g = %d\\n\", g);\n    printf(\"y = %d\\n\", y);\n    return 0; // Note: 'return 0;' should be inside 'main' block.\n}\n</code></pre> <p>Using a local variable without initializing it or assigning a value to it is a programming error. Almost all compilers issue a logical warning message in such cases.</p> <p>[There is no such strict requirement in C++.]</p> <p>Global variables can only be initialized with constant expressions. Variables or function call expressions cannot be used in the expression (initializer) used to initialize global variables. The expression must consist only of constants.</p> <p>[Initializing global variables with non-constant expressions is valid in C++. Most modern C compilers also tend to consider the code valid when global variables are initialized with non-constant expressions. For portability, we advise against this practice.]</p> <p>However, there is no such restriction on initializing local variables. </p><pre><code>#include &lt;stdio.h&gt;\nint func(void);\nint x = 5;\n// int y = x + 5; /* Invalid */\n// int z = func(); /* Invalid */\n\nint main()\n{\n    // Assume 'b' is accessible, or defined elsewhere for this example to work.\n    // int a = b; \n    // int k = b - 2;\n    int m = func();\n    /***/\n}\n// In the program above, the definitions of variables a, k, m within the main function are valid (assuming b and func() are defined/accessible).\n</code></pre>"},{"location":"c/10_scope_and_lifetime/#iii-dynamic-duration-entities","title":"iii. Dynamic Duration Entities","text":"<p>Objects whose memory locations are allocated using dynamic memory functions have dynamic duration. You will see objects created with dynamic memory functions later.</p>"},{"location":"c/10_scope_and_lifetime/#comparison-of-global-and-local-variables","title":"Comparison of Global and Local Variables","text":"<p>When a variable is needed in a program, using a global or local variable may bring some advantages or disadvantages. However, some drawbacks of global variables can be discussed in general. Unless there is a special situation, local variables should be preferred over global variables, and global variables should only be used when necessary. Global variables can cause the following disadvantages:</p> <ol> <li>Since global variables have static duration, they remain in memory until the end of the program. This leads to less efficient use of memory.</li> <li>Since global variables are shared by all functions, source files that use global variables heavily are harder to read.</li> <li>In a source file that frequently uses global variables, the cost of bug hunting is higher. If there is a bug related to a global variable, all functions must be searched to find this bug. The ability of all functions to access global variables also creates the risk that a function might accidentally modify a global variable.</li> <li>Modifying a source file that uses global variables also requires more effort. Different parts of the source code become tightly coupled through the use of global variables. In this case, making a change in one place in the source code may require making changes in other places as well.</li> <li>Most programmers want to use global variables as little as possible. This is because functions that use global variables cannot be easily reused in other projects. The same global variables must be defined in the projects where they are used. Therefore, the reusability of functions written based on global variables decreases.</li> <li>Global variables pollute the global namespace. This point will be revisited when the concept of \"linkage\" is discussed later.</li> </ol>"},{"location":"c/10_scope_and_lifetime/#objects-holding-function-return-values","title":"Objects Holding Function Return Values","text":"<p>Functions convey their return values to the calling functions with the help of a temporary object. Examine the following program: </p><pre><code>#include &lt;stdio.h&gt;\nint add(int x, int y)\n{\n    return x + y;\n}\nint main()\n{\n    int a, b, sum;\n    printf(\"Enter two numbers: \");\n    scanf(\"%d%d\", &amp;a, &amp;b);\n    sum = add(a, b);\n    printf(\"sum = %d\\n\", sum);\n    return 0;\n}\n</code></pre> <p>The return type of a function actually means the type of the temporary object that will carry the function's return value. You can see the <code>add</code> function defined above is called from within the <code>main</code> function. When the program flow reaches the <code>return</code> statement within the <code>add</code> function, a temporary object is created. This temporary object is initialized with the <code>return</code> expression. That is, the <code>return</code> expression is actually the expression that initializes the temporary object created. A call to a function that produces a return value represents the temporary object holding that function's return value. So, how long is the lifespan of this temporary object? This object is created by the <code>return</code> statement and is destroyed when the evaluation of the expression containing the function call ends. Thus, after the execution of the statement: </p><pre><code>sum = add(a, b);\n</code></pre> within the <code>main</code> function in the example, the lifespan of the temporary object also ends."},{"location":"c/11_control_statements/","title":"Control Statements","text":""},{"location":"c/11_control_statements/#control-statements","title":"Control Statements","text":"<p>You know that the sentences of a program written in the C language are called statements.</p> <p>Some statements only provide information to the compiler program. These statements do not cause the compiler to generate executing code. Such statements are called \"declaration statements.\"</p> <p>Some statements cause the compiler to generate executing code. Such statements are called \"executable statements.\"</p> <p>Executable statements can also be divided into different groups:</p>"},{"location":"c/11_control_statements/#simple-statement","title":"Simple Statement:","text":"<p>Statements formed by an expression terminated with a terminating token (semicolon) are called simple statements: </p><pre><code>x = 10;\ny++;\nfunc();\n</code></pre> Three separate simple statements are written above."},{"location":"c/11_control_statements/#null-statement","title":"Null Statement:","text":"<p>In the C language, a solitary terminating token (semicolon) <code>;</code> constitutes a statement by itself. This statement is called the null statement. An empty block also constitutes a null statement: </p><pre><code>;\n{}\n</code></pre> <p>Both statements above are null statements.</p>"},{"location":"c/11_control_statements/#compound-statement","title":"Compound Statement:","text":"<p>A structure formed by one or more statements enclosed within a block is called a compound statement. A compound statement is shown below: </p><pre><code>    {\n        x = 10;\n        y++;\n        func();\n    }\n</code></pre>"},{"location":"c/11_control_statements/#control-statement","title":"Control Statement:","text":"<p>Control statements are statements that can change the flow of execution of a program. With control statements, the program's flow can be directed to different points. They conform to certain predefined syntactic rules of the C language and contain at least one keyword within their own syntax. The following control statements exist in the C language:</p> <ul> <li><code>if</code> statement</li> <li><code>while</code> loop statement</li> <li><code>do while</code> loop statement</li> <li><code>for</code> loop statement</li> <li><code>break</code> statement</li> <li><code>continue</code> statement</li> <li><code>switch</code> statement</li> <li><code>goto</code> statement</li> <li><code>return</code> statement</li> </ul>"},{"location":"c/12_if_statement/","title":"If Statement","text":""},{"location":"c/12_if_statement/#the-if-statement","title":"The <code>if</code> Statement","text":"<p>The most important statement for controlling program flow in the C language is the <code>if</code> statement.</p> <p>In its simplest form, the general syntax of the <code>if</code> statement is as follows: </p><pre><code>if (expression)\n    statement;\n</code></pre> The expression inside the <code>if</code> parenthesis is called the conditional expression. <p>The statement following the <code>if</code> parenthesis is called the true path of the <code>if</code> statement.</p> <p>The statement that forms the true path of the <code>if</code> statement can be a simple statement, a null statement, a compound statement, or another control statement.</p> <p>The execution of the simple <code>if</code> statement is as follows: First, the numerical value of the conditional expression is calculated. The calculated numerical value is interpreted as logical TRUE or FALSE. If the calculated value of the conditional expression is 0, it is interpreted as false; if it is any non-zero value, it is interpreted as true. For example, let's assume the calculated value of the conditional expression is \\(-5\\). In this case, the control expression is evaluated as true. If the expression is interpreted as TRUE, the true path of the <code>if</code> statement is executed; if the expression is interpreted as FALSE, the true path is not executed. The simple <code>if</code> statement is based on the execution or non-execution of a statement according to the truth or falsity of an expression.</p> <p>Compile and run the following program: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int x;\n    printf(\"enter a number : \");\n    scanf(\"%d\", &amp;x);\n    if (x &gt; 10)\n        printf(\"the true path of the if statement!\\n\");\n}\nreturn 0;\n</code></pre> <p>With the <code>if</code> statement written in the <code>main</code> function, the <code>printf</code> call is executed if the integer entered from the keyboard is greater than 10; otherwise, it is not executed.</p>"},{"location":"c/12_if_statement/#the-if-statement-with-a-false-path-if-else","title":"The <code>if</code> Statement with a False Path (<code>if-else</code>)","text":"<p>The <code>if</code> control statement can also include the <code>else</code> keyword. Such an <code>if</code> statement is called an <code>if</code> statement with a false path. The general form of the <code>if</code> statement with a false path is as follows: </p><pre><code>if (expression)\n    statement1;\nelse\n    statement2;\n</code></pre> <p>This time you see the <code>else</code> keyword after the statement following the true path of the <code>if</code> statement, followed by another statement. The <code>statement2</code> in the general form is called the false path of the <code>if</code> statement.</p> <p>The conditional expression of the <code>if</code> statement is interpreted as logically TRUE or FALSE. This time, if the conditional expression is TRUE, <code>statement1</code> is executed; if it is interpreted as FALSE, <code>statement2</code> is executed. The <code>if</code> statement with a false path aims at executing one of two separate statements depending on whether a conditional expression is true or false. That is, if the expression is true, one task is performed; if false, another task is performed.</p> <p>Examine the following example: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    char ch;\n    printf(\"enter a character : \");\n    ch = getchar();\n    if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z')\n        printf(\"%c is a lowercase letter!\\n\", ch);\n    else\n        printf(\"%c is not a lowercase letter!\\n\", ch);\n}\nreturn 0;\n</code></pre> <p>In the <code>main</code> function above, a character is retrieved from the keyboard using the standard <code>getchar</code> function. The sequence number of the retrieved character is assigned to the variable named <code>ch</code>. Information on whether the character entered from the keyboard is a lowercase letter is printed to the screen, depending on whether the conditional expression is true or false. Let's look at the conditional expression: </p><pre><code>ch &gt;= 'a' &amp;&amp; ch &lt;= 'z'\n</code></pre> For this expression to be true, both terms of the \"logical AND (<code>&amp;&amp;</code>)\" operator must be true. This is only possible if the character <code>ch</code> is a lowercase letter character. <p>The true and/or false path of an <code>if</code> statement can be a compound statement (a block). In this case, more than one simple statement can be executed depending on whether the conditional expression is true or false. Examine the following example: </p><pre><code>/***/\nif (x &gt; 0) {\n    y = x * 2 + 3;\n    z = func(y);\n    result = z + x;\n}\nelse {\n    y = x * 5 - 2;\n    z = func(y - 2);\n    result = z + x - y;\n}\n/***/\n</code></pre> <p>In the <code>if</code> statement above, the value of the <code>result</code> variable is calculated by different operations depending on whether the expression \\(x &gt; 0\\) is true or false. Both the true and false paths of the <code>if</code> statement are formed by compound statements.</p> <p>An <code>if</code> statement does not have to have a false path. However, an <code>if</code> statement cannot have only an <code>else</code> part. In this case, a null statement or an empty compound statement must be placed in the true path of the <code>if</code> statement: </p><pre><code>    if (expression)\n        ;\n    else\n        statement1;\n</code></pre> or <pre><code>    if (expression)\n    { }\n    else\n        statement1;\n</code></pre> An <code>if</code> statement that only has a false path, with an empty true path, is not a good option in terms of readability. In such cases, a better technique is to take the logical inverse of the conditional expression and eliminate the false path of the <code>if</code> statement: <pre><code>if (!expression)\n    statement1;\n</code></pre> Examine the following code snippet: <pre><code>/***/\nif (x &gt; 5)\n    ;\nelse {\n    func1(x);\n    func2(x);\n}\n/***/\n</code></pre> <p>In the <code>if</code> statement above, if the value of the variable \\(x\\) is greater than 5, nothing is done; otherwise, the functions <code>func1</code> and <code>func2</code> are called with the value of the variable \\(x\\). If the conditional expression is inverted and the <code>if</code> statement is rewritten: </p><pre><code>/***/\nif (x &lt;= 5) {\n    func1(x);\n    func2(x);\n}\n/***/\n</code></pre> <p>Any expression conforming to the definition of an expression can be found inside the <code>if</code> parenthesis: </p><pre><code>if (10)\n    statement1;\nif (-1)\n    statement2;\n</code></pre> <p>The value of the conditional expressions above is always interpreted as true, because the expressions have a non-zero value.</p> <p>The following conditional expression, however, will always be interpreted as false, so the true path of the <code>if</code> statement will never be executed: </p><pre><code>if (0)\n    statement1;\n</code></pre> <p>In the following <code>if</code> statement, <code>statement1</code> and <code>statement2</code> are executed depending on whether the value of the variable \\(x\\) is non-zero or zero: </p><pre><code>if (x) {\n    statement1;\n    statement2;\n    /***/\n}\n</code></pre> The structure above is equivalent to the following structure: <pre><code>if (x != 0) {\n    statement1;\n    statement2;\n}\n</code></pre> <p>Examine the following example: </p><pre><code>if (!x) {\n    statement1;\n    statement2;\n}\n</code></pre> <p>In this <code>if</code> statement, <code>statement1</code> and <code>statement2</code> are executed only if the value of the variable \\(x\\) is 0.</p> <p>Again, the structure above is equivalent to the following structure: </p><pre><code>    if (x == 0) {\n        statement1;\n        statement2;\n    }\n</code></pre>"},{"location":"c/12_if_statement/#using-the-assignment-operator-in-the-conditional-expression","title":"Using the Assignment Operator in the Conditional Expression","text":"<p>The assignment operator is often used in the conditional expression of the <code>if</code> statement. Thus, the value produced by the assignment operator is utilized. Examine the following code snippet: </p><pre><code>    if ((x = getval()) &gt; 5)\n        func1(x);\n    else\n        func2(x);\n</code></pre> <p>In the conditional expression of the <code>if</code> statement, the return value of the called <code>getval</code> function is assigned to the variable \\(x\\). Recall that the value produced by the assignment operator is the value assigned to the object. You see that the expression formed by the assignment operator is enclosed in parentheses. In this case, the return value of the <code>getval</code> function is both assigned to the variable \\(x\\) and checked whether it is greater than 5. If parentheses had not been used, the value 0 or 1 would have been assigned to \\(x\\) depending on whether the return value of the <code>getval</code> function was greater than 5. In that case, either the <code>func1</code> function would be called with the value 1 or the <code>func2</code> function would be called with the value 0. The statement could have been written as follows, couldn't it? </p><pre><code>x = getval();\nif (x &gt; 5)\n    func1(x);\nelse\n    func2(x);\n</code></pre> <p>However, the idiomatic code provides convenience in writing more complex statements. Consider how the following <code>if</code> statement will be executed. Recall that the pre-evaluation, or \"short-circuiting,\" behavior of the first part of the \"logical AND\" operator is guaranteed. </p><pre><code>    if ((y = getval()) &gt; 5 &amp;&amp; isprime(x))\n        func1(y);\n    func2(y);\n</code></pre>"},{"location":"c/12_if_statement/#nested-if-statements","title":"Nested <code>if</code> Statements","text":"<p>The true or false path of an <code>if</code> statement can also be another <code>if</code> statement: </p><pre><code>if (expression1)\n    if (expression2) {\n        statement1;\n        statement2;\n        statement3;\n    }\n    statement4;\n</code></pre> <p>In this example, the second <code>if</code> statement forms the true path of the first <code>if</code> statement. The first and second <code>if</code> statements do not have false paths.</p> <p>In nested <code>if</code> statements, the <code>else</code> keyword that follows the last <code>if</code> keyword belongs to the innermost <code>if</code> statement: </p><pre><code>    if (expression1)\n        if (expression2)\n            statement1;\n        else\n            statement2;\n</code></pre> In the example above, even though the visual formatting might suggest the <code>else</code> part belongs to the first <code>if</code> statement, the <code>else</code> part belongs to the second, innermost <code>if</code> statement (dangling else). <p>If it is desired that the <code>else</code> keyword belongs to the first <code>if</code> statement, the true path of the first <code>if</code> statement must be blocked (enclosed in braces): </p><pre><code>if (expression1) {\n    if (expression2)\n        statement1;\n}\nelse\n    statement2;\n</code></pre> In the example above, the <code>else</code> part belongs to the first <code>if</code> statement. <pre><code>if (expression1) {\n    if (expression2)\n        statement1;\n    else {\n        statement2;\n        statement3;\n    }\n    statement4;\n}\nelse\n    statement5;\n</code></pre> In the example above, since the true path of the first <code>if</code> statement consists of more than one statement\u2014one of which is another <code>if</code> statement\u2014blocking (braces) is used. <code>statement5</code> forms the false path of the first <code>if</code> statement."},{"location":"c/12_if_statement/#the-else-if-ladder","title":"The <code>else if</code> Ladder","text":"<p>Examine the following <code>if</code> statements:</p> <p>If the other comparisons are not true when a comparison results in true, such comparisons are called disjoint comparisons. In disjoint comparisons, using separate <code>if</code> statements is poor technique: </p><pre><code>if (m == 1)\n    printf(\"January\\n\");\nif (m == 2)\n    printf(\"February\\n\");\nif (m == 3)\n    printf(\"March\\n\");\n/***/\nif (m == 12)\n    printf(\"December\\n\");\n</code></pre> In the example above, suppose the value of the variable \\(m\\) is 1. In this case, the text \"January\" is printed to the screen. However, the subsequent <code>if</code> statements separately test whether the variable \\(m\\) is equal to 2, 3, ... 12 in turn. But since the variable \\(x\\) has the value 1, it is clear that the control expressions within all other <code>if</code> statements will be evaluated as false. In this case, all <code>if</code> statements after the first <code>if</code> statement are unnecessarily executed. At the same time, the readability of the code is also impaired. <p>In disjoint comparisons, <code>else if</code> ladders should be used: </p><pre><code>if (expression1)\n    statement1;\nelse\n    if (expression2)\n        statement2;\n    else\n        if (expression3)\n            statement3;\n        else\n            if (expression4)\n                statement4;\n            else\n                statement5;\n</code></pre> In this structure, if the conditional expression of any <code>if</code> statement is evaluated as true, the program flow never proceeds to another <code>if</code> statement. This structure is called an else if ladder (cascaded if). Since writing the <code>else if</code> ladder in the form above impairs readability, especially in long <code>else if</code> ladders, the following writing style should be preferred for readability: <pre><code>if (expression1)\n    statement1;\nelse if (expression2)\n    statement2;\nelse if (expression3)\n    statement3;\nelse if (expression4)\n    statement4;\nelse\n    statement5;\n</code></pre> The false path of the <code>if</code> statement at the very end of the ladder has a special importance. In the example above, <code>statement5</code> is in the <code>else</code> part of the last <code>if</code> statement. If the conditional expression of none of the <code>if</code> statements in the ladder is true, the false path of the last <code>if</code> statement is executed, right? As a result of the execution of the ladder above, one of <code>statement1</code>, <code>statement2</code>, <code>statement3</code>, <code>statement4</code>, or <code>statement5</code> is definitely executed. <p>An <code>else if</code> ladder without a false path for the last <code>if</code> statement can be exited without any action being performed.</p> <p>In terms of both readability and efficiency, conditions with higher probability or frequency in the <code>else if</code> ladder should be placed higher up.</p>"},{"location":"c/12_if_statement/#common-mistakes","title":"Common Mistakes","text":"<p>One common mistake, especially made by C beginners, is confusing the simple <code>if</code> statement with the <code>if</code> statement with a false path. That is, the false path of the <code>if</code> statement is forgotten: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int x;\n    printf(\"enter a number: \");\n    scanf(\"%d\", &amp;x);\n    if (x % 2 == 0)\n        printf(\"%d is an even number!\\n\", x);\n    printf(\"%d is an odd number!\\n\", x);\n}\nreturn 0;\n</code></pre> If the expression inside the <code>if</code> parenthesis is false, there is no error. But what is printed to the screen if the expression is true? Suppose the value 28 is entered from the keyboard: <pre><code>28 is an even number!\n28 is an odd number!\n</code></pre> <p>Perhaps the most common mistake is accidentally placing the terminating token (<code>;</code>) at the end of the <code>if</code> parenthesis. Examine the following <code>main</code> function: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int x;\n    printf(\"enter a number: \");\n    scanf(\"%d\", &amp;x);\n    if (x % 2 == 0);\n        printf(\"%d is an even number!\\n\", x);\n}\nreturn 0;\n</code></pre> In the <code>main</code> function above, the <code>printf</code> function is called regardless of whether the expression \\(x \\% 2 == 0\\) is true or false. The <code>printf</code> call is outside the <code>if</code> statement. It is absolutely compliant with the syntax rules for a null statement to form the true path of the <code>if</code> statement. The written <code>if</code> statement actually means \"do nothing if x is even.\" Most compilers do not issue a logical warning message for this situation, which is unlikely to be written consciously. <p>If the same mistake were made in the true path of an <code>if</code> statement with a false path, a syntax error would occur, right? </p><pre><code>if (x &gt; 5);\n    printf(\"true!\\n\");\nelse\n    printf(\"false\\n\");\n</code></pre> You know that the <code>else</code> keyword must be used in conjunction with an <code>if</code> statement. The <code>if</code> statement in the code snippet above is an <code>if</code> statement whose true path means \"do nothing.\" Therefore, the <code>else</code> keyword is not attached to any <code>if</code> statement. This is a syntax error, because there cannot be an <code>else</code> that is not attached to an <code>if</code> statement. <p>Of course, a null statement can form the true or false path of an <code>if</code> statement. In this case, for readability, writing this null statement indented one tab gives a strong impression that the null statement was placed consciously. </p><pre><code>if ((val = getval()) != 0)\n    ;\n</code></pre> Another frequent mistake is using the assignment operator (<code>=</code>) instead of the comparison operator (<code>==</code>) inside the <code>if</code> parenthesis. <pre><code>/***/\nif (x == 5)\n    printf(\"equal\\n\");\n/***/\n</code></pre> In the <code>if</code> statement above, the <code>printf</code> function is called if the value of the variable \\(x\\) is equal to 5. The comparison operator has no side effect. That is, the value of the variable \\(x\\) is only compared with the constant 5 inside the <code>if</code> parenthesis above; it is not changed. However, if the assignment operator is accidentally used instead of the comparison operator: <pre><code>/***/\nif (x = 5)\n    printf(\"equal\\n\");\n/***/\n</code></pre> The assignment operator produces the value of the expression on its right side. The value of the expression inside the <code>if</code> parenthesis is calculated as 5. Since 5 is a non-zero value, the <code>printf</code> function is called regardless of the value of the variable \\(x\\). Since the assignment operator has a side effect, the value 5 is also assigned to the variable \\(x\\) upon execution of the <code>if</code> statement. <p>Most C compilers view the situation with suspicion and issue a logical warning message if the expression inside the <code>if</code> parenthesis is a simple assignment expression. For example, a typical warning message in Borland compilers is:</p> <pre><code>warning : possibly incorrect assignment!\n</code></pre> <p>However, the assignment operator can also be used consciously inside the <code>if</code> parenthesis: </p><pre><code>    if (x = func())\n        m = 20;\n</code></pre> In conscious use, the expression can be structured as follows to suppress the compiler's logical warning message: <pre><code>    if ((x = func()) != 0)\n        m = 20;\n</code></pre> As in the example above, if the value produced by the assignment operator is explicitly made a term in a comparison operation, compilers do not issue a \"logical warning\" message in this case. <p>Another common mistake is forgetting to block the true or false path of the <code>if</code> statement. That is, a simple statement is accidentally written instead of a compound statement. </p><pre><code>    if (x == 10)\n        m = 12;\n    k = 15;\n</code></pre> In the <code>if</code> statement above, only the statement: <pre><code>m = 12;\n</code></pre> <p>forms the true path of the <code>if</code> statement.</p> <pre><code>k = 15;\n</code></pre> <p>is outside the <code>if</code> statement. This situation usually occurs because the programmer first creates the true or false path of the <code>if</code> statement with a simple statement, and then forgets to block when adding a second simple statement to the true or false path.</p> <p>It is also clear from the writing style of the code that the true path of the <code>if</code> statement was accidentally not blocked. The correct way should have been: </p><pre><code>    if (x == 10) {\n        m = 12;\n        k = 15;\n    }\n</code></pre> The following <code>if</code> statement is invalid because it again uses an <code>else</code> keyword that is not matched with an <code>if</code> keyword: <pre><code>    if ( x == 10)\n        m = 12;\n    k = 15;\n    else /* Invalid */\n        y = 20;\n</code></pre> Because you know that an <code>else</code> must be attached to an <code>if</code> statement. <p>To avoid such mistakes, some programmers write the simple statement as a compound statement, even if the true or false path of the <code>if</code> statement consists of a simple statement: </p><pre><code>    if (x &gt; 10) {\n        y = 12;\n    }\n    else {\n        k = 5;\n    }\n</code></pre> In the example above, no syntax error or mistake occurs if another simple statement is added to the true or false path of the <code>if</code> statement. However, avoiding unnecessary blocking is better for readability. <p>Consider the case where it is desired to test if a value is within a certain range inside the <code>if</code> parenthesis: </p><pre><code>    if (10 &lt; x &lt; 20)\n        func();\n</code></pre> In the <code>if</code> statement above, it is intended to call the <code>func</code> function if the variable \\(x\\) is between the values 10 and 20. However, the expression inside the <code>if</code> parenthesis is always true. That is, the <code>func</code> function call is always executed. Since the less-than operator (<code>&lt;</code>) has left-to-right associativity, the leftmost less-than operator is evaluated first. You know that the value produced by the operator is 1 or 0. The produced value of 1 or 0 becomes the operand of the rightmost less-than operator. Since the value 20 is greater than 1 or 0, the expression is always true. <p>Another dangerous mistake is forgetting the function call operator (parentheses) when the expression inside the <code>if</code> parenthesis is a function call expression:</p> <p>Instead of: </p><pre><code>    if (func())\n        m = 12;\n</code></pre> Suppose: <pre><code>    if (func)\n        m = 12;\n</code></pre> is written. This does not result in a syntax error. In this case, the true path of the <code>if</code> statement is always executed. In the C language, a function name is treated as an address information equivalent to the function's code location in memory. Since this address information is always a non-zero value, the conditional expression is always evaluated as true."},{"location":"c/12_if_statement/#testing-functions-predicate-functions","title":"Testing Functions (Predicate Functions)","text":"<p>Since the <code>bool</code> data type is not one of C's native data types (historically), testing functions, i.e., functions that answer a question, written in the C language often return the <code>int</code> type.</p> <p>[The <code>bool</code> type was also added as a native data type with C99 standards. According to C99 standards, the <code>_Bool</code> keyword was added to the C language.]</p> <p>For example, let's assume a function is written to test whether an integer is a prime number. The function's signature would be: </p><pre><code>    int isprime(int val);\n</code></pre> The widely used convention for the return values of testing functions is as follows: If the function answers the question posed as true or positive, it returns any non-zero value. If the result of the question or test is negative or false, the function returns the value 0. This simplifies the job of the code snippet calling the testing function, allowing idiomatic code to be written like this: <p>If a task is to be performed when the test result is positive: </p><pre><code>    if (isprime(val))\n        statement;\n</code></pre> If a task is to be performed when the test result is negative: <pre><code>    if (!isprime(val))\n        statement;\n</code></pre> can be written. <p>Examine the following program: </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;ctype.h&gt;\nint main()\n{\n    int ch;\n    printf(\"enter a character : \");\n    ch = getchar();\n    if (isupper(ch))\n        printf(\"%c is an uppercase letter!\\n\", ch);\n    else\n        printf(\"%c is not an uppercase letter!\\n\", ch);\n}\nreturn 0;\n</code></pre> <code>isupper</code> is a standard function that tests whether the character whose code number is passed to it is an uppercase letter character. If the character whose code number is passed is an uppercase letter, the function returns a non-zero value. If it is not an uppercase letter, the function's return value is 0. In this case, the conditional expression of the <code>if</code> statement in the <code>main</code> function means \"if ch is an uppercase letter,\" right? If the conditional expression were written as: <pre><code>    if (!isupper(ch))\n</code></pre> this would mean \"if ch is not an uppercase letter.\" <p>Below, a function named <code>isleap</code> is defined, which tests whether a year is a leap year. Years that are exactly divisible by 4, but not by 100, or that are exactly divisible by 400, are leap years: </p><pre><code>#include &lt;stdio.h&gt;\nint isleap(int y)\n{\n    return y % 4 == 0 &amp;&amp; (y % 100 != 0 || y % 400 == 0);\n}\nint main()\n{\n    int year;\n    printf(\"enter a year: \");\n    scanf(\"%d\", &amp;year);\n    if (isleap(year))\n        printf(\"%d is a leap year!\\n\", year);\n    else\n        printf(\"%d is not a leap year!\\n\", year);\n    return 0;\n}\n</code></pre>"},{"location":"c/12_if_statement/#standard-character-testing-functions","title":"Standard Character Testing Functions","text":"<p>Character testing functions are functions that allow information about characters to be obtained. In most compilers, these functions are also defined as macros within the <code>ctype.h</code> header file. Therefore, the <code>ctype.h</code> file must be included in the source code before character testing functions are called. Character testing functions are valid for the first half of the ASCII character set. That is, their return values are not reliable when used for Turkish characters. Correctly running character testing functions for Turkish-specific characters (<code>\u00e7</code>, <code>\u011f</code>, <code>\u0131</code>, <code>\u00f6</code>, <code>\u015f</code>, <code>\u00fc</code>, <code>\u00c7</code>, <code>\u011e</code>, <code>I</code>, <code>\u00d6</code>, <code>\u015e</code>, <code>\u00dc</code>) is a matter of localization. This topic will be addressed in later sections.</p> <p>Below is a table listing the standard character testing functions:</p> Function Return Value <code>isalpha</code> True if an alphabetic character, false otherwise. <code>isupper</code> True if an uppercase letter, false otherwise. <code>islower</code> True if a lowercase letter, false otherwise. <code>isdigit</code> True if a digit character, false otherwise. <code>isxdigit</code> True if a character representing one of the hexadecimal digits (0123456789ABCDEFabcdef), false otherwise. <code>isalnum</code> True if an alphabetic or digit character, false otherwise. <code>isspace</code> True if one of the whitespace characters (space, carriage return, new line, vertical tab, form feed), false otherwise. <code>ispunct</code> True if one of the punctuation characters, i.e., a character outside of control characters, alphanumeric characters, and whitespace characters, false otherwise. <code>isprint</code> True if a printable character (including the space character), false otherwise. <code>isgraph</code> True if a visible character (excluding the space character), false otherwise. <code>iscntrl</code> True if a control character or delete character (first 32 characters of ASCII set or character number 127), false otherwise."},{"location":"c/12_if_statement/#islower-function","title":"<code>islower</code> Function","text":"<p><code>islower</code> is a standard function that tests whether the character whose code number is passed to it is a lowercase letter character. If the character is a lowercase letter, the function returns a non-zero value, i.e., a logical \"true\" value. If it is not a lowercase letter, the function's return value is zero. This function can be written as follows: </p><pre><code>#include &lt;stdio.h&gt;\nint islower (int ch)\n{\n    return ch &gt;= 'a' &amp;&amp; ch &lt;= 'z';\n}\nint main()\n{\n    char ch;\n    printf(\"enter a character: \");\n    ch = getchar();\n    if (islower(ch))\n        printf(\"lowercase letter\\n\");\n    else\n        printf(\"not a lowercase letter\\n\");\n    return 0;\n}\n</code></pre> <p>In the <code>islower</code> function written above, it is first tested whether the parameter variable is a lowercase letter: </p><pre><code>    ch &gt;= 'a' &amp;&amp; ch &lt;= 'z';\n</code></pre> In a character code where lowercase letters are placed consecutively, the value of the expression above is true only if the value of the variable <code>ch</code> is the sequence number of a lowercase letter."},{"location":"c/12_if_statement/#isalpha-function","title":"<code>isalpha</code> Function","text":"<p><code>isalpha</code> is also a standard function. If the character whose code number is passed to its parameter is an alphabetic character, i.e., an uppercase or lowercase letter, the function returns a non-zero value; if it is not an alphabetic character, it returns a zero value. </p><pre><code>    int isalpha (int ch)\n    {\n        return (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') || (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z');\n    }\n</code></pre>"},{"location":"c/12_if_statement/#isdigit-function","title":"<code>isdigit</code> Function","text":"<p><code>isdigit</code> is a standard function. If the character whose code number is passed to its parameter is a digit character, the function returns a non-zero value; if it is not a digit character, it returns a zero value: </p><pre><code>    int isdigit (int ch)\n    {\n        return (ch &gt;= '0' &amp;&amp; ch &lt;= '9');\n    }\n</code></pre>"},{"location":"c/12_if_statement/#isalnum-function","title":"<code>isalnum</code> Function","text":"<p><code>isalnum</code> is also a standard function. If the character whose code number is passed to its parameter is an alphabetic character or a digit character, it returns a non-zero value; otherwise, it returns a zero value. This function is written in two separate forms below: </p><pre><code>#include &lt;ctype.h&gt;\nint isalnum1(int ch)\n{\n    return ch &gt;= 'a' &amp;&amp; ch &lt;= 'z' || ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z'\n        || ch &gt;= '0' &amp;&amp; ch &lt;= '9';\n}\nint isalnum2(int ch)\n{\n    return isalpha(ch) || isdigit(ch);\n}\n</code></pre>"},{"location":"c/12_if_statement/#isxdigit-function","title":"<code>isxdigit</code> Function","text":"<p><code>isxdigit</code> is a standard function that tests whether a character is a symbol for a digit in the hexadecimal number system. If the character is one of <code>0123456789ABCDEFabcdef</code>, the function returns a non-zero value; if it is not one of these characters, it returns a zero value. </p><pre><code>int isxdigit (int ch)\n{\n    return ch &gt;= '0' &amp;&amp; ch &lt;= '9' || ch &gt;= 'A' &amp;&amp; ch &lt;= 'F'\n        || ch &gt;= 'a' &amp;&amp; ch &lt;= 'f';\n}\n</code></pre>"},{"location":"c/12_if_statement/#standard-character-conversion-functions","title":"Standard Character Conversion Functions","text":"<p>Converting from lowercase to uppercase or from uppercase to lowercase is a frequently needed operation. The standard <code>toupper</code> and <code>tolower</code> functions are used for this purpose.</p>"},{"location":"c/12_if_statement/#tolower-function","title":"<code>tolower</code> Function","text":"<p><code>tolower</code> is a standard C function. If the character whose code number is passed to its parameter is an uppercase letter, it returns the code number of its lowercase counterpart. If the code number of a non-uppercase character is passed to the <code>tolower</code> function, the function returns the same value. This function is defined below: </p><pre><code>#include &lt;stdio.h&gt;\nint tolower (int ch)\n{\n    if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z')\n        return ch - 'A' + 'a';\n    return ch;\n}\nint main()\n{\n    char ch;\n    printf(\"enter a character :\");\n    ch = getchar();\n    printf(\"%c\\n\", tolower(ch));\n}\nreturn 0;\n</code></pre>"},{"location":"c/12_if_statement/#toupper-function","title":"<code>toupper</code> Function","text":"<p><code>toupper</code> is a standard C function. If the character whose sequence number is passed to its parameter is a lowercase letter, it returns the sequence number of its uppercase counterpart. If the sequence number of a non-lowercase character is passed to the <code>toupper</code> function, the function returns the same value. The function is defined below: </p><pre><code>int toupper(int ch)\n{\n    if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z')\n        return ch - 'a' + 'A';\n    return ch;\n}\n</code></pre>"},{"location":"c/12_if_statement/#example","title":"Example","text":"<p>Below are the functions <code>get_max2</code>, which returns the larger of two numbers, and <code>get_max3</code>, which returns the largest of three numbers: </p><pre><code>int get_max2(int a, int b)\n{\n    if (a &gt; b)\n        return a;\n    return b;\n}\nint get_max3(int a, int b, int c)\n{\n    int max = a;\n    if (b &gt; max)\n        max = b;\n    if (c &gt; max)\n        max = c;\n    return max;\n}\n#include &lt;stdio.h&gt;\nint main()\n{\n    int x, y, z;\n    printf(\"enter two numbers : \");\n    scanf(\"%d%d\", &amp;x, &amp;y);\n    printf(\"the larger of %d and %d is = %d\\n\", x, y, get_max2(x, y));\n    printf(\"enter three numbers : \");\n    scanf(\"%d%d%d\", &amp;x, &amp;y, &amp;z);\n    printf(\"the largest of %d %d and %d is = %d\\n\",x, y, z,\n        get_max3(x, y, z));\n    return 0;\n}\n</code></pre> The following program defines a function named <code>get_hex_char</code>. The function returns the sequence number of the character symbol in the hexadecimal number system for an integer between 0 and 15 passed to it. <pre><code>#include &lt;stdio.h&gt;\nint get_hex_char(int number)\n{\n    if (number &gt;= 0 &amp;&amp; number &lt;= 9)\n        return ('0' + number);\n    if (number &gt;= 10 &amp;&amp; number &lt;= 15)\n        return ('A' + number - 10);\n    return -1;\n}\nint main()\n{\n    int number;\n    printf(\"enter a number between 0 and 15 : \");\n    scanf(\"%d\", &amp;number);\n    printf(\"%d = %c\\n\", number, get_hex_char(number));\n    return 0;\n}\n</code></pre> <p>The following program defines a function named <code>get_hex_val</code>. The function returns the value in the decimal number system of a hexadecimal digit symbol whose code number is passed to it. If the character passed to the function is not a hexadecimal character, the value -1 is returned. </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;ctype.h&gt;\nint get_hex_val(int ch)\n{\n    ch = toupper(ch);\n    if (isdigit(ch))\n        return ch - '0';\n    if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'F')\n        return ch - 'A' + 10;\n    return -1;\n}\nint main()\n{\n    char hex;\n    printf(\"enter a character showing a hex digit: \");\n    hex = getchar();\n    printf(\"%c = %d\\n\", hex, get_hex_val(hex));\n    return 0;\n}\n</code></pre> <p>The following program defines a function named <code>change_case</code>. If the character passed to the <code>change_case</code> function is a lowercase letter, it converts this character to an uppercase letter; if it is an uppercase letter, it converts the character to a lowercase letter. If it is not an alphabetic character, the function returns the character's own value. </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;ctype.h&gt;\nint change_case(int ch)\n{\n    if (isupper(ch))\n        return tolower(ch);\n    return toupper(ch);\n}\nint main()\n{\n    int c;\n    printf(\"enter a character : \");\n    c = getchar();\n    c = change_case(c);\n    putchar(c);\n    return 0;\n}\n</code></pre> <p>The following C program solves a quadratic equation whose coefficients are obtained from the keyboard: </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\nint main()\n{\n    double a, b, c;\n    double delta;\n    printf(\"enter the coefficients of the equation\\n\");\n    printf(\"a = \");\n    scanf(\"%lf\", &amp;a);\n    printf(\"b = \");\n    scanf(\"%lf\", &amp;b);\n    printf(\"c = \");\n    scanf(\"%lf\", &amp;c);\n    delta = b * b - 4 * a * c;\n    if (delta &lt; 0)\n        printf(\"your equation has no real root\\n\");\n    else if (delta == 0) {\n        printf(\"your equation has one real root\\n\");\n        printf(\"root = %lf\\n\", -b / (2 * a));\n    }\n    else {\n        double kokdelta = sqrt(delta);\n        printf(\"your equation has 2 real roots\\n\");\n        printf(\"root 1 = %lf\\n\", (-b + kokdelta) / (2 * a));\n        printf(\"root 2 = %lf\\n\", (-b - kokdelta) / (2 * a));\n    }\n    return 0;\n}\n</code></pre>"},{"location":"c/13_function_declarations/","title":"Function Declarations","text":""},{"location":"c/13_function_declarations/#function-declarations-prototypes","title":"Function Declarations (Prototypes)","text":"<p>The compilation process is performed by the compiler from top to bottom within the source code. During the compilation phase, when the compiler encounters a function call, it must know the return type of the called function. A function's return type determines which CPU register the return value will be retrieved from. Obtaining this information at compile time is essential for the program to run correctly.</p> <p>If the definition of the called function is placed before the calling function, the compiler already has information about the return type of the called function before it encounters the function call expression during the compilation process. This is because compilation is performed from top to bottom.</p> <p>Examine the following example: </p><pre><code>#include &lt;stdio.h&gt;\ndouble get_val(double x, double y)\n{\n    return x * y / (x + y);\n}\nint main()\n{\n    double d;\n    d = get_val(4.5, 7.3);\n    printf(\"d = %lf\\n\", d);\n    return 0;\n}\n</code></pre> In the example above, the <code>get_val</code> function is defined before the <code>main</code> function that calls it. Before reaching the call expression, the compiler already knows the return type of the <code>get_val</code> function. <p>If the definition of the called function is made after the calling function, the compiler cannot know the return type of the called function when it reaches the function call expression. This is a problematic situation: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    double d;\n    // The return type of the function is unknown.\n    d = get_val(4.5, 7.3);\n    printf(\"d = %lf\\n\", d);\n    return 0;\n}\ndouble get_val(double x, double y)\n{\n    return x * y / (x + y);\n}\n</code></pre> <p>Above, the <code>get_val</code> function is called within the <code>main</code> function. However, the definition of the <code>get_val</code> function is placed later in the source code than the <code>main</code> function. When the compiler encounters the call to the <code>get_val</code> function during compile time, it does not know the return type of this function.</p> <p>If a C compiler encounters a function call expression and has not yet obtained information about the function's return type, it assumes that the return value of the function in question is of type <code>int</code>.</p> <p>In the example above, the compiler assumes that the return value of the <code>get_val</code> function is of type <code>int</code> and generates code accordingly. Later, when the compilation flow reaches the function's definition, it sees that the function's return value is of type <code>double</code>. Compilers report this contradictory situation, which prevents target code generation, with an error message.</p> <p>[In C++, if the called function is not defined before the calling function, the function's return value is not assumed to be of type <code>int</code>. In this case, a function declaration is mandatory. A compile-time error occurs if this declaration is not made.]</p> <p>Defining the called function above the calling function is not always possible. Dozens of functions can be defined in a large source file. It may be the case that every defined function calls each other. In this case, it becomes very difficult to define the function to be called before the calling function. Furthermore, two functions can call each other in C. This corresponds to a recursive call mechanism. In such a function design, defining the called function first is no longer possible. </p><pre><code>double func1()\n{\n    /***/\n    func2();\n    /***/\n}\ndouble func2()\n{\n    /***/\n    func1();\n    /***/\n}\n</code></pre> <p>No matter which of the function definitions above is placed higher, a contradictory situation will still occur.</p> <p>Moreover, the definitions of the called functions often do not reside in the same source file. In this case, how does the compiler receive information about the called function?</p>"},{"location":"c/13_function_declarations/#what-is-a-function-declaration","title":"What is a Function Declaration?","text":"<p>A function declaration (or function prototype) is a statement that provides information about a function to the compiler. The compiler generates the code related to the function call based on the information it receives from here. Additionally, the compiler can perform some checks with this information. It prevents possible mistakes by generating error or warning messages as a result of these checks.</p>"},{"location":"c/13_function_declarations/#general-form-of-function-declarations","title":"General Form of Function Declarations","text":"<p>The general form of a function declaration is as follows:</p> <pre><code>[return_type] &lt;function_name&gt; ([type1], [type2].....);\n</code></pre> <p>For example, the declaration for the <code>get_val</code> function can be made in the following form: </p><pre><code>    double get_val(double, double);\n</code></pre> The compiler obtains the following information from such a declaration: <ol> <li>The return value of the <code>get_val</code> function is of type <code>double</code>. After this information, the compiler no longer assumes the return value to be of type <code>int</code> if this function is called; it generates code based on obtaining a <code>double</code> return value.</li> <li>The <code>get_val</code> function has two parameters. After this notification, the compiler has the opportunity to check whether this function is called with the correct number of arguments. If it sees that the function is called with the wrong number of arguments, it reports the situation with an error message.</li> <li>The parameters of the <code>get_val</code> function are of type <code>double</code>. After this information, the compiler applies automatic type conversion to the arguments if arguments of other types are sent to the function. This topic will be covered in the section named \"Automatic Type Conversion.\"</li> </ol> <p>Example declarations are given below: </p><pre><code>int multiply (int, int);\ndouble power (double, double);\nvoid clrscr(void);\n</code></pre> Just as in function definitions, if the function's return value is not specified in function declarations, the compiler assumes that the declaration is made for an <code>int</code> return value: <pre><code>    func(double);\n</code></pre> is completely equivalent to: <pre><code>    int func(double);\n</code></pre> However, it is better for readability to explicitly write the <code>int</code> keyword.  <p>[In C++, the return type must be written.]</p> <p>If the declared function does not produce a return value, the <code>void</code> keyword must be used: </p><pre><code>    void func(double);\n</code></pre> Function declarations only provide information to the compiler. This is not a definition operation. Therefore, the compiler does not allocate memory for the program's runtime as a result of the declaration."},{"location":"c/13_function_declarations/#omitting-parameter-types-in-a-declaration","title":"Omitting Parameter Types in a Declaration","text":"<p>Before the standardization process of C, the parameter parenthesis was often left empty in function declarations. No information was given about the types and number of the function's parameters in the declaration. The sole purpose of the declaration was to inform about the function's return value type. Therefore, a declaration like: </p><pre><code>    double func();\n</code></pre> did not mean that the <code>func</code> function had no parameters. With the addition made to function declarations during the standardization process, the possibility was given to provide information about the number and types of the function's parameters. However, this raised a problem. If code written according to old rules was compiled according to new rules, and a declaration like <code>double func();</code> was interpreted as the function having no parameters, a syntax error would occur if the declared function was called as, for example, <code>func(5)</code>. To ensure backward compatibility, a decision was made: If the function has no parameters, the <code>void</code> keyword must be written inside the parameter parenthesis in the declaration. Examine the following declarations: <pre><code>    double foo();\n    double func(void);\n</code></pre> According to the standards, the compiler concludes from the declaration of the <code>foo</code> function that no information has been given about the <code>foo</code> function's parameters, and when it encounters a function call, it does not check the number of arguments sent to the function. That is, a function declared this way can be called with the desired number of arguments in compliance with the rules. <p>From the declaration of the <code>func</code> function, the compiler concludes that the <code>func</code> function has no parameters, and if it encounters one or more arguments sent to the function when it encounters a function call, it determines this as a compile-time error.</p> <p>[In C++, both declarations are equivalent. That is, there is no difference between leaving the parameter parenthesis empty and writing the <code>void</code> keyword in a function declaration.]</p>"},{"location":"c/13_function_declarations/#writing-parameter-names-in-declarations","title":"Writing Parameter Names in Declarations","text":"<p>In function declarations, the names of the parameters can also be written after their types. The scopes of the parameter names included in declarations are limited only to the declaration's parameter parenthesis. Standards defined this situation with a separate scope rule. Names used inside the function declaration parenthesis are only known within that parenthesis. These names are not known when exiting this parenthesis. This scope rule is called the \"Function Prototype Scope\" rule.</p> <p>The parameter names written here are only useful for readability. There is no requirement for these parameter names to be the same as the parameter names used in the function's definition.</p> <p>Let's rewrite the declarations above by giving names to the parameters: </p><pre><code>    float calculate(float a, float b);\n    int multiply(int number1, int number2);\n    double pow(double base, double exp);\n</code></pre> Those who read only the function declarations without seeing the function definitions get an idea of what information these variables expect from function calls based on the parameter names used in the declarations."},{"location":"c/13_function_declarations/#location-of-function-declarations","title":"Location of Function Declarations","text":"<p>A function's declaration can be made anywhere in the program. If declarations are made at the global level, meaning outside all blocks, they remain valid within the area from where they are declared until the end of the file. The function's declaration must be made before the function in question is called.</p> <p>However, although rarely encountered in applications, function declarations can also be made at the local level. In this case, information is given only to the block where the declaration was made. In other words, a function declaration, like variable definitions, adheres to the scope rule.</p> <p>Generally, function declarations are made at the top of the program or inside one of the header files defined by the programmer. Header files will be discussed in detail later.</p>"},{"location":"c/13_function_declarations/#declarations-of-standard-c-functions","title":"Declarations of Standard C Functions","text":"<p>The declarations of standard C functions are placed inside standard header files. In applications, the programmer does not write the declaration of a standard C function himself; he includes the header file containing this declaration in his source code using the <code>#include</code> preprocessor command.</p>"},{"location":"c/13_function_declarations/#not-making-a-function-declaration","title":"Not Making a Function Declaration","text":"<p>There is no requirement for the source code of a called function to be in the same source file. When the compiler encounters a function call, it does not search for the source code of the called function. It writes information indicating that the relevant function has been called into the generated object file for the linker. Finding the compiled code of the called function and combining the object files appropriately is the job of the linker program.</p> <p>Suppose the definition of a called function is not in the same source file. What happens if the declaration of the called function is not made? In the C language, this is not a syntax error.</p> <p>[In C++, this situation is directly a syntax error. The compiler must see the definition or declaration of a function before the function in question is called.]</p> <p>In the C language, the compiler produces the object file by assuming the return value of an undeclared function is of type <code>int</code>. If the function's return value is not used in the source code, or if the return value of the called function is indeed of type <code>int</code>, no problem arises. However, if the function's return value is used and the return value is not of type <code>int</code>, a runtime error is in question. Compile and run the following example on your compiler: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    double d;\n    d = sqrt(9.); // sqrt is defined in math.h, but math.h is not included.\n    printf(\"d = %lf\\n\", d);\n    return 0;\n}\n</code></pre> <p>No error occurs during the compilation of the program above. However, the compiler generates code assuming the return value of the called <code>sqrt</code> function is of type <code>int</code>. In fact, the return value of the compiled <code>sqrt</code> function is of type <code>double</code>. During runtime, instead of the <code>double</code> value returned by the function, an <code>int</code> value is attempted to be pulled as a result of the code produced by the compiler. This is a program runtime error.</p> <p>Now, compile and run the program again by adding the following declaration before the <code>main</code> function: </p><pre><code>    double sqrt(double val);\n</code></pre> The declarations of standard C functions are in header files with the <code>.h</code> extension. By including the relevant header file in the source code with the <code>#include</code> preprocessor command, the standard C functions are actually declared. Indeed, when the source program, which is the output of the preprocessor program, is given to the compiler, the declaration of the function is found in this included file. Undoubtedly, instead of including the relevant header file in the source code, the declarations of standard C functions can also be made by the programmer. In this case, no error will occur either. In the example above, the declaration of the called <code>sqrt</code> function can be added to the source code in two ways: <p>i. By including the header file containing the function declaration in the source code with a preprocessor command: </p><pre><code>    #include &lt;math.h&gt;\n</code></pre> ii. The function's declaration can be written directly: <pre><code>    double sqrt(double val);\n</code></pre> However, the preferred method should be to include the header file in the source code. This is because the programmer might write the function's declaration incorrectly. <p>The reason for including header files in the source code is not only function declarations. Header files also contain other declarations: Macros, symbolic constants, type name declarations, structure declarations, etc.</p>"},{"location":"c/13_function_declarations/#function-declaration-and-argument-parameter-compatibility-check","title":"Function Declaration and Argument-Parameter Compatibility Check","text":"<p>The main purpose of function declarations, as stated above, is to inform the compiler about the function's return type. However, if the types of the function's parameters are specified in the function declarations (prototype), the compiler compares the number of parameters in the prototype declaration with the number of arguments sent to the function in the function call expression. For example:</p> <p>If a declaration like: </p><pre><code>    float process(float, float);\n</code></pre> is written, a compile-time error occurs if the <code>process</code> function is called with too few or too many arguments. <pre><code>x = process(5.8);               /* Invalid! Call with insufficient argument */\ny = process(4.6, 7.9, 8.0)      /* Invalid! Call with excessive arguments */\n</code></pre>"},{"location":"c/13_function_declarations/#details-regarding-declaration-syntax","title":"Details Regarding Declaration Syntax","text":"<p>The declarations of functions with the same return type can be written separated by commas, but such a declaration form is generally not preferred by programmers. </p><pre><code>    double func1(int), func2(int, int), func3(float);\n</code></pre> The declaration above is valid. With such a declaration, the compiler is informed that the return value of all functions <code>func1</code>, <code>func2</code>, and <code>func3</code> is of type <code>double</code>. <p>Function declarations can also be combined with variable definitions. This is also not preferred for readability. </p><pre><code>    long func1(int), long func2(void), x, y;\n</code></pre> With the declaration statement above, the declarations of <code>func1</code> and <code>func2</code> are made, while the variables \\(x\\) and \\(y\\) are defined. <p>Making a function declaration does not necessitate defining or calling that function. Not defining a declared function does not cause an error.</p> <p>A function's declaration can be made multiple times. This does not cause a compile-time error. However, the declarations made must not contradict each other.</p> <p>Suppose declarations for the same function are made in different places in the source file, in the following forms: </p><pre><code>int func (int, int);\nfunc (int, int);\nint func(int x, int y);\nfunc(int number1, int number2);\n</code></pre> <p>There is no contradiction in any of the declarations above. Using different names for the function parameters in subsequent declarations does not create a contradiction because the scope of these names is only within the parenthesis where the declaration is made. However, the following different declarations are invalid: </p><pre><code>double func(int x, double y);\ndouble func(int x, float y);  /* Invalid! Conflict in parameter type */\nlong sample(double x);\nsample (double x); /* Invalid! Return type conflict (assumed int vs declared long) */\n</code></pre>"},{"location":"c/13_function_declarations/#locations-of-function-declarations-in-multi-file-projects","title":"Locations of Function Declarations in Multi-File Projects","text":"<p>In C and C++ languages, a project often consists of more than one source file, i.e., modules. In most source files, functions defined in other source files are called. That is, there is often a service-client relationship between source files. A module that will serve other modules is written as two separate files. One of the files is the implementation file, which has the <code>.c</code> extension. Declarations regarding the services provided by this file to other modules are placed in another file with the <code>.h</code> extension. This file is called a header file. Declarations of functions that will serve other modules should be placed inside the header file.</p> <p>The client source file includes the content of the server module's header file in its own file using the <code>#include</code> preprocessor command. Thus, the declaration is made. This situation will be revisited in the section on \"Preprocessor Commands.\"</p>"},{"location":"c/14_type_conversions/","title":"Type Conversions","text":""},{"location":"c/14_type_conversions/#type-conversions","title":"Type Conversions","text":"<p>There are certain limitations when computers perform arithmetic operations. For computers to perform an arithmetic operation, the operands involved generally need to have the same length (i.e., the same number of bits) and be represented in the same format in memory. For example, the processor can directly add two 16-bit integers, but it cannot directly add a 16-bit integer and a 32-bit floating-point number.</p> <p>The C programming language allows different types to coexist within the same expression. That is, a variable of an integer type, a literal of type <code>float</code>, or a variable of type <code>char</code> can be included together in a single expression. In this case, before subjecting them to any operation, the C compiler performs the appropriate type conversions to enable the computer hardware to evaluate the expression.</p> <p>For instance, when a 16-bit <code>int</code> value is added to a 64-bit <code>double</code> value, the 16-bit <code>int</code> value is first represented as a 64-bit <code>double</code> value, and then the addition is performed. Similarly, when a 16-bit <code>int</code> value is multiplied by a 64-bit <code>double</code> value, the compiler first converts the <code>int</code> value to a 64-bit <code>double</code> value. This type conversion is more complex because <code>int</code> and <code>double</code> values are stored in different formats in memory.</p> <p>These type conversions are performed automatically without the programmer needing to write any code. We call such conversions implicit type conversions. On the other hand, the C language also gives the programmer the ability to treat any expression as a different type using an operator. We call such type conversions performed by the programmer explicit type conversions or type casts.</p> <p>Let's first examine implicit type conversions. Unfortunately, implicit type conversions are complex, and if not well understood, errors in programs are inevitable. You know that there are 11 different native data types in C. To avoid any errors, it is necessary to know very well how implicit type conversion will be performed for every possible binary combination of these types.</p>"},{"location":"c/14_type_conversions/#when-is-type-conversion-performed","title":"When is Type Conversion Performed?","text":"<p>An implicit type conversion is performed automatically in the four cases listed below:</p> <ol> <li>If the operands of an arithmetic or logical expression are not of the same type:     We call such type conversions conversion before operation.</li> <li>If the type of the expression on the right side of the assignment operator is not the same as the type of the object on the left side: <pre><code>double total;\nlong number1, number2;\n/***/\ntotal = number1 + number2;\n</code></pre>     We call the type conversions performed in this case assignment type conversions.</li> <li>If the type of an argument sent to a function in a function call is not the same as the type of the corresponding parameter of the function: <pre><code>double sqrt (double val);\nvoid func()\n{\n    int number;\n    double result = sqrt(number);\n    /***/\n}\n</code></pre>     In the example above, the type of the argument <code>number</code> sent to the called <code>sqrt</code> function is different from the type of the function's parameter variable. In this case, a type conversion operation is performed.</li> <li>If the type of a <code>return</code> expression is not the same as the return type of the function: <pre><code>double func(int val)\n{\n    /****/\n    return val;\n}\n</code></pre>     In the <code>func</code> function defined above, the type of the <code>return</code> expression is <code>int</code>, while the declared return type of the function is <code>double</code>. In this case, an implicit type conversion operation is performed by the compiler.</li> </ol> <p>Cases 3 and 4 can also be considered assignment operations. Arguments in a function call expression are passed by being copied to the parameter variables. Thus, there is an implicit assignment operation. Similarly, <code>return</code> expressions are also copied to temporary objects that will hold the function's return value.</p>"},{"location":"c/14_type_conversions/#implicit-arithmetic-type-conversions-before-operation","title":"Implicit Arithmetic Type Conversions (Before Operation)","text":"<p>Implicit type conversions before an operation are applied when the types of the operands in expressions containing binary operators are different. As a result of the implicit type conversion, the situation of having two different types is eliminated, and both operands are made to have the same type. For example: </p><pre><code>int i;\ndouble d, result;\nresult = i + d;\n</code></pre> The types of the variables <code>i</code> and <code>d</code> on the right side of this expression are different. One operand is <code>int</code>, and the other is <code>double</code>. In this case, the compiler generates code that expresses one of the operands in the type of the other in a temporary region. Therefore, the operation is performed in the common type. <p>So, should the <code>int</code> operand be expressed as <code>double</code>, or the <code>double</code> operand as <code>int</code>? The compiler tries to perform such a conversion in a way that prevents information loss.</p> <p>In this situation, to prevent information loss, the operand with the smaller type is generally expressed in the type of the operand with the larger type.</p> <p>To learn the rules in detail, let's examine the possible situations under two main groups:</p>"},{"location":"c/14_type_conversions/#1-if-one-of-the-operands-is-a-real-number-type","title":"1. If One of the Operands is a Real Number Type:","text":"<ul> <li>If one of the operands is of type <code>long double</code> and the other is of a different type, the other operand is expressed in the <code>long double</code> type, and the operation is performed in the <code>long double</code> type.</li> <li>If one of the operands is of type <code>double</code> and the other is of a different type, the other operand is expressed in the <code>double</code> type, and the operation is performed in the <code>double</code> type.</li> <li>If one of the operands is of type <code>float</code> and the other is of a different type, the other operand is expressed in the <code>float</code> type, and the operation is performed in the <code>float</code> type.</li> </ul>"},{"location":"c/14_type_conversions/#2-if-none-of-the-operands-are-real-number-types","title":"2. If None of the Operands are Real Number Types:","text":"<p>If any of the operands in the expression are of type <code>signed char</code>, <code>unsigned char</code>, <code>signed short int</code>, or <code>unsigned short int</code>, these types are converted to the <code>int</code> type before the following algorithm is applied. This conversion is called \"integral promotion.\"</p> <p>The following rules are then applied:</p> <ul> <li>If one of the operands is of type <code>unsigned long</code> and the other is of a different type, the other operand is expressed in the <code>unsigned long</code> type, and the operation is performed in the <code>unsigned long</code> type.</li> <li>If one of the operands is of type <code>signed long</code> and the other is of a different type, the other operand is expressed in the <code>signed long</code> type, and the operation is performed in the <code>signed long</code> type.</li> <li>If one of the operands is of type <code>unsigned int</code> and the other is of a different type, the other operand is expressed in the <code>unsigned int</code> type, and the operation is performed in the <code>unsigned int</code> type.</li> </ul> <p>Exceptions:</p> <ul> <li>If one of the operands is <code>signed long int</code> and the other is <code>unsigned int</code>, and the lengths of these types are the same on the system used (as in UNIX and Win 32 systems), both operands are converted to the <code>unsigned long int</code> type.</li> <li>If one of the operands is <code>signed int</code> and the other is <code>unsigned short int</code>, and the lengths of these types are the same on the system used (as in the DOS operating system), both operands are converted to the <code>unsigned int</code> type.</li> </ul> <p>Care should be taken when converting from a signed integer type to an unsigned integer type: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int x = -2;\n    unsigned int y = 1;\n    if (y &gt; x)\n        printf(\"true!\\n\");\n    else\n        printf(\"false!\\n\");\n}\nreturn 0;\n</code></pre> <p>When the program above runs, the message \"false!\" is printed to the screen.</p> <p>In the expression <code>y &gt; x</code>, the left operand of the <code>&gt;</code> operator is of type <code>unsigned int</code>, while the right operand is of type <code>int</code>. As a result of the implicit type conversion, the <code>int</code> operand is expressed as <code>unsigned int</code> before the operation. When the value \\(-2\\) is expressed as <code>unsigned int</code>, it is no longer a negative value but a large positive number. For example, if a 2-byte <code>int</code> type is involved, this value is 65534. Therefore, the expression <code>y &gt; x</code> is interpreted as false. The comparison is \\(1 &gt; 65534\\), which is false.</p> <p>Function call expressions can also cause implicit type conversions if they form other expressions with operators. This is because for functions that have a return value, the function call expression corresponds to the function's return value. For example: </p><pre><code>int i = 5;\n...\npow(2, 3) + i\n</code></pre> <p>In the expression above, since the return value of the <code>pow</code> function is of type <code>double</code>, the variable <code>i</code>, which is of type <code>int</code>, is also expressed as <code>double</code> in a temporary region and entered into the operation so that the operation can be performed.</p>"},{"location":"c/14_type_conversions/#assignment-type-conversions","title":"Assignment Type Conversions","text":"<p>These type conversions have a very simple rule: Before assignment, the expression on the right side of the assignment operator is expressed in the type of the object on the left side of the assignment operator.</p> <p>There is no information loss when converting smaller types to larger types. For example: </p><pre><code>double leftx;\nint righty = 5;\nleftx = righty;\n</code></pre> In the example above, the type of the <code>righty</code> variable is <code>int</code>. First, an implicit conversion to the <code>double</code> type is performed, and then the value of the <code>righty</code> variable, expressed as <code>double</code>, is assigned to the <code>leftx</code> variable. <p>Below are some examples for 16-bit systems:</p> TYPE decimal hex converted type hex decimal <code>int</code> 138 <code>0x008A</code> <code>long int</code> <code>0x0000008A</code> 138L <code>char</code> 'd' (100) <code>0x64</code> <code>int</code> <code>0x0064</code> 100 <code>int</code> -56 <code>0xFFC8</code> <code>long int</code> <code>0xFFFFFFC8</code> -56L <code>char</code> '\\x95' (-107) <code>0x95</code> <code>int</code> <code>0xFF95</code> -107 <code>unsigned int</code> 45678 <code>0xB26E</code> <code>long int</code> <code>0x0000B26E</code> 45678L <code>char</code> '0' (48) <code>0x30</code> <code>long int</code> <code>0x00000030</code> 48L <p>When a negative integer is converted from a smaller type to a larger type, the high-order bits of the number are filled with the 1 bit to preserve negativity (sign extension).</p> <p>In assignment type conversions performed by the compiler, information loss may occur before the assignment if a larger type is converted to a smaller type.</p> <p>The following simple rules can be given:</p> <ul> <li> <p>If both sides of the assignment operator are integer types (<code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>), information loss may occur if the right side of the assignment operator is a larger type. Information loss only occurs if the value on the right side of the assignment operator is outside the boundaries of the type on the left side. Information loss appears as the loss of high-order bytes. Example: </p><pre><code>long m = 0x12345678;\nint y = m;\nprintf (\"m = %x\\n\", m);\n</code></pre> In the example above, the value of a <code>long</code> type variable is assigned to an <code>int</code> type variable \\(y\\). We assume the code is running on a 16-bit system, for example, under DOS. Under DOS, the number limits for the <code>int</code> type are \\(-32768\\) to \\(+32767\\). These numbers are the largest and smallest values that can be written as signed for a two-byte area. In the hexadecimal number system, each digit corresponds to 4 bits, and every two digits correspond to 1 byte of space. Therefore, the number <code>0x12345678</code> is an 8-hex digit, or 4-byte, long number. However, the object to which the assignment will be made is of type <code>int</code>, and this type can be at most 4 hex digits (2 bytes) long. In this case, the high-order 2 bytes (4 hex digits) of the value belonging to the variable \\(m\\) are lost. After the assignment operation, the value of the variable \\(y\\) is printed as <code>5678</code> by the <code>printf</code> function. </li> <li> <p>If the right operand of the assignment operator is a real number type (<code>float</code>, <code>double</code>, <code>long double</code>) and the left operand is an integer type, the decimal part of the real number value is first lost. If the integer part obtained from the real number cannot be expressed in the integer type to which the assignment is made, this behavior is undefined behavior. Code where this situation occurs must be strictly avoided. However, almost all compilers perform type conversion in the following way in this situation: If the real number that is the right operand of the assignment operator contains a decimal part, the decimal part is first lost. If the remaining integer value after the decimal part is lost stays within the limits of the left operand's type, there is no further information loss, but if the limits of the left side's type are exceeded, there is an additional information loss, and this time the high-order bytes are lost. Example: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    double y = 234.12;\n    int x;\n    x = y;\n    printf(\"x = %d\\n\", x); /* x is assigned the value 234 */\n    y = 7689523345.347;\n    x = y; /* Error: Undefined behavior/Information loss */\n    printf(\"x = %d\\n\", x);\n    return 0;\n}\n</code></pre> Now, compile and run the following program: <pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    char ch;\n    ch = 135;\n    if (ch == 135)\n        printf(\"true!\\n\");\n    else\n        printf(\"false!\\n\");\n    return 0;\n}\n</code></pre> Why is \"false!\" printed to the screen when the program runs? </li> </ul> <p>The value 135 is assigned to the variable <code>ch</code>: </p><pre><code>ch = 135;\n</code></pre> In this case, since the high-order byte will be lost, the value assigned to the variable <code>ch</code> becomes: <pre><code>1000 0111\n</code></pre> <p>In the comparison operation <code>ch == 135</code>, the variable <code>ch</code>, which is of type <code>char</code>, is promoted to the <code>signed int</code> type before the comparison operation. As a result of integral promotion before the operation, the high-order bytes are filled with 1 bits because <code>ch</code> has a negative value. Before the comparison operation, the value of <code>ch</code> becomes:</p> <pre><code>1111 1111 1000 0111\n</code></pre> <p>However, the value 135, which is the right operand of the comparison operator, is an <code>int</code> type literal. That is, the values actually being compared are as follows:</p> <pre><code>1111 1111 1000 0111\n0000 0000 1000 0111\n</code></pre> <p>The comparison results in false.</p>"},{"location":"c/14_type_conversions/#integral-promotion","title":"Integral Promotion","text":"<p>As explained earlier, integral promotion means that the types <code>char</code>, <code>unsigned char</code>, <code>short</code>, and <code>unsigned short</code> found in an expression are automatically converted to the <code>int</code> type before the expression is evaluated by the compiler.</p> <p>So, is the conversion made to <code>signed int</code> or <code>unsigned int</code>?</p> <p>The general rule is this: If the value of the operand undergoing type conversion can be expressed in the <code>int</code> type, the conversion is made to <code>int</code>; if it cannot be expressed, the conversion is made to <code>unsigned int</code>.</p> <p>For example, in the DOS operating system, where <code>unsigned short</code> and <code>int</code> types have the same length, the <code>unsigned short</code> type is converted to the <code>unsigned int</code> type during integral promotion.</p> <p>If the value to be promoted is of type <code>signed char</code>, <code>unsigned char</code>, or <code>signed short</code>, the conversion is made to the <code>signed int</code> type.</p> <p>We must not overlook the following point regarding information loss. In some cases, information loss occurs not because type conversion is performed, but because it is not performed. Boundary value overflows can be a good example of this situation.</p> <p>Example: (Assume we are working under DOS) </p><pre><code>long x = 1000 * 2000;\n</code></pre> The code above seems normal at first glance. This is because the result of the multiplication, 2000000, is within the signed <code>long</code> type number limits under DOS. However, information loss occurs before the assignment operation. <code>1000</code> and <code>2000</code> are <code>int</code> type literals, and when they are entered into the operation, the value produced by the multiplication operator is also of type <code>int</code>. In this case, since the <code>int</code> type, which is 2 bytes long, cannot hold the value 2000000, the high-order byte is lost. 2000000 can be represented as <code>0x1E8480</code> in the hexadecimal number system. When the high-order byte is lost, the operation result becomes <code>0x8480</code>. <code>0x8480</code> is a negative number because its sign bit is 1. If we take its two's complement: <pre><code>0x8480\n1000 0100 1000 0000 (binary)\n0111 1011 0111 1111 (one's complement)\n0111 1011 1000 0000 (two's complement = 0x7B80 = 31616)\n</code></pre> <p>As seen, the value produced by the operation is \\(-31616\\). In this case, even if the type of the variable \\(x\\) is <code>long</code>, the assigned value will be \\(-31616\\).</p>"},{"location":"c/14_type_conversions/#type-conversion-in-function-calls","title":"Type Conversion in Function Calls","text":"<p>As stated before, if there is a type difference between the arguments sent to a function and the parameters of the function that will hold these arguments, an implicit type conversion occurs, and the type of the arguments is converted to the type of the parameter variables. However, for this type conversion to occur, the compiler must have information about the types of the function's parameter variables before reaching the function call expression. The compiler can obtain this information in two separate ways:</p> <ol> <li>If the called function is defined before the calling function: the compiler determines the type of the parameter variables from the function's definition.</li> <li>If the function declaration (prototype) is made: the compiler has prior knowledge about the type of the parameter variables.</li> </ol> <p>Examine the following example: </p><pre><code>#include &lt;stdio.h&gt;\ndouble func(double x, double y)\n{\n    /***/\n}\nint main()\n{\n    int a, b;\n    /***/\n    func(a, b);\n    return 0;\n}\n</code></pre> <p>In the example above, the values of the variables \\(a\\) and \\(b\\), which are of type <code>int</code>, are sent as arguments to the <code>func</code> function called within the <code>main</code> function. Since the function definition is before the call expression, the values of the variables \\(a\\) and \\(b\\), which are of type <code>int</code>, are converted to the <code>double</code> type and passed to the variables \\(x\\) and \\(y\\), which are the parameters of the <code>func</code> function. If the <code>func</code> function is defined after the <code>main</code> function, information about the types of the parameter variables must be given to the compiler with a function declaration so that the implicit type conversion can be performed. </p><pre><code>#include &lt;stdio.h&gt;\ndouble func(double x, double y); // Function declaration (prototype)\nint main()\n{\n    int a, b;\n    /***/\n    func(a, b);\n    return 0;\n}\ndouble func(double x, double y)\n{\n    /***/\n}\n</code></pre> <p>So, if the called function is defined after the calling function and no function declaration is made\u2014in which case the function must have an <code>int</code> return type to avoid a compile-time error\u2014will type conversion occur?</p> <p>In this case, since the compiler will not have information about the types of the function's parameters, it applies an operation called default argument conversion to the arguments sent to the function. Default argument conversion is as follows:</p> <ul> <li>Arguments of type <code>char</code> or <code>short</code> are promoted to integer (<code>integral promotion</code>).</li> <li>Arguments of type <code>float</code> are converted to double.</li> <li>No type conversion is performed for arguments of other types.</li> </ul>"},{"location":"c/14_type_conversions/#type-cast-operator","title":"Type Cast Operator","text":"<p>With the type cast operator, an expression can be expressed in another type before it is subjected to an operation. The type cast operator is a unary operator in the prefix position.</p> <p>The operator consists of parentheses and a type information written inside the parentheses: </p><pre><code>    (double)x\n</code></pre> The value produced by the operator is the value of its operand expression expressed in the type inside the parentheses. The type cast operator, like all other unary operators, is at the second precedence level of the operator precedence table. <p>Compile and run the following program: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int x = 10;\n    int y = 4;\n    double z;\n    z = (double)x / y;\n    printf(\"z = %lf\\n\", z);\n    return 0;\n}\n</code></pre> In the expression <code>z = (double)x / y</code> in the program above, the type cast operator produces a value first. The value produced by the type cast operator is the value of the object \\(x\\) expressed as <code>double</code>. In this case, when it is the turn of the division operator, the operand of the division operator is the value 10 of type <code>double</code>. This time, with an implicit type conversion, the right operand of the division operator is converted to <code>double</code>, and the division is performed in the <code>double</code> type. In this case, the division operator produces the value \\(2.5\\). <p>Undoubtedly, if the expression had been written as follows, there would still be no information loss: </p><pre><code>    z = x / (double)y\n</code></pre> However, if the expression had been written as follows: <pre><code>    z = (double) (x / y)\n</code></pre> in this case, the operand of the type cast operator would be the expression <code>(x / y)</code>. This would not prevent information loss. The result of integer division \\(10 / 4\\) is \\(2\\). The type cast then converts \\(2\\) to \\(2.0\\). <p>In cases where information loss is desired, an explicit conversion with the type cast operator should be made instead of an implicit type conversion for readability. </p><pre><code>int i;\ndouble d;\n/***/\ni = d;\n</code></pre> Assigning the value of the <code>double</code> variable \\(d\\) to the <code>int</code> variable \\(i\\) does not exhibit reliable behavior. At best, only the integer part of the value of \\(d\\) is assigned to the variable \\(i\\). Readers of such code get the impression that this assignment was made accidentally. Most compilers also report the possible information loss with a warning message. If this assignment is made consciously, the type cast operator should be used: <pre><code>int i;\ndouble d;\n/***/\ni = (int)d;\n</code></pre> In the following program, a floating-point number entered from the keyboard is rounded to the nearest integer. If the decimal part of the entered value is greater than or equal to <code>.5</code>, the number is rounded up; if it is less than <code>.5</code>, the number is rounded down: <pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    double d;\n    int x;\n    printf(\"enter a real number : \");\n    scanf(\"%lf\", &amp;d);\n    if (d &gt;= 0) // Note: Simplified condition for rounding based on sign.\n        x = d + .5;\n    else\n        x = d - .5;\n    printf(\"x = %d\\n\", x);\n    return 0;\n}\n</code></pre>"},{"location":"c/15_loop_statements/","title":"Loop Statements","text":""},{"location":"c/15_loop_statements/#loop-statements","title":"Loop Statements","text":"<p>Control statements that allow a part of a program to be executed repeatedly are called \"loop statements.\" There are 3 separate loop statements in the C language:</p> <ul> <li><code>while</code> loop statement</li> <li><code>do while</code> loop statement</li> <li><code>for</code> loop statement</li> </ul> <p>The most frequently used of these is the <code>for</code> loop statement. The <code>for</code> loop statement is the most powerful loop structure, not only in the C language but in all programming languages. Even if there were no <code>while</code> or <code>do while</code> loop statements, code written using those loops could be written using the <code>for</code> loop. However, there are situations where <code>while</code> and <code>do while</code> loops are preferred for readability.</p>"},{"location":"c/15_loop_statements/#the-while-loop-statement","title":"The <code>while</code> Loop Statement","text":"<p>The general syntax of the <code>while</code> loop statement is as follows: </p><pre><code>while (expression)\n    statement;\n</code></pre> The expression inside the parenthesis following the <code>while</code> keyword is called the control expression. The first statement following the <code>while</code> parenthesis is called the loop body. The loop body can be formed by a simple statement, a null statement, a compound statement, or a control statement. <p>The execution of the <code>while</code> loop statement is as follows: First, the numerical value of the control expression is calculated. This expression is evaluated logically. If the expression has a value of 0, it is interpreted as false. In this case, the statement in the loop body is not executed, and the program flow continues with the first statement following the loop statement. If the control expression has a non-zero value, it is interpreted as true; in this case, the statement in the loop body is executed.</p> <p>After the statement in the loop body is executed, the value of the control expression is calculated again. The statement in the loop body is executed as long as the control expression has a non-zero value (is true). The loop is exited when the control expression has a value of zero, meaning when the expression is interpreted as false.</p> <p>The <code>while</code> loop in the C language is a loop statement that allows one or more tasks to be performed as long as a condition is true.</p> <p>Examine the following example: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int i = 0;\n    while (i &lt; 100) {\n        printf(\"%d \", i);\n        ++i;\n    }\n    return 0;\n}\n</code></pre> Let's examine the <code>while</code> loop in the <code>main</code> function. A compound statement forms the loop body. This compound statement is executed as long as the expression \\(i &lt; 100\\) is true. That is, the <code>printf</code> function is called, and then the value of the variable \\(i\\) is incremented by 1. When the value of the variable \\(i\\) becomes 100, the control expression will be false, and the loop is exited. Examine the following example: <pre><code>#include &lt;stdio.h&gt;\nint main ()\n{\n    char ch = 'A';\n    while (ch &lt;= 'Z')\n        putchar(ch++);\n    return 0;\n}\n</code></pre> With the <code>main</code> function above, all uppercase characters of the English alphabet are printed to the screen sequentially. You see that the variable named <code>ch</code> is first assigned the value 'A'. The loop iterates as long as the expression <code>ch &lt;= 'Z'</code> is true. This time, a simple statement forms the loop body. You know that the postfix <code>++</code> operator produces the object's own value. However, due to the side effect of the operator, the value of the variable <code>ch</code> is incremented by 1. When the value of the variable <code>ch</code> is 'Z', the control expression is still true. But in the next iteration of the loop, the control expression is false, and the loop is exited. <p>In the <code>while</code> loop statement, the statement in the loop body is not guaranteed to be executed at least once. Since the control expression is evaluated first, if the control expression is false upon the first entry to the loop, the statement in the loop body is never executed.</p>"},{"location":"c/15_loop_statements/#control-expressions","title":"Control Expressions","text":"<p>Any expression can be the control expression of a <code>while</code> loop.</p> <p>The control expression can contain a function call: </p><pre><code>while (isupper(ch)) {\n    /***/\n}\n</code></pre> The <code>while</code> loop above iterates as long as the <code>isupper</code> function returns a non-zero value, i.e., as long as <code>ch</code> is an uppercase character. <p>The following <code>while</code> loop iterates as long as the <code>isupper</code> function returns a value of 0, i.e., as long as <code>ch</code> is not an uppercase character. </p><pre><code>while (!isupper(ch)) {\n    /***/\n}\n</code></pre> The comma operator can also be used in the control expression of the <code>while</code> loop statement. Examine the following example: <pre><code>#include &lt;stdio.h&gt;\n#include &lt;ctype.h&gt;\n// #include &lt;conio.h&gt; (Assuming getch() is available)\nint getch_mock() { return getchar(); } // Mock function for standard C environment\nint main()\n{\n    char ch;\n    while (ch = getch_mock(), toupper(ch) != 'Q')\n        putchar(ch);\n    return 0;\n}\n</code></pre> You know that the expression that is the left operand of the comma operator is guaranteed to be performed first. Let's look at the control expression of the <code>while</code> loop in the <code>main</code> function above: <pre><code>while (ch = getch_mock(), toupper(ch) != 'Q')\n</code></pre> Since the expression that is the left operand of the comma operator will be performed first, the <code>getch</code> function is called (or <code>getch_mock</code> here). The code number of the character received from the keyboard is assigned to the variable <code>ch</code>. Then, with the call to the <code>toupper</code> function, it is tested whether the value of the variable <code>ch</code> is the character 'Q'. Recall that the value produced by the comma operator is the value of its right operand. In this case, the expression that determines whether the loop continues is: <pre><code>toupper(ch) != 'Q'\n</code></pre> That is, the loop iterates as long as <code>ch</code> is not the uppercase character 'Q' (or 'q'). <p>A variable can also form the control expression: </p><pre><code>while (x) {\n    /***/\n}\n</code></pre> The loop above iterates as long as the variable \\(x\\) has a non-zero value. <p>A literal can also be the control expression: </p><pre><code>while (1) {\n    /***/\n}\n</code></pre> In the <code>while</code> statement above, the literal 1 is used as the control expression. Since 1 is a non-zero value, and the control expression does not change based on a variable, the loop cannot be exited by the condition becoming false. Such loops are called infinite loops. Infinite loops can occur as a result of a programmer's mistake, or they can be created consciously to achieve a specific purpose. A <code>while</code> loop where the literal value 1 is inside the <code>while</code> parenthesis is a consciously created infinite loop statement. <p>The use of the assignment operator within the control expression is also a common occurrence: </p><pre><code>while ((val = get_value()) &gt; 0) {\n    foo(val);\n    /***/\n}\n</code></pre> In the <code>while</code> loop above, the return value of the <code>get_value</code> function is assigned to the variable named <code>val</code>. You see that the expression formed by the assignment operator is enclosed in parentheses. Since the value produced by the assignment operator is the value assigned to the object, the left operand of the greater-than operator is again the return value of the <code>get_value</code> function. In this case, the loop iterates as long as the return value of the <code>get_value</code> function is greater than 0. You see that the <code>foo</code> function called inside the loop body is sent the value of <code>val</code> as an argument. The <code>foo</code> function is called with the return value of the <code>get_value</code> function."},{"location":"c/15_loop_statements/#the-break-statement","title":"The <code>break</code> Statement","text":"<p>The <code>break</code> keyword is immediately followed by the terminating token: </p><pre><code>break;\n</code></pre> The statement formed in this manner is called the \"break statement.\" The <code>break</code> statement can be used in the body of a loop statement or a <code>switch</code> statement. When a <code>break</code> statement is encountered during the execution of a loop statement, the loop is exited, and the program flow continues with the first statement outside the loop body. That is, the loop is exited unconditionally. <p>Examine the following program: </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\nint main ()\n{\n    int val;\n    while (1) {\n        printf(\"enter a number : \");\n        scanf(\"%d\", &amp;val);\n        if (val &lt; 0)\n            break;\n        printf(\"square root of %d = %lf\\n\", val, sqrt(val));\n    }\n    printf(\"loop exited, program terminating!\\n\");\n    return 0;\n}\n</code></pre> An infinite loop is consciously created in the program. In each iteration of the loop, a value is read into the variable named <code>val</code> from the keyboard. If a value less than 0 is entered from the keyboard, the loop is exited with the <code>break</code> statement. <p>The <code>break</code> statement can only be used in the body of a loop statement or a <code>switch</code> statement. The following code snippet is invalid: </p><pre><code>if (x &gt; 100) {\n    if (y &lt; 200)\n        break; // Invalid use of break outside a loop or switch\n    /***/\n}\n</code></pre>"},{"location":"c/15_loop_statements/#the-continue-statement","title":"The <code>continue</code> Statement","text":"<p>The <code>continue</code> keyword is also immediately followed by the terminating token: </p><pre><code>continue;\n</code></pre> The statement formed in this manner is called the \"continue statement.\" <p>When the program flow reaches the <code>continue</code> statement inside a loop statement, the loop skips to the next iteration, as if the current iteration of the loop has finished. </p><pre><code>int getval(void);\nint isprime(void);\nwhile (1) {\n    val = getval();\n    if (val &lt; 0)\n        break;\n    /* statements */\n    if (isprime(val))\n        continue;\n    /* statements */\n}\n</code></pre> In the <code>main</code> function above, an infinite loop is created. In each iteration of the loop, the return value of the <code>getval</code> function is stored in the <code>val</code> variable. If the value assigned to the <code>val</code> variable is 0, the loop is exited with the <code>break</code> statement. The subsequent <code>if</code> statement tests whether the <code>val</code> value is prime. If the value assigned to <code>val</code> is prime, the rest of the loop is not executed, and the program moves to the next iteration of the loop with the <code>continue</code> statement. <p>The <code>continue</code> statement is particularly used to increase readability, especially when there are long <code>if</code> statements inside the loop. </p><pre><code>while (k++ &lt; 100) {\n    ch = getch();\n    if (!isspace(ch)) {\n        /* statements */\n    }\n}\n</code></pre> <p>In the <code>while</code> loop written above, the code number of a character is read into the <code>ch</code> variable from the keyboard using the <code>getch</code> function. It is desired that the statements be executed if the character received from the keyboard is not a whitespace character. The readability of the code snippet above can be increased by using the <code>continue</code> statement: </p><pre><code>while (k++ &lt; 100) {\n    ch = getch();\n    if (isspace(ch))\n        continue;\n    /* statements */\n}\n</code></pre> <p>Some programmers also use the <code>continue</code> statement as an alternative to a null statement in the loop body: </p><pre><code>    while (i++ &lt; 100)\n        continue;\n</code></pre> The <code>continue</code> statement can only be used in the body of a loop statement. Using the <code>continue</code> statement anywhere outside a loop is invalid."},{"location":"c/15_loop_statements/#common-mistakes","title":"Common Mistakes","text":"<p>Accidentally making the loop body of the <code>while</code> loop statement a null statement is a common mistake:</p> <pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int i = 10;\n    while (--i &gt; 0); /* a null statement here */\n    printf(\"%d\\n\", i);\n    return 0;\n}\n</code></pre> <p>The loop iterates until the value of the expression inside the <code>while</code> parenthesis becomes 0. The <code>printf</code> call is not in the body of the loop statement. The terminating token following the <code>while</code> parenthesis is considered the statement that forms the loop body. When the loop is exited, the value 0 is printed to the screen.</p> <p>If a null statement is desired in the body of the <code>while</code> loop consciously, not as a mistake, this null statement should be written on the next line, indented by one tab, rather than immediately after the <code>while</code> parenthesis, for readability.</p> <p>Another typical mistake related to the <code>while</code> loop statement is forgetting to block the loop body. That is, a simple statement is accidentally used when the loop body should be a compound statement: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int i = 1;\n    while (i &lt;= 100)\n        printf(\"%d \", i);\n    i++; // This statement is outside the loop body!\n    return 0;\n}\n</code></pre> Suppose it is desired to print numbers from 1 to 100 to the screen with a space between them. In the <code>while</code> statement above, the <code>i++</code> statement, which increments the loop variable, does not belong to the loop body. In this case, since the expression \\(i \\le 100\\) will always be true, an infinite loop occurs, and the value 1 is continuously printed to the screen. <p>Similar to the <code>if</code> statement, accidentally using the assignment operator (<code>=</code>) instead of the comparison operator (<code>==</code>) inside the <code>while</code> parenthesis is also a frequent mistake: </p><pre><code>    while (x == 5) {\n        /***/\n    }\n</code></pre> A loop like the one above iterates as long as the value of the variable \\(x\\) is 5, while the following statement creates an infinite loop: <pre><code>    while (x = 5) {\n        /***/\n    }\n</code></pre> In each iteration of the loop, the value 5 is assigned to the variable \\(x\\). Since the value produced by the assignment operator, which is 5, is interpreted as \"true,\" the loop iterates continuously."},{"location":"c/15_loop_statements/#using-the-postfix-or-operator-in-the-control-expression","title":"Using the Postfix <code>++</code> or <code>--</code> Operator in the Control Expression","text":"<p>The postfix <code>++</code> or <code>--</code> operator is often used in the control expression. In such a situation, the decision to continue the loop is made by first looking at the value of the expression, and then the side effect of the increment or decrement operator takes place. Examine the following example: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int i = 0;\n    while (i++ &lt; 100)\n        ;\n    printf(\"\\n%d\\n\", i); // Prints 101 to the screen.\n    return 0;\n}\n</code></pre>"},{"location":"c/15_loop_statements/#while-loop-that-iterates-n-times","title":"<code>while</code> Loop That Iterates \\(n\\) Times","text":"<p>For \\(n\\) being a positive integer, the following code templates can be used to create a <code>while</code> loop that iterates \\(n\\) times: </p><pre><code>while (n-- &gt; 0)\n\n// or\n\nwhile (n--)\n</code></pre> Below is a function named <code>power</code> that calculates a specific power of an integer. Examine the function: <pre><code>int power(int base, int exp)\n{\n    int result = 1;\n    while (exp--)\n        result *= base;\n    return result;\n}\n</code></pre> <p>The <code>while</code> loop written in the function iterates as many times as the value of the variable <code>exp</code>, right? In this case, the <code>base</code> variable is multiplied by itself <code>exp</code> times.</p>"},{"location":"c/15_loop_statements/#loop-body-being-a-null-statement","title":"Loop Body Being a Null Statement","text":"<p>Sometimes the loop body is consciously made a null statement. For readability, it is recommended that the null statement be written according to the indentation rule like a normal statement in this case. Examine the following program: </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;ctype.h&gt;\n// #include &lt;conio.h&gt; (Assuming getch() is available)\nint getch_mock() { return getchar(); } // Mock function for standard C environment\nint main()\n{\n    int ch;\n    printf(\"Yes or No? [y] [n] : \");\n    while ((ch = toupper(getch_mock())) != 'Y' &amp;&amp; ch != 'N')\n        ;\n    if (ch == 'Y')\n        printf(\"you said yes!\\n\");\n    else\n        printf(\"you said no!\\n\");\n    return 0;\n}\n</code></pre> <p>The <code>while</code> loop written in the <code>main</code> function above forces the user to enter one of the characters 'y', 'Y', 'n', or 'N' from the keyboard. Examine the loop carefully. The \"logical AND\" operator (<code>&amp;&amp;</code>) is used in the loop's control expression. Recall that the left operand of the \"logical AND\" operator is guaranteed to be performed first. The non-standard <code>getch</code> function (or <code>getch_mock</code> here) reads a character from the keyboard. The sequence number of the received character, i.e., the return value of the <code>getch</code> function, is sent as an argument to the standard <code>toupper</code> function. Thus, if a lowercase character is entered from the keyboard, it is converted to uppercase. The return value of the <code>toupper</code> function is assigned to the <code>ch</code> variable. The value of the expression inside the parenthesis is the value assigned to the <code>ch</code> variable. The inequality of the entire right side of the \"logical AND\" operator to the character 'Y' is queried. If the value assigned to the <code>ch</code> variable is 'Y', the second part of the \"logical AND\" operator is not even checked, and the control expression is interpreted as false. The loop is thus exited. If the value assigned to the <code>ch</code> variable is 'N', the right operand of the <code>&amp;&amp;</code> operator is evaluated, i.e., the inequality of the value of the <code>ch</code> variable to the character 'N' is queried. If <code>ch</code> is equal to 'N', the control expression is again interpreted as false, and the loop is exited. In all other cases, since the control expression will be interpreted as true, the loop continues to iterate. In other words, exiting the loop is only possible by entering one of the characters 'y', 'Y', 'n', or 'N' from the keyboard.</p>"},{"location":"c/15_loop_statements/#while-loop-statement","title":"<code>while</code> Loop Statement","text":"<p>Below is the definition of a function named <code>num_digit</code> that returns the number of digits of an integer. Compile and run the program:</p> <pre><code>#include &lt;stdio.h&gt;\nint num_digit(int val)\n{\n    int digit_counter = 0;\n    if (val == 0)\n        return 1;\n    while (val != 0) {\n        digit_counter++;\n        val /= 10;\n    }\n    return digit_counter;\n}\nint main()\n{\n    int x;\n    printf(\"enter an integer :\");\n    scanf(\"%d\", &amp;x);\n    printf(\"the number %d has %d digits!\\n\", x, num_digit(x));\n    return 0;\n}\n</code></pre> <p>A very simple algorithm is used to calculate the number of digits. The number is continuously divided by 10 until zero is obtained. In the <code>num_digit</code> function, it is first tested whether the value of the parameter variable <code>val</code> is 0. If <code>val</code> is equal to 0, the value 1 is returned. The number 0 also has 1 digit, right? The subsequent <code>while</code> loop iterates with the condition \\(val \\neq 0\\). That is, the loop is exited when the value of the variable <code>val</code> becomes 0. In each iteration of the loop, the value of the <code>digit_counter</code> variable is incremented by 1 inside the body. Then, with the statement <code>val /= 10;</code>, the <code>val</code> variable is made equal to one-tenth of its value.</p> <p>Below is a function named <code>sum_digit</code> that returns the sum of the digit values of an integer passed to it: </p><pre><code>#include &lt;stdio.h&gt;\nint sum_digit(int val)\n{\n    int digit_sum = 0;\n    while (val) {\n        digit_sum += val % 10;\n        val /= 10;\n    }\n    return digit_sum;\n}\nint main()\n{\n    int val;\n    printf(\"enter an integer :\");\n    scanf(\"%d\", &amp;val);\n    printf(\"the sum of the digits of the number %d is = %d\\n\", val, sum_digit(val));\n    return 0;\n}\n</code></pre> In the <code>sum_digit</code> function, the parameter variable <code>val</code> is again continuously divided by 10 in a loop, and the statements in the loop body are executed until <code>val</code> becomes 0. Inside the loop body, with the statement: <pre><code>digit_sum += val % 10;\n</code></pre> the units digit of the <code>val</code> variable is added to the <code>digit_sum</code> variable. Thus, after exiting the loop, the <code>digit_sum</code> variable holds the sum of the digit values of the number passed from outside. <p>Below is a function named <code>get_rev_num</code> that returns the reverse of an integer passed to it: </p><pre><code>#include &lt;stdio.h&gt;\nint get_rev_num(int val)\n{\n    int rev_number = 0;\n    while (val) {\n        rev_number = rev_number * 10 + val % 10;\n        val /= 10;\n    }\n    return rev_number;\n}\nint main()\n{\n    int val;\n    printf(\"enter an integer :\");\n    scanf(\"%d\", &amp;val);\n    printf(\"the reverse of the number %d is = %d\\n\", val, get_rev_num(val));\n    return 0;\n}\n</code></pre> <p>The variable <code>rev_number</code> defined in the <code>get_rev_num</code> function is initialized to 0. The <code>while</code> loop in the function is made to iterate until the value of the parameter variable <code>val</code> becomes 0. In each iteration of the loop, the value of the expression: </p><pre><code>    rev_number = rev_number * 10 + val % 10\n</code></pre> is assigned to the <code>rev_number</code> variable. <p>Suppose the value passed to the function is 1357:</p> <code>rev_number</code> <code>val</code> 0 1357 7 135 75 13 753 1 7531 0 <p>Upon exiting the loop, the value of the <code>rev_number</code> variable is 7531.</p> <p>The following program defines a function named <code>display_factors</code> that factorizes an integer and prints the factors to the screen from smallest to largest: </p><pre><code>#include &lt;stdio.h&gt;\nvoid display_factors(int number)\n{\n    int k = 2;\n    printf(\"(%d) -&gt; \", number);\n    while (number != 1) {\n        while (number % k == 0) {\n            printf(\"%d \", k);\n            number /= k;\n        }\n        ++k;\n    }\n    printf(\"\\n\");\n}\n</code></pre> The following program prints the 3-digit numbers that satisfy the equality \\(abc = a^3 + b^3 + c^3\\) to the screen: <pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int k = 100;\n    while (k &lt; 1000) {\n        int y = k / 100;\n        int o = k % 100 / 10;\n        int b = k % 10;\n        if (y * y * y + o * o * o + b * b * b == k)\n            printf(\"%d\\n\", k);\n        ++k;\n    }\n    return 0;\n}\n</code></pre> Try to find what value the following function calculates: <pre><code>int func(int val)\n{\n    int sum = 0;\n    while (val) {\n        sum += val % 10;\n        if (sum &gt; 10)\n            sum = 1 + sum % 10;\n        val /= 10;\n    }\n    return sum;\n}\n</code></pre>"},{"location":"c/15_loop_statements/#the-do-while-loop-statement","title":"The <code>do while</code> Loop Statement","text":"<p>The general syntax of the <code>do while</code> loop statement is as follows: </p><pre><code>do\n    statement;\nwhile (expression);\n</code></pre> In the <code>do while</code> loop, the control expression is at the end. The terminating token (semicolon) must be found after the <code>while</code> parenthesis. That is, the semicolon here is part of the loop statement's syntax. The execution of the <code>do while</code> loop is as follows: <p>The statement following the <code>do</code> keyword is executed once upon entering the loop; then, the control expression inside the <code>while</code> parenthesis is checked. The statement forming the loop body is executed as long as the control expression is true. What is the difference between the <code>do while</code> loop and the <code>while</code> loop? In the <code>while</code> loop, the statement in the loop body is not guaranteed to be executed at least once. However, in the <code>do while</code> loop, since the check is performed at the end, the statement in the body is executed at least once.</p> <p>Compile and run the following program: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int val;\n    do {\n        printf(\"enter a value between 0 - 100 : \");\n        scanf(\"%d\", &amp;val);\n    } while (val &lt; 0 || val &gt; 100);\n    printf(\"val = %d\\n\", val);\n    return 0;\n}\n</code></pre> In the <code>main</code> function, the <code>do while</code> loop forces the user to enter a value in the range 0-100. If the entered value is less than 0 or greater than 100, a new value is requested from the user. <p>The <code>num_digit</code> function, previously written using a <code>while</code> loop, is now written with a <code>do while</code> loop: </p><pre><code>int num_digit(int val)\n{\n    int digit_counter = 0;\n    do {\n        digit_counter++;\n        val /= 10;\n    } while(val != 0);\n    return digit_counter;\n}\n</code></pre> The <code>print_ulam</code> function defined below prints the Collatz sequence for an integer to the screen: <pre><code>#include &lt;stdio.h&gt;\nvoid print_ulam(int val)\n{\n    printf(\"Collatz sequence for %d\\n\", val);\n    do {\n        printf(\"%d \", val);\n        if (val % 2 == 0)\n            val /= 2;\n        else\n            val = val * 3 + 1;\n    } while(val &gt; 1);\n    printf(\"%d\\n\", val);\n}\nint main()\n{\n    int x;\n    printf(\"enter a number: \");\n    scanf(\"%d\", &amp;x);\n    print_ulam(x);\n    return 0;\n}\n</code></pre>"},{"location":"c/15_loop_statements/#the-for-loop-statement","title":"The <code>for</code> Loop Statement","text":"<p>The general syntax of the <code>for</code> loop statement is as follows: </p><pre><code>for (expression1; expression2; expression3)\n    statement;\n</code></pre> The compiler expects an opening parenthesis after the <code>for</code> keyword and two semicolon tokens inside the parenthesis. These two semicolons divide the <code>for</code> parenthesis into three parts. Expressions conforming to the definition of an expression can be placed in all three parts. <p>Two semicolons must be present inside the <code>for</code> parenthesis. Leaving the <code>for</code> parenthesis empty, or having one, three, or more semicolons inside the <code>for</code> parenthesis is invalid.</p> <p>The first statement that follows the closing of the <code>for</code> parenthesis forms the loop body. The loop body can consist of a simple statement, a compound statement (i.e., multiple statements enclosed in a block), a null statement, or a control statement.</p> <p>Each of the three expressions inside the <code>for</code> parenthesis has a separate function.</p> <p>The expression forming the second part of the <code>for</code> parenthesis is called the control expression. Like the expression inside the <code>while</code> parenthesis, this expression determines whether the loop continues. If the value of this expression is non-zero, i.e., interpreted as \"true,\" the loop continues. The statement in the loop body is executed. If the value of the control expression is 0, i.e., the expression is interpreted as false, the program flow continues with the execution of the first statement following the <code>for</code> loop statement.</p> <p>When the program flow reaches the <code>for</code> statement, the expression in the first part of the <code>for</code> parenthesis is evaluated. The expression in the first part is typically used to initialize the loop variable. However, there is no such requirement.</p> <p>The expression in the third part of the <code>for</code> parenthesis is evaluated after the statement(s) in the loop body have been executed and before the control expression is checked again. This part is mostly used for incrementing or decrementing a loop variable.</p> <p>Examine the following program: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int i;\n    for (i = 0; i &lt; 2; ++i)\n        printf(\"%d \", i);\n    printf(\"\\nlast value = %d\\n\", i);\n    return 0;\n}\n</code></pre> When the program flow reaches the <code>for</code> loop statement, the first expression inside the <code>for</code> parenthesis is evaluated first. That is, the value 0 is assigned to the variable <code>i</code>. <p>Now the program flow moves to the second part of the <code>for</code> parenthesis, the control expression, and the condition \\(i &lt; 2\\) is checked. Since the value of the control expression is non-zero, the expression is accepted as logically true. The program flow thus moves to the loop body. You see that the loop body is formed by a simple statement. This statement is executed. That is, the value of the variable <code>i</code> is printed to the screen, and the cursor moves to the next line.</p> <p>The program flow then moves to the third part of the <code>for</code> parenthesis, and the expression here is evaluated. That is, the value of the variable \\(i\\) is incremented by 1, and the value of the variable \\(i\\) becomes 1.</p> <p>The second expression is evaluated again, and since the expression \\(i &lt; 2\\) is true, the statement in the loop body is executed one more time.</p> <p>The program flow again moves to the third part of the <code>for</code> parenthesis, and the expression here is evaluated. That is, the value of the variable \\(i\\) is incremented by 1. The value of the variable \\(i\\) becomes 2.</p> <p>The program flow again moves to the second part of the <code>for</code> parenthesis. The control expression is checked again. Since the expression \\(i &lt; 2\\) is false this time, the program flow does not enter the loop body but continues with the first statement following the loop body. That is, the following is printed to the screen: </p><pre><code>    last value = 2\n</code></pre>"},{"location":"c/15_loop_statements/#loop-variables","title":"Loop Variables","text":"<p>There is no requirement to use a loop variable in the <code>for</code> loop. For example, the following loop fully conforms to the rules: </p><pre><code>for (func1(); func2(); func3())\n    func4();\n</code></pre> With the <code>for</code> loop statement above, the <code>func1</code> function is called upon entering the loop. The statement in the loop body is executed, meaning the <code>func4</code> function is called, as long as the <code>func2</code> function returns a non-zero value. After the <code>func4</code> function is called, and before the control expression is checked again, the <code>func3</code> function is called this time. <p>The following <code>for</code> loop statement prints the character received from the keyboard as long as the character 'x' is not entered: </p><pre><code>#include &lt;stdio.h&gt;\n// #include &lt;conio.h&gt; (Assuming getch() is available)\nint getch_mock() { return getchar(); } // Mock function for standard C environment\nint main()\n{\n    char ch;\n    for (ch = getch_mock(); ch != 'x' ; ch = getch_mock())\n        putchar(ch);\n    return 0;\n}\n</code></pre> There is no requirement for the loop variable to be one of the integer types. The loop variable can also be one of the real number types: <pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    double i;\n    for (i = 0.1; i &lt; 6.28; i += 0.01)\n        printf(\"%lf \", i);\n    return 0;\n}\n</code></pre> In the loop above, a <code>double</code> type loop variable is chosen. In the first part of the <code>for</code> parenthesis, the value 0.1 is assigned to the loop variable. In the third part of the parenthesis, the loop variable is incremented by 0.01. The loop iterates under the condition that the value of the variable \\(i\\) is less than 6.28."},{"location":"c/15_loop_statements/#omission-of-expressions-inside-the-for-parenthesis","title":"Omission of Expressions inside the <code>for</code> Parenthesis","text":"<p>The first part of the <code>for</code> loop statement parenthesis may not contain an expression. This is fully compliant with the rules. Suppose it is desired to print numbers from 1 to 100. The initialization of the loop variable can be moved outside the <code>for</code> loop, from the first part of the <code>for</code> parenthesis: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int i = 0;\n    for (; i &lt; 100; ++i)\n        printf(\"%d \", i);\n    return 0;\n}\n</code></pre> The third part of the <code>for</code> loop parenthesis may also not contain an expression. The increment or decrement of the loop variable can be performed in the loop body instead of inside the <code>for</code> parenthesis: <pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int i = 0;\n    for (; i &lt; 100;) {\n        printf(\"%d \", i);\n        i++;\n    }\n    return 0;\n}\n</code></pre> <code>for</code> loops without the first and third expressions are completely equivalent to <code>while</code> loops. Any code that can be written with a <code>while</code> loop can also be written with a <code>for</code> loop. The <code>while</code> loop is a better option for <code>for</code> loops without the first and third parts in terms of readability. <p>The second expression of the <code>for</code> parenthesis may also be completely absent. In this case, since there will be no control expression, the loop iterates continuously, independent of a condition. That is, an infinite loop is created. However, the two semicolons must still be present inside the parenthesis. The same task is now performed using a conscious infinite loop:</p> <p>Most C programmers prefer the pattern <code>for (;;)</code> when they want to consciously create an infinite loop. This pattern is equivalent to the pattern <code>while (1)</code>. Both indicate an infinite loop. The <code>for (;;)</code> form is preferred over the <code>while (1)</code> form for creating an infinite loop. </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int i = 0;\n    for (;;) {\n        if (i == 100)\n            break;\n        printf(\"%d \", i);\n        i++;\n    }\n    return 0;\n}\n</code></pre> Now, try to estimate what will be printed to the screen by the execution of the following loop statement: <pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    double d;\n    for (d = 1.5; d &lt; 3,0; d += 0.1)\n        printf(\"%lf \", d);\n    return 0;\n}\n</code></pre> Nothing is printed to the screen! You see that the loop's control expression is <code>d &lt; 3,0</code>. A comma character was accidentally used instead of a period when writing the floating-point literal. In this case, the value produced by the comma operator is the value of the second operand, which is 0. The control expression is interpreted as false, so the statement in the loop body is never executed."},{"location":"c/15_loop_statements/#for-loops-that-iterate-n-times","title":"<code>for</code> Loops That Iterate \\(n\\) Times","text":"<p>For \\(n\\) being a positive integer, all of the following loops iterate \\(n\\) times: </p><pre><code>    for (i = 0; i &lt; n; ++i)\n    for (i = 1; i &lt;= n; ++i)\n    for (i = n - 1; i &gt;= 0; --i)\n    for (i = n; i &gt; 0; --i)\n</code></pre>"},{"location":"c/15_loop_statements/#use-of-the-continue-statement-in-for-loops","title":"Use of the <code>continue</code> Statement in <code>for</code> Loops","text":"<p>With the use of the <code>continue</code> statement inside the body of a loop, the remaining statements in the body are skipped, and the loop moves to the next iteration. When a <code>continue</code> statement is encountered inside the body of a <code>for</code> loop, the program flow moves to the third expression of the <code>for</code> parenthesis, and this expression is evaluated.</p>"},{"location":"c/15_loop_statements/#using-the-loop-variable-as-a-flag","title":"Using the Loop Variable as a Flag","text":"<p>In some applications, the loop variable of the <code>for</code> loop also acts as a flag. Suppose it is necessary to exit a <code>for</code> loop when a certain condition occurs: </p><pre><code>for (i = 0; i &lt; 100; ++i)\n    if (is_valid(i))\n        break;\n</code></pre> As a result of running the loop statement above, two different situations are possible. If the <code>break</code> statement is executed in the loop body, i.e., if the <code>is_valid</code> function returns a non-zero value for any value of \\(i\\), the value of the variable \\(i\\) upon loop exit will be less than 100. If the loop completes all its iterations without the <code>break</code> statement being executed, the value of the variable \\(i\\) upon loop exit will be 100. <p>By checking whether the value of \\(i\\) is 100 upon loop exit, it can be understood how the loop was exited.</p>"},{"location":"c/15_loop_statements/#examples-of-for-loop-statement-usage","title":"Examples of <code>for</code> Loop Statement Usage","text":"<p>The following program defines functions named <code>okek</code> (LCM) and <code>obeb</code> (GCD) that calculate the greatest common divisor and the least common multiple of two numbers: </p><pre><code>#include &lt;stdio.h&gt;\nint obeb(int number1, int number2)\n{\n    int i;\n    int min = (number1 &lt; number2) ? number1 : number2;\n    for (i = min; i &gt;= 1; --i)\n        if (number1 % i == 0 &amp;&amp; number2 % i == 0)\n            return i;\n    return 1;\n}\nint okek(int number1, int number2)\n{\n    int i;\n    int max = (number1 &gt; number2) ? number1 : number2;\n    for (i = max; i &lt;= number1 * number2; i += max)\n        if (i % number1 == 0 &amp;&amp; i % number2 == 0)\n            return i;\n    return number1 * number2;\n}\nint main()\n{\n    int x, y;\n    int n = 5;\n    while (n--) {\n        printf(\"enter two integers : \");\n        scanf(\"%d%d\", &amp;x, &amp;y);\n        printf(\"gcd = %d\\n\", obeb(x, y));\n        printf(\"lcm = %d\\n\", okek(x, y));\n    }\n    return 0;\n}\n</code></pre> The function defined below finds the greatest common divisor using the Euclidean algorithm: <pre><code>int obeb(int a, int b)\n{\n    int temp;\n    while (b) {\n        temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n</code></pre> The following program writes a function named <code>fact</code> that calculates the factorial value for an integer. The program should be compiled on a system where the <code>int</code> type is 4 bytes: <pre><code>#include &lt;stdio.h&gt;\nint fact(int number)\n{\n    int i;\n    int result = 1;\n    if (number == 0 || number == 1)\n        return 1;\n    for (i = 2; i &lt;= number; ++i)\n        result *= i;\n    return result;\n}\nint main()\n{\n    int k;\n    for (k = 0; k &lt; 14; ++k)\n        printf(\"%2d! = %-10d\\n\", k, fact(k));\n    return 0;\n}\n</code></pre> The number \\(e\\) is found below using a series summation with the <code>fact</code> function: <pre><code>#include &lt;stdio.h&gt;\nint fact(int);\nint main()\n{\n    int k;\n    double e = 0.;\n    for (k = 0; k &lt; 14; ++k)\n        e += 1. / fact(k);\n    printf(\"e = %lf\\n\", e);\n    return 0;\n}\n</code></pre> The following program writes a function named <code>isprime</code> that tests whether an integer passed to it is prime. The function returns a non-zero value if the number passed to it is prime, and 0 if it is not prime. In the <code>main</code> function written for testing purposes, the <code>isprime</code> function is called, and prime numbers less than 1000 are printed to the screen: <pre><code>#include &lt;stdio.h&gt;\nint isprime(int number)\n{\n    int k;\n    if (number == 0 || number == 1)\n        return 0;\n    if (number % 2 == 0)\n        return number == 2;\n    if (number % 3 == 0)\n        return number == 3;\n    if (number % 5 == 0)\n        return number == 5;\n    for (k = 7; k * k &lt;= number; k += 2)\n        if (number % k == 0)\n            return 0;\n    return 1;\n}\nint main()\n{\n    int k;\n    int prime_counter = 0;\n    for (k = 0; k &lt; 1000; ++k)\n        if (isprime(k)) {\n            if (prime_counter % 10 == 0 &amp;&amp; prime_counter)\n                putchar('\\n');\n            prime_counter++;\n            printf(\"%3d \", k);\n        }\n    return 0;\n}\n</code></pre> An integer that is equal to the sum of its divisors is called a perfect integer. For example, 6 and 28 are perfect integers. \\(1 + 2 + 3 = 6\\) \\(1 + 2 + 4 + 7 + 14 = 28\\) The following program searches for perfect numbers less than 10000. The found numbers are printed to the screen: <pre><code>#include &lt;stdio.h&gt;\nint is_perfect(int number);\nint main()\n{\n    int k;\n    for (k = 2; k &lt; 10000; ++k)\n        if (is_perfect(k))\n            printf(\"%d perfect\\n\", k);\n    return 0;\n}\nint is_perfect(int number)\n{\n    int i;\n    int total = 1;\n    for (i = 2; i &lt;= number / 2; ++i)\n        if (number % i == 0)\n            total += i;\n    return number == total;\n}\n</code></pre> The following program ensures that characters are continuously read from the keyboard, and the read characters are displayed on the screen. The program terminates when the characters \"xyz\" are entered consecutively: <pre><code>#include &lt;stdio.h&gt;\n// #include &lt;conio.h&gt; (Assuming getch() is available)\nint getch_mock() { return getchar(); } // Mock function for standard C environment\nint main()\n{\n    char ch;\n    int total = 0;\n    while (total &lt; 3) {\n        ch = getch_mock();\n        putchar(ch);\n        if (ch == 'x' &amp;&amp; total == 0)\n            total++;\n        else if (ch == 'y' &amp;&amp; total == 1)\n            total++;\n        else if (ch == 'z' &amp;&amp; total == 2)\n            total++;\n        else total = 0;\n    }\n    return 0;\n}\n</code></pre>"},{"location":"c/15_loop_statements/#nested-loops","title":"Nested Loops","text":"<p>A loop statement can form the body of another loop. Loops created in this manner are called nested loops. Compile and run the following program: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int i, k;\n    for (i = 0; i &lt; 5; ++i)\n        for (k = 0; k &lt; 10; ++k)\n            printf(\"(%d %d) \", i, k);\n    printf(\"\\n\\n(%d %d) \", i, k);\n    return 0;\n}\n</code></pre> The statement in the body of the outer <code>for</code> loop is another <code>for</code> loop. The inner <code>for</code> loop statement is executed as long as the expression \\(i &lt; 5\\) is true. What values does the last <code>printf</code> call print to the screen? Since the outer loop iterates with the condition \\(i &lt; 5\\), the value of the variable \\(i\\) after exiting the outer loop is 5. After the inner <code>for</code> loop statement is executed for the last time, the value of the variable \\(k\\) also becomes 10. In this case, the very last <code>printf</code> call prints (5 10) to the screen. <p>Now, try to find out what the <code>put_stars</code> function, whose code is given below, does: </p><pre><code>#include &lt;stdio.h&gt;\nvoid put_stars(int n)\n{\n    int i, k;\n    for (i = 1; i &lt;= n; ++i) {\n        for (k = 1; k &lt;= i; ++k)\n            putchar('*');\n        putchar('\\n');\n    }\n}\nint main()\n{\n    int val;\n    printf(\"enter a value : \");\n    scanf(\"%d\", &amp;val);\n    put_stars(val);\n    return 0;\n}\n</code></pre> The following program prints the 3-digit numbers that satisfy the equality \\(abc = a^3 + b^3 + c^3\\) to the screen. <pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int i, j, k;\n    int number = 100;\n    for (i = 1; i &lt;= 9; ++i)\n        for (j = 0; j &lt;= 9; ++j)\n            for (k = 0; k &lt;= 9; ++k) {\n                if (i * i * i + j * j * j + k * k * k == number)\n                    printf(\"%d\\n\", number);\n                number++;\n            }\n    return 0;\n}\n</code></pre>"},{"location":"c/15_loop_statements/#use-of-the-break-statement-in-nested-loops","title":"Use of the <code>break</code> Statement in Nested Loops","text":"<p>Care must be taken when using the <code>break</code> statement in nested loops. Using the <code>break</code> statement in the body of an inner loop only exits the innermost loop: Examine the following example: </p><pre><code>while (1) {\n    while (1) {\n        if (expression)\n            break;\n        /***/\n    }\n    /* flow comes to this point when inner loop is exited with break */\n}\n</code></pre> If it is desired to exit all nested loops, not just the innermost one, the <code>goto</code> control statement should be used. You will see this topic in the section on the <code>goto</code> control statement. <p>Since the second <code>while</code> loop here will be treated as a single control statement, blocking (braces) is not necessary.</p>"},{"location":"c/15_loop_statements/#ways-to-exit-loops","title":"Ways to Exit Loops","text":"<p>How can a loop be exited? One of the following ways can be used to exit a loop.</p> <ol> <li>By the control expression being false:     You know that loop statements iterate as long as their control expressions are true.</li> <li>With the <code>return</code> statement:     Since the <code>return</code> statement inside a function terminates the function, the loop is exited when a <code>return</code> statement is encountered inside a loop statement.</li> <li>With the <code>break</code> statement:     With the use of the <code>break</code> statement, the program flow continues with the first statement following the loop statement.</li> <li>With the <code>goto</code> statement:     The <code>goto</code> statement can redirect the program flow within the same function to another point outside the loop. Thus, the loop can be exited.</li> <li>With a function call that terminates the program:     The program itself can be terminated with the standard <code>exit</code> or <code>abort</code> functions.</li> </ol> <p>Assigning a value to the loop variable in an unnatural way to make the control expression false for the purpose of exiting a loop impairs program readability. Such code should be avoided.</p>"},{"location":"c/16_ternary_operator/","title":"Ternary Operator","text":""},{"location":"c/16_ternary_operator/#the-conditional-operator-ternary-operator","title":"The Conditional Operator (Ternary Operator)","text":"<p>The conditional operator (ternary operator) is the only ternary operator in the C language. Any expression can be one of the operands of the conditional operator. The general syntax of the conditional operator is as follows: </p><pre><code>    expression1 ? expression2 : expression3\n</code></pre> The conditional operator, as seen from the syntax above, consists of two separate tokens. The <code>?</code> and <code>:</code> tokens separate the operator's three operands. <p>The compiler recognizes a conditional operator from the <code>?</code> token. The numerical value of the expression to the left of the <code>?</code> token (expression1) is calculated. This expression is interpreted logically. If the value of <code>expression1</code> is non-zero (true), then only the numerical value of expression2 is calculated. If the value of <code>expression1</code> is 0 (false), then only the numerical value of expression3 is calculated.</p> <p>Like other operators, the conditional operator also produces a value. The value produced by the conditional operator is the value of <code>expression2</code> if <code>expression1</code> is true (non-zero), and the value of <code>expression3</code> if <code>expression1</code> is false. Example:</p> <pre><code>m = x &gt; 3 ? y + 5 : y \u2013 5;\n</code></pre> <p>Here, the numerical value of the expression \\(x &gt; 3\\) is calculated first. If the value of this expression is non-zero (true), the conditional operator produces the value \\(y + 5\\). If the value of the expression \\(x &gt; 3\\) is 0 (false), the conditional operator produces the value \\(y \u2013 5\\). In this case, the value \\(y + 5\\) or \\(y \u2013 5\\) is assigned to the variable \\(m\\), depending on whether the expression \\(x &gt; 3\\) is true or false.</p> <p>The same operation can also be done with an <code>if</code> statement: </p><pre><code>if (x &gt; 3)\n    m = y + 5;\nelse\n    m = y \u2013 5;\n</code></pre> The conditional operator is at the 13th precedence level of the operator precedence table. This level is immediately above the assignment operator. Let's consider the following expression: <pre><code>x &gt; 3 ? y + 5 : y \u2013 5 = m\n</code></pre> <p>Since the precedence of the conditional operator is higher than the assignment operator, the conditional operator is evaluated first. Assume that the expression \\(x &gt; 3\\) is true and the operator produces the value \\(y + 5\\).</p> <pre><code>y + 5 = m\n</code></pre> <p>Since the value produced by the conditional operator is not an Lvalue (an object), the expression above is invalid.</p> <p>It is usually not necessary to enclose the first operand of the conditional operator in parentheses. However, it is generally preferred to enclose this operand in parentheses for readability: </p><pre><code>    (x &gt;= y + 3) ? a * a : b\n</code></pre> Care must be taken with the third operand of the conditional operator. For example: <pre><code>    m = a &gt; b ? 20 : 50 + 5\n</code></pre> Depending on whether the expression \\(a &gt; b\\) is true or false, the conditional operator produces the value 20 or 55, and finally, the value produced by the conditional operator is assigned to the variable \\(m\\). However, if it is desired that \\(m\\) be assigned the value produced by the expression \\(a &gt; b ? 20 : 50\\) plus 5, the expression must be structured as follows: <pre><code>m = (a &gt; b ? 20 : 50) + 5;\n</code></pre> <p>All three operands of the conditional operator can be function call expressions, but the called functions must be functions that produce a return value. A function call expression for a function whose return value is <code>void</code> as one of the three operands can create an invalid situation.</p> <p>Examine the following code snippet: </p><pre><code>    #include &lt;stdio.h&gt;\n    int func1(void);\n    int func2(void);\n    int func3(void);\n    int main()\n    {\n        int m;\n        m = func1() ? func2() : func3();\n        return 0;\n    }\n</code></pre> In the expression using the conditional operator above, the return value of the <code>func2</code> function is assigned to the variable \\(m\\) if the return value of the <code>func1</code> function is a non-zero value; otherwise, the return value of the <code>func3</code> function is assigned. <p>What the conditional operator produces is a value, not an object. Since the value produced by the conditional operator does not denote an object, an assignment cannot be made to this value. Examine the following <code>if</code> statement: </p><pre><code>    if (x &gt; y)\n        a = 5;\n    else\n        b = 5;\n</code></pre> In the <code>if</code> statement above, the value 5 is assigned to the variable \\(a\\) if the expression \\(x &gt; y\\) is true, and to the variable \\(b\\) if it is false. If the same task is performed using the conditional operator: <pre><code>    (x &gt; y) ? a : b = 5; /* Invalid! */\n</code></pre> This leads to a compile-time error. This is because what the conditional operator produces is the value of the variables \\(a\\) or \\(b\\), not the object itself. Such an assignment creates an error at compile time because the left side is not an Lvalue (an expression denoting an object). <p>For the same reason, the following expression is also invalid: </p><pre><code>    (x &gt; 5 ? y : z)++; /* Invalid! */\n</code></pre> What is obtained when the expression inside the parenthesis is evaluated is the values of the objects \\(y\\) or \\(z\\), not the objects themselves. That is, the operand of the postfix <code>++</code> operator is not an Lvalue.  <p>[In C++, if the 2nd or 3rd operand of the conditional operator is an Lvalue, the value produced by the operator is an Lvalue. Thus, the statements above, which are invalid in C, are valid in C++.]</p>"},{"location":"c/16_ternary_operator/#situations-where-the-conditional-operator-is-used","title":"Situations Where the Conditional Operator is Used","text":"<p>It is not always correct to use the conditional operator instead of the <code>if</code> statement. There are typical situations where the use of the conditional operator is recommended. In these situations, the general idea is to utilize the value produced by the conditional operator within the same expression and transfer this value somewhere:</p> <ol> <li> <p>The value produced by the conditional operator can be assigned to an object:</p> <ul> <li><code>p = (x == 5) ? 10 : 20;</code></li> <li><code>m = (a &gt;= b + 5) ? a + b : a \u2013 b;</code></li> </ul> <p><code>if</code> statements that would perform the job of the statements above could also be written:</p> <ul> <li><code>if (x == 5) p = 10; else p = 20;</code></li> <li><code>if (a &gt;= b + 5) m = a + b; else m = a - b;</code></li> </ul> </li> <li> <p>A function can return with the value produced by the conditional operator: </p><pre><code>return x &gt; y ? 10 : 20;\n</code></pre>     In this example, the function returns the value 10 or 20 depending on whether the expression \\(x &gt; y\\) is true or false. The following <code>if</code> statement could also be used instead of the expression above:     <pre><code>if (x &gt; y)\n    return 10;\nreturn 20;\n</code></pre> </li> <li>A function can be called with the value produced by the conditional operator: <pre><code>func(a == b ? x : y);\n</code></pre>     In the statement above, the <code>func</code> function is called with the value \\(x\\) if \\(a\\) is equal to \\(b\\), and with the value \\(y\\) if \\(a\\) is not equal to \\(b\\). An <code>if</code> statement performing the same task could also be written:     <pre><code>if (a == b)\n    func(x);\nelse\n    func(y);\n</code></pre></li> <li>The value produced by the conditional operator can also be used as part of the control expression of a control statement: <pre><code>if (y == (x &gt; 5 ? 10 : 20))\n    func();\n</code></pre>     In the statement above, the equality of the variable \\(y\\) to 10 or 20 is checked inside the <code>if</code> parenthesis, depending on whether the expression \\(x &gt; 5\\) is true or false.</li> </ol> <p>In the situations above, preferring the conditional operator over the <code>if</code> statement is good technique. In these cases, the conditional operator creates a more readable structure.</p> <p>The conditional operator should not be used carelessly. If the value produced by the conditional operator will not be utilized directly, the <code>if</code> control statement should be preferred over the conditional operator. For example:</p> <pre><code>x &gt; y ? a++ : b++;\n</code></pre> <p>The value produced by the conditional operator is not utilized in the statement. Here, the following <code>if</code> statement should be preferred: </p><pre><code>if (x &gt; y)\n    a++;\nelse\n    b++;\n</code></pre> Another example: <pre><code>x == y ? printf(\"equal\\n\") : printf(\"not equal\\n\");\n</code></pre> <p>In this example, the conditional operator is used by utilizing the fact that the <code>printf</code> function produces a return value. The conditional operator produces the return value of one of the <code>printf</code> function calls, which are the second or third operands, depending on whether the expression \\(x == y\\) is true or false. This is actually the number of characters written to the screen. But the value produced by the conditional operator is not used in the expression. Here too, the <code>if</code> statement should be preferred: </p><pre><code>if (x == y)\n    printf(\"equal\\n\");\nelse\n    printf(\"not equal\\n\");\n</code></pre> If the types of the second and third operands of the conditional operator are different, type conversion rules come into play, just as with other operators: <pre><code>int i;\ndouble d;\nm = (x == y) ? i : d;\n</code></pre> In this example, the variable \\(i\\) is of type <code>int</code>, and the variable \\(d\\) is of type <code>double</code>. If the comparison expression \\(x == y\\) is true, the type of the value produced by the conditional operator is <code>double</code>. <p>In some cases, neither the <code>if</code> statement nor the conditional operator needs to be used: </p><pre><code>if (x &gt; 5)\n    m = 1;\nelse\n    m = 0;\n</code></pre> The following statement could have been written instead of the <code>if</code> statement above: <pre><code>    m = (x &gt; 5) ? 1 : 0;\n</code></pre> In situations where the values produced by the conditional operator can only be 1 or 0, using the comparison operator directly should be considered better technique: <pre><code>    m = x &gt; 5;\n</code></pre> Another example: <pre><code>return x == y ? 1 : 0;\n</code></pre> could have been written instead of: <pre><code>return x == y;\n</code></pre> The associativity of the conditional operator is right-to-left. If there is more than one conditional operator in an expression, the rightmost one is evaluated first. Examine the following code snippet: <pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int x = 1, y = 1, m;\n    m = x &lt; 5 ? y == 0 ? 4 : 6 : 8;\n    printf(\"m = %d\\n\", m);\n    return 0;\n}\n</code></pre> In the <code>main</code> function above, the value 6 is printed to the screen as the value of the variable \\(m\\) by the <code>printf</code> function call. The expression is evaluated as follows: <pre><code>m = x &lt; 5 ? (y == 0 ? 4 : 6) : 8;\n</code></pre>"},{"location":"c/16_ternary_operator/#examples-of-conditional-operator-usage","title":"Examples of Conditional Operator Usage","text":"<p>Below is the function <code>max2</code> defined, which returns the larger of two numbers: </p><pre><code>int max2(int a, int b)\n{\n    return a &gt; b ? a : b;\n}\n</code></pre> The series \\(1 - \\frac{1}{3} + \\frac{1}{5} - \\frac{1}{7} + \\frac{1}{9} + \\dots\\) converges to \\(\\frac{\\pi}{4}\\). Below, the number \\(\\pi\\) is calculated using a loop. Examine the use of the conditional operator in the loop body: <pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    double sum = 0.;\n    int k;\n    for (k = 0; k &lt; 10000; ++k)\n        sum += (k % 2 ? -1. : 1.) / (2 * k + 1);\n    printf(\"pi = %lf\\n\", 4. * sum);\n    return 0;\n}\n</code></pre>"},{"location":"c/17_preprocessor_directives__1/","title":"Preprocessor Directives - 1","text":""},{"location":"c/17_preprocessor_directives__1/#preprocessor-directives-1","title":"Preprocessor Directives (1)","text":"<p>C compilers consist of two separate modules:</p> <ol> <li>Preprocessor Module</li> <li>Compilation Module</li> </ol> <p>The preprocessor has nothing to do with the computer's processor or any other hardware component. The preprocessor is a software program that performs a specific task.</p> <p>The preprocessor is a preliminary program that performs certain arrangements and changes on the source file. The preprocessor program has an input and an output. The input of the preprocessor is the source file itself. The output of the preprocessor program forms the input of the compilation module. That is, the source program is first processed by the preprocessor. The preprocessor module performs various textual arrangements and changes in the source file. Then, this modified or arranged source file is converted into object code by the compilation module.</p> <p>In the C programming language, all lines starting with <code>#</code> are directives given to the preprocessor program.</p> <p>The preprocessor program can perform operations from a predetermined set of commands. Each command is identified by a word following the <code>#</code> token. Below is a list of all preprocessor directives:</p> <ul> <li><code>#include</code></li> <li><code>#define</code></li> <li><code>#if</code></li> <li><code>#else</code></li> <li><code>#elif</code></li> <li><code>#ifdef</code></li> <li><code>#ifndef</code></li> <li><code>#endif</code></li> <li><code>#undef</code></li> <li><code>#line</code></li> <li><code>#error</code></li> <li><code>#pragma</code></li> </ul> <p>The words above that define the preprocessor directives are not C language keywords. By the time it is the compiler's turn, they have been deleted from the source file by the preprocessor. For example, a variable named <code>include</code> can be defined if desired, but it can be said that this is not a good idea in terms of readability. The words specifying the preprocessor directives only gain special meaning when they follow the <code>#</code> character.</p> <p>The preprocessor program does not perform any task aimed at generating object code; it performs some textual arrangements within the source code. After performing the directives given to it, it deletes the lines starting with <code>#</code> from the source file. The program entering the compilation module no longer contains lines starting with <code>#</code>.</p> <p>For now, you will only see the <code>#include</code> and <code>#define</code> directives. The remaining preprocessor directives will be covered in detail later.</p>"},{"location":"c/17_preprocessor_directives__1/#the-include-preprocessor-directive","title":"The <code>#include</code> Preprocessor Directive","text":"<p>The general syntax of the <code>#include</code> preprocessor directive is as follows: </p><pre><code>#include &lt;file name&gt;\n// or\n#include \"file name\"\n</code></pre> With the <code>#include</code> directive, the content of the file whose name is given is pasted into the place where this directive is written. With this directive, the preprocessor reads the specified file from the disk and places it where the directive is written. The job done with this directive can be likened to the \"copy \u2013 paste\" operation in text editor programs. <p>The file name to be included in the source file with the <code>#include</code> preprocessor directive can be specified in two separate ways:</p> <ol> <li>In angle brackets:<ul> <li><code>#include &lt;stdio.h&gt;</code></li> <li><code>#include &lt;time.h&gt;</code></li> </ul> </li> <li>In double quotes:<ul> <li><code>#include \"general.h\"</code></li> <li><code>#include \"genetic.h\"</code></li> </ul> </li> </ol> <p>If the file name is given in angle brackets, the file in question is searched for by the preprocessor only within a predefined directory. This predefined directory may vary depending on the compiler used and the system setup. For example: </p><pre><code>    \\tc\\include\n    \\borland\\include\n    \\c600\\include\n    // and similarly for UNIX systems:\n    /usr/include\n</code></pre> Standard header files are included in the source code within angle brackets. <p>In most systems, when the file name is written within double quotes, the preprocessor first searches for the relevant file in the current directory. If it is not found there, it searches in the system-defined directory. For example, let's assume we are working in the directory: </p><pre><code>    C:\\sample\n</code></pre> With the directive <code>#include \"strfunc.h\"</code>, the preprocessor first searches for the file <code>strfunc.h</code> in the <code>C:\\sample</code> directory. If it cannot find it there, it searches in the system-defined directory. Header files created by programmers themselves are usually included in the source code within double quotes, as they are not located in the system's directory. <p>The file name to be included in the source code with the <code>#include</code> preprocessor directive can also include the file path: </p><pre><code>#include &lt;sys\\stat.h&gt;\n#include \"c:\\headers\\myheader.h\"\n</code></pre> The <code>#include</code> directive can be found anywhere in the source program. However, the best place for files containing various declarations, such as standard header files, is undoubtedly at the very top of the program. <p>The <code>#include</code> directive can also be found in a nested form. For example, the following method can be used to include a large number of files in the source code:</p> <code>main.c</code> <code>project.h</code> <code>#include \"project.h\"</code> <code>#include &lt;stdio.h&gt;</code> <code>int main()</code> <code>#include &lt;conio.h&gt;</code> <code>{ /*...*/ }</code> <code>#include &lt;stdlib.h&gt;</code> <code>#include &lt;time.h&gt;</code> <p>Only the <code>project.h</code> file is included in the <code>main.c</code> file. After the preprocessor includes this file in the source code, it continues from this file.</p>"},{"location":"c/17_preprocessor_directives__1/#why-are-header-files-used","title":"Why are Header Files Used?","text":"<p>Especially large programs are written in separate parts called modules. The purpose of some of these modules is to provide services to other modules. In C and C++ languages, general service codes (server codes) are generally written as two separate files. Function definitions and global variable definitions are located in the file with the <code>.c</code> extension. This file is called the implementation file. Declarations concerning the codes that will receive the service (client codes) are kept in another file. This file is called the header file. A header file is the interface of a module. The module establishes its relationship with the outside world through its interface.</p> <p>User codes that will benefit from the provided services do not see the service-providing codes themselves, only their interface. Client codes are written dependent on the interfaces of the server codes. Thus, the server codes themselves and their interfaces are clearly separated from each other.</p> <p>What are the benefits of separating the definitions of the server codes from their interfaces?</p> <p>User codes, i.e., client codes, are written dependent on the function interfaces, not their definitions. The following benefits can be obtained from this:</p> <ol> <li>Those who write the server codes can make changes to the definition codes, provided they stick to the same interface. In this case, no changes are required in the client codes.</li> <li>The programmer writing the user codes performs easier abstraction because they do not have to know the implementation details of the server codes.</li> <li>The project development time is shortened if more than one programmer works on the same project.</li> </ol>"},{"location":"c/17_preprocessor_directives__1/#the-define-preprocessor-directive","title":"The <code>#define</code> Preprocessor Directive","text":"<p>The function of the <code>#define</code> preprocessor directive can be likened to the \"find - replace\" feature in text editor programs. This directive is used to replace a text in the source code with another text.</p> <p>The preprocessor obtains the first non-space sequence of characters after skipping the spaces following the <code>define</code> word. Let's call this sequence STR1. Then, the entire sequence of characters until the end of the line is obtained. Let's call this STR2. The preprocessor places the text STR2 instead of the text STR1 in the source code: </p><pre><code>#define SIZE 100\n</code></pre> With the preprocessor directive, the preprocessor replaces every <code>SIZE</code> token it sees in the source code with the token <code>100</code>. The <code>SIZE</code> token is no longer present in the source program entering the compilation module. <p>The <code>#define</code> preprocessor directive is most often used to replace a name with a numerical value. A name replaced by a numerical value is called a \"symbolic constant.\" Symbolic constants are not objects. In the source code entering the compilation module, symbolic constants are replaced by numerical expressions.</p> <p>Names defined with the <code>#define</code> preprocessor directive are also called \"simple macros.\"</p> <p>Symbolic constants are conventionally named with uppercase letters. This allows the reader of the code to distinguish between variables and symbolic constants. As is known, predominantly lowercase letters are used for variable naming in the C language.</p> <p>A symbolic constant can be used in the definition of another symbolic constant. For example: </p><pre><code>#define MAX 100\n#define MIN (MAX - 50)\n</code></pre> The replacement operation is performed if STR1 is found as a token in the source code: <pre><code>#define SIZE 100\n</code></pre> Assume that the source code contains statements such as: <pre><code>size = MAX_SIZE;\nprintf(\"SIZE = %d\\n\", size);\n</code></pre> The preprocessor does not make any changes to these statements. <p>In the expression <code>size = MAX_SIZE</code>, <code>SIZE</code> is not a separate token; the token is <code>MAX_SIZE</code>. Since the replacement is case-sensitive, the name <code>size</code> in the source code is also not the token to be replaced.</p> <p>In the expression <code>printf(\"SIZE = %d\\n\", max_size)</code>, the token is the string literal. That is, <code>SIZE</code> inside the string literal is not a separate token on its own.</p> <p>The <code>#define</code> preprocessor directive cannot be used to perform a replacement operation for literals and operators. The following <code>#define</code> preprocessor directives are invalid: </p><pre><code>#define + -\n#define 100 200\n</code></pre> Symbolic constants must be named according to the C language's variable naming rules: <pre><code>#define B\u00dcY\u00dcK 10 // Invalid in standard C/English environment\n</code></pre> The preprocessor program also executes the preprocessor directives inside the file included in the source code with the <code>#include</code> directive. In this case, when a file containing symbolic constant definitions is included in the source code with the <code>#include</code> directive, these symbolic constants become valid as if they were defined within the source code. <p>Strings can also be used in the <code>#define</code> preprocessor directive: </p><pre><code>#define ERROR_MESSAGE \"FILE CANNOT BE OPENED \\n\"\n/***/\nprintf(HATA_MESAJI);\n/***/\n</code></pre> If the string to be used in the symbolic constant definition is long, it can be placed on multiple lines to facilitate code readability. In this case, the <code>\\</code> token must be placed at the end of all lines except the last one. <p>For readability, all symbolic constant definitions should be written consecutively one below the other. The chosen symbolic constant names should give the person reading the code an idea of their purpose.</p> <p>Defining a symbolic constant does not necessitate the existence of information that can be replaced in the source code. Not using a defined symbolic constant in the source code does not lead to any errors.</p>"},{"location":"c/17_preprocessor_directives__1/#symbolic-constants-make-code-more-readable","title":"Symbolic Constants Make Code More Readable","text":"<p>Symbolic constants increase the readability and comprehensibility of the written code. Giving names to some literals can provide more information about the purpose for which these literals are used. Let's look at the example below: </p><pre><code>#define PERSONNEL_COUNT 750\n\nvoid foo()\n{\n    /***/\n    if (x == PERSONNEL_SAYISI) // PERSONNEL_SAYISI is PERSONEL_SAYISI in Turkish text\n    /***/\n}\n</code></pre> If the literal value 750 had been used directly instead of the <code>PERSONNEL_COUNT</code> symbolic constant in the source code, it would be much more difficult for the reader of the code to deduce what this literal means, wouldn't it?"},{"location":"c/17_preprocessor_directives__1/#naming-types-with-symbolic-constants","title":"Naming Types with Symbolic Constants","text":"<p>The <code>#define</code> preprocessor directive can also be used to give names to C's native data types: </p><pre><code>#define BYTE char\n#define BOOL int\n\nBYTE foo(BYTE b);\nBOOL isprime(int val);\n</code></pre> You know that the <code>char</code> type is actually a 1-byte integer type. The use of the name <code>char</code> often gives the impression that a task related to text or characters is being performed. However, functions that perform general operations on memory blocks also often use the <code>char</code> type. In this case, a name like <code>BYTE</code> can be used to give more idea about the operation being performed. You recall that the <code>BOOL</code> type does not exist in C (historically). The <code>int</code> type is used as a logical data type instead of the <code>bool</code> data type in C. However, the name <code>BOOL</code> can be used with the <code>#define</code> preprocessor directive to increase program readability. <p>We will later address the <code>typedef</code> keyword and the definition of new type names as an alternative to this usage.</p>"},{"location":"c/17_preprocessor_directives__1/#functions-returning-with-symbolic-constants","title":"Functions Returning with Symbolic Constants","text":"<p>Another usage aimed at increasing readability is for the return values of functions. You know that the return values of some functions answer a question, and the return values of some functions give an idea about the success of an operation. Such functions can be better in terms of readability if they use symbolic constants instead of return value expressions: </p><pre><code>return VALID;\nreturn INVALID;\nreturn TRUE;\nreturn FALSE;\nreturn FAILED;\n</code></pre> and so on."},{"location":"c/17_preprocessor_directives__1/#calling-functions-with-symbolic-constants","title":"Calling Functions with Symbolic Constants","text":"<p>Symbolic constants are also sent to some functions by the calling code snippet.</p> <p>Some symbolic constants are also defined for this purpose in C's standard header files. For example, in the <code>stdlib.h</code> header file, there are definitions in the form: </p><pre><code>#define EXIT_FAILURE 1\n#define EXIT_SUCCESS 0\n</code></pre> That is, if the <code>stdlib.h</code> header file is included in the source code, the <code>EXIT_FAILURE</code> symbolic constant can be used instead of 1, and the <code>EXIT_SUCCESS</code> symbolic constant can be used instead of 0. These symbolic constants are used in calls to the standard <code>exit</code> function: <pre><code>exit(EXIT_FAILURE);\n</code></pre> In the <code>stdio.h</code> header file, three symbolic constants are defined for the purpose of being sent as arguments to the standard <code>fseek</code> function: <pre><code>#define SEEK_SET 0\n#define SEEK_CUR 1\n#define SEEK_END 2\n</code></pre>"},{"location":"c/17_preprocessor_directives__1/#flag-variables-taking-their-values-with-symbolic-constants","title":"Flag Variables Taking Their Values with Symbolic Constants","text":"<p>In C programs, flag variables also often take their values with symbolic constants: </p><pre><code>pos_flag = ON;\nvalidity_flag = INVALID;\n</code></pre> The <code>case</code> expressions in the <code>switch</code> control statement are also often formed with symbolic constants. We will examine this topic in the <code>switch</code> control statement section."},{"location":"c/17_preprocessor_directives__1/#modifying-the-program-via-symbolic-constants","title":"Modifying the Program via Symbolic Constants","text":"<p>In situations where a literal is used in many places within the program, a replacement operation for this literal can be done from a single location. Thus, the program in question can be written dependent on a symbolic constant, and then recompiled and run for different parametric values by changing the symbolic constant. For example, let's assume we are writing a game program based on the user guessing a number with a specific number of guesses. Let the player have 10 guesses. In this case, the value 10 is used in many places in the source code, right? Suppose it is later desired to increase the player's number of guesses to 20 in the game program. The literals 10, which represent the player's number of guesses, must be changed to 20 in the source code. Performing this replacement operation individually by the programmer is both difficult and error-prone. Not every literal 10 used in the source code may represent the player's guess limit. However, if a symbolic constant is defined instead of the value representing the player's limit: </p><pre><code>#define NO_OF_GUESS 10\n</code></pre> and the program is written using this symbolic constant, the values 10 throughout the entire program can be easily converted to the value 20 by making a change in this symbolic constant definition."},{"location":"c/17_preprocessor_directives__1/#symbolic-constants-used-instead-of-floating-point-literals","title":"Symbolic Constants Used Instead of Floating-Point Literals","text":"<p>The use of symbolic constants prevents possible inconsistencies and typographical errors, especially when using floating-point literals.</p> <p>For example, let's assume that the number \\(\\pi\\) is frequently used in a program that performs mathematical calculations. The symbolic constant: </p><pre><code>#define PI 3.14159\n</code></pre> can be used instead of the number \\(\\pi\\). If the number \\(\\pi\\) is written as a literal each time, the same value may not be written each time. For example, while the literal \\(3.14159\\) is written in one place in the source code, a value like \\(3.15159\\) might be accidentally written at another point in the source code. The compiler program has no mechanism to issue a logical warning message for such inconsistencies. The use of symbolic constants eliminates such errors. <p>Most compilers also define many mathematical constants in the <code>math.h</code> header file.</p>"},{"location":"c/17_preprocessor_directives__1/#symbolic-constants-defined-for-portability-purposes","title":"Symbolic Constants Defined for Portability Purposes","text":"<p>Some symbolic constants are defined both to provide portability and to create a common interface. Standard symbolic constants carrying the boundary values of the integer types used on the system are defined in the <code>limits.h</code> standard header file:</p> Symbolic Constant Smallest/Largest Possible Value Meaning <code>CHAR_BIT</code> 8 Number of bits in the <code>char</code> type <code>SCHAR_MIN</code> -127 Smallest value of <code>signed char</code> type <code>SCHAR_MAX</code> 127 Largest value of <code>signed char</code> type <code>UCHAR_MAX</code> 255 Largest value of <code>unsigned char</code> type <code>SHRT_MIN</code> -32,767 Smallest value of <code>signed short int</code> type <code>SHRT_MAX</code> 32,767 Largest value of <code>signed short int</code> type <code>USHRT_MAX</code> 65,535 Largest value of <code>unsigned short</code> type <code>INT_MIN</code> -32,767 (varies) Smallest value of <code>signed int</code> type <code>INT_MAX</code> 32,767 (varies) Largest value of <code>signed int</code> type <code>UINT_MAX</code> 65,535 (varies) Largest value of <code>unsigned int</code> type <code>LONG_MIN</code> -2,147,483,648 Smallest value of <code>signed long int</code> type <code>LONG_MAX</code> 2,147,483,647 Largest value of <code>signed long int</code> type <code>ULONG_MAX</code> 4,294,967,295 Largest value of <code>unsigned long int</code> type <code>LLONG_MIN</code> -9,233,372,036,854,775,808 Smallest value of <code>signed long long int</code> type (C99) <code>LLONG_MAX</code> 9,233,372,036,854,775,807 Largest value of <code>signed long long int</code> type (C99) <code>ULLONG_MAX</code> 18,446,744,073,709,551,615 Largest value of <code>unsigned long long int</code> type (C99) <code>CHAR_MIN</code> <code>SCHAR_MIN</code> or 0 Smallest value of <code>char</code> type. If system's <code>char</code> is signed, value is <code>SCHAR_MIN</code>. If unsigned, value is 0. <code>CHAR_MAX</code> <code>SCHAR_MAX</code> or <code>UCHAR_MAX</code> Largest value of <code>char</code> type. If system's <code>char</code> is signed, value is <code>SCHAR_MAX</code>. If unsigned, value is <code>UCHAR_MAX</code>. <code>MB_LEN_MAX</code> 1 Maximum number of bytes a multi-byte character can have. (In locales where this type is supported)"},{"location":"c/17_preprocessor_directives__1/#locations-of-symbolic-constant-definitions","title":"Locations of Symbolic Constant Definitions","text":"<p>The <code>#define</code> directive can be used anywhere in the source code. However, it is effective in the region from where it is defined until the end of the source code. The preprocessor program does not have a concept of scope directly. A symbolic constant defined at the beginning of a block is effective not only within that block but everywhere from where it is defined until the end of the source code.</p> <p>Symbolic constants are sometimes defined inside the header file and sometimes inside the source file.</p>"},{"location":"c/17_preprocessor_directives__1/#common-mistakes-in-using-symbolic-constants","title":"Common Mistakes in Using Symbolic Constants","text":"<p>A typical mistake is using the equals sign (<code>=</code>) unnecessarily in the symbolic constant definition: </p><pre><code>#define N = 100\n</code></pre> In this case, the preprocessor pastes the text: <pre><code>= 100\n</code></pre> <p>where it sees <code>N</code>. For example, let's assume a definition like: </p><pre><code>int a[N];\n</code></pre> is made. The preprocessor converts this definition to: <pre><code>int a[= 100];\n</code></pre> which is invalid. <p>Another typical mistake is accidentally terminating the <code>#define</code> preprocessor directive line with a semicolon (<code>;</code>): </p><pre><code>#define N 100;\n</code></pre> In this case, the preprocessor places: <pre><code>100;\n</code></pre> <p>where it sees <code>N</code>. The definition: </p><pre><code>int a[N];\n</code></pre> becomes: <pre><code>int a[100;];\n</code></pre> This definition is invalid. In such errors, the compiler usually issues as many error messages as the symbolic constant is used. <p>Care must be taken when defining symbolic constants. It must be remembered that the preprocessor module does not perform any arithmetic operations, but only a textual replacement: </p><pre><code>#define MAX 10 + 20\nint main()\n{\n    int result;\n    result = MAX * 2;\n    printf(\"%d\\n\", result);\n    return 0;\n}\n</code></pre> In the example above, the value 50 is assigned to the variable <code>result</code>, not 60. However, if the preprocessor directive had been written as: <pre><code>#define MAX (10 + 20)\n</code></pre> the value 60 would have been assigned to the variable <code>result</code>."},{"location":"c/17_preprocessor_directives__1/#simple-macros-for-standard-c-operators","title":"Simple Macros for Standard C Operators","text":"<p>Since some character sets, such as ISO 646, in which the source text is written do not have the characters <code>&amp;</code>, <code>|</code>, and <code>^</code>, problems arise in writing some C operators.</p> <p>In the <code>iso646</code> header file, which was later added to the language by an addition to the C89 standards, simple macros that are converted to some standard C operators are defined. Below is a list of these macros:</p> Macro Replacement <code>#define and</code> <code>&amp;&amp;</code> <code>#define and_eq</code> <code>&amp;=</code> <code>#define bitand</code> <code>&amp;</code> <code>#define bitor</code> <code>|</code> <code>#define compl</code> <code>~</code> <code>#define not</code> <code>!</code> <code>#define not_eq</code> <code>!=</code> <code>#define or</code> <code>||</code> <code>#define or_eq</code> <code>|=</code> <code>#define xor</code> <code>^</code> <code>#define xor_eq</code> <code>^=</code>"},{"location":"c/18_switch_statement/","title":"Switch Statement","text":""},{"location":"c/18_switch_statement/#the-switch-statement","title":"The <code>switch</code> Statement","text":"<p>The <code>switch</code> statement is used to perform different tasks for different values of an integer expression. The <code>switch</code> statement provides an alternative to <code>else if</code> ladders in terms of readability.</p> <p>The general form of the statement is as follows: </p><pre><code>switch (expression) {\ncase expression1 :\ncase expression2 :\ncase expression3 :\n.......\ncase expression_n:\ndefault:\n}\n</code></pre> <code>switch</code>, <code>case</code>, and <code>default</code> are keywords in the C language."},{"location":"c/18_switch_statement/#execution-of-the-switch-statement","title":"Execution of the <code>switch</code> Statement","text":"<p>The numerical value of the expression inside the <code>switch</code> parenthesis is calculated. It is tested from top to bottom whether a <code>case</code> expression with a value equal to this numerical value exists. If such a <code>case</code> expression is found, the program flow is transferred to that <code>case</code> label. The program then proceeds by falling through from this point. If the numerical value of the expression inside the <code>switch</code> parenthesis is not equal to any <code>case</code> expression, the flow is transferred to the part where the <code>default</code> keyword is located, if it exists. </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int a;\n    printf(\"enter a number : \");\n    scanf(\"%d\", &amp;a);\n    switch (a) {\n        case 1: printf(\"one\\n\");\n        case 2: printf(\"two\\n\");\n        case 3: printf(\"three\\n\");\n        case 4: printf(\"four\\n\");\n        case 5: printf(\"five\\n\");\n    }\n    return 0;\n}\n</code></pre> In the example above, suppose the value 1 is read into the variable <code>a</code> from the keyboard using the <code>scanf</code> function. The program's screen output will be as follows: <pre><code>one\ntwo\nthree\nfour\nfive\n</code></pre> If it is desired that only the statement(s) corresponding to the matching <code>case</code> expression be executed, the <code>break</code> statement is used. With the use of the <code>break</code> statement, the <code>switch</code> statement is exited, just like loops. <code>break</code> statements are added to the previously given example: <pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int a;\n    printf(\"enter a number: \");\n    scanf(\"%d\", &amp;a);\n    switch (a) {\n        case 1 : printf(\"one\\n\"); break;\n        case 2 : printf(\"two\\n\"); break;\n        case 3 : printf(\"three\\n\"); break;\n        case 4 : printf(\"four\\n\"); break;\n        case 5 : printf(\"five\\n\");\n    }\n    return 0;\n}\n</code></pre> In applications, a <code>break</code> statement is generally used for every <code>case</code> expression in a <code>switch</code> statement. Of course, there is no such requirement. <p>Any number of statements can follow the <code>:</code> token that follows the <code>case</code> expressions. There is no need to block these statements if more than one statement follows a <code>case</code> expression. That is, all statements following a <code>case</code> expression are treated as if they were inside a block.</p> <p>There is no requirement for <code>case</code> expressions to follow a specific order.</p>"},{"location":"c/18_switch_statement/#the-default-case","title":"The <code>default</code> Case","text":"<p><code>default</code> is a keyword. The <code>default</code> keyword placed in the <code>switch</code> statement body is followed by the <code>:</code> token. This constructed <code>case</code> is called the default case.</p> <p>If an equivalent <code>case</code> expression is not found, the program flow enters the default case.</p> <p>A default case is added to the previously written <code>switch</code> statement: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int a;\n    printf(\"enter a number: \");\n    scanf(\"%d\", &amp;a);\n    switch (a) {\n        case 1 : printf(\"one\\n\"); break;\n        case 2 : printf(\"two\\n\"); break;\n        case 3 : printf(\"three\\n\"); break;\n        case 4 : printf(\"four\\n\"); break;\n        case 5 : printf(\"five\\n\"); break;\n        default: printf(\"none\\n\");\n    }\n    return 0;\n}\n</code></pre> As explained above, all <code>case</code> expressions are tested sequentially in the compilation direction, i.e., from top to bottom, until a <code>case</code> expression equal to the numerical value of the expression inside the <code>switch</code> parenthesis is found. If there is available information about the frequency or probability of <code>case</code> expressions, writing the <code>case</code> expressions with higher probability or frequency earlier can reduce the number of unnecessary comparisons. <p><code>case</code> expressions must be constant expressions of an integral type. As is known, constant expressions can be converted to definite numerical values by the compiler during the compilation phase: </p><pre><code>    case 1 + 3: /* Valid */\n</code></pre> is possible because \\(1 + 3\\) is a constant expression, but: <pre><code>    case x + 5: /* Invalid */\n</code></pre> is not possible because it is not a constant expression. The compiler cannot calculate a numerical value during the compilation phase. <pre><code>    case 'a' :\n</code></pre> The <code>case</code> expression above is valid. 'a' is a character literal. The <code>case</code> expression is a constant expression of an integer type. <pre><code>    case 3.5 :\n</code></pre> The <code>case</code> expression above is invalid. 3.5 is a floating-point literal. <p>An <code>else if</code> ladder can be written instead of the <code>switch</code> control statement. That is, if there were no <code>switch</code> statement, the desired task could also be performed with an <code>else if</code> ladder. However, using the <code>switch</code> statement instead of an <code>else if</code> ladder increases readability in some situations. For example: </p><pre><code>if (a == 1)\n    statement1;\nelse if (a == 2)\n    statement2;\nelse if (a == 3)\n    statement3;\nelse if (a == 4)\n    statement4;\nelse\n    statement5;\n</code></pre> The <code>else if</code> ladder above is functionally equivalent to the following <code>switch</code> statement: <pre><code>switch (a) {\n    case 1 : statement1; break;\n    case 2 : statement2; break;\n    case 3 : statement3; break;\n    case 4 : statement4; break;\n    default: statement5;\n}\n</code></pre> An <code>else if</code> ladder can be written to perform the same task as every <code>switch</code> statement, but not every <code>else if</code> ladder can be replaced by a <code>switch</code> statement. The expression inside the <code>switch</code> parenthesis must be of an integral type. The <code>case</code> expressions must also be constant expressions of integral types. The <code>switch</code> statement is used to test the equality of an expression of an integral type to different integer values and to perform different tasks in case of equality. However, any kind of comparison can be involved in an <code>else if</code> ladder. Example: <pre><code>if (x &gt; 20)\n    m = 5;\nelse if (x &gt; 30 &amp;&amp; x &lt; 55)\n    m = 3;\nelse if (x &gt; 70 &amp;&amp; x &lt; 90)\n    m = 7;\nelse\n    m = 2;\n</code></pre> A <code>switch</code> statement cannot be written instead of the <code>else if</code> ladder above. <p>The <code>switch</code> statement, in some cases, forms a much more readable structure than the <code>else if</code> ladder; that is, the use of the <code>switch</code> statement, above all, makes the code easier to read and understand.</p> <p>The same operations for multiple <code>case</code> expressions can be achieved as follows: </p><pre><code>case 1:\ncase 2:\ncase 3:\n    statement1;\n    statement2;\n    break;\ncase 4:\n</code></pre> There is no shorter way to do this. Some programmers arrange the source code layout as follows: <pre><code>    case 1: case 2: case 3: case 4: case 5:\n        statement1; statement2;\n</code></pre> Examine the following program first, then compile and run it: <pre><code>void print_season(int month)\n{\n    switch (month) {\n        case 12:\n        case 1 :\n        case 2 : printf(\"winter\"); break;\n        case 3 :\n        case 4 :\n        case 5 : printf(\"spring\"); break;\n        case 6 :\n        case 7 :\n        case 8 : printf(\"summer\"); break;\n        case 9 :\n        case 10:\n        case 11: printf(\"autumn\");\n    }\n}\n</code></pre> The <code>print_season</code> function takes the sequence number of a month, i.e., the information of which month of the year it is, and prints the name of the season the month is in to the screen. How could the same task be done with an <code>else if</code> ladder? The logical OR operator could be used in the conditional expression of each <code>if</code> statement: <pre><code>void print_season(int month)\n{\n    if (month == 12 || month == 1 || month == 2)\n        printf(\"winter\");\n    else if (month == 3 || month == 4 || month == 5)\n        printf(\"spring\");\n    else if (month == 6 || month == 7 || month == 8)\n        printf(\"summer\");\n    else if (month == 9 || month == 10 || month == 11)\n        printf(\"autumn\");\n}\n</code></pre> Since symbolic constants are replaced by the preprocessor before the compilation process, they can be included in <code>case</code> expressions: <pre><code>#define TRUE 1\n#define FALSE 0\n#define UNDEFINED 2\n\ncase TRUE :\ncase FALSE :\ncase UNDEFINED :\n</code></pre> The <code>case</code> expressions above are valid. <p>Character literals can also be used as <code>case</code> expressions: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    switch (getchar()) {\n        case '0': printf(\"zero\\n\"); break;\n        case '1': printf(\"one\\n\"); break;\n        case '2': printf(\"two\\n\"); break;\n        case '3': printf(\"three\\n\"); break;\n        case '4': printf(\"four\\n\"); break;\n        case '5': printf(\"five\\n\"); break;\n        default : printf(\"invalid!\\n\");\n    }\n    return 0;\n}\n</code></pre> The readability of the code is weakened if the statements following the <code>case</code> expressions are longer than 15-20 lines. In this case, converting the operations to function calls is a good technique. <pre><code>switch (x) {\n    case ADDREC:\n        addrec();\n        break;\n    case DELREC:\n        delrec();\n        break;\n    case FINDREC:\n        findrec();\n        break;\n}\n</code></pre> In the example above, <code>ADDREC</code>, <code>DELREC</code>, and <code>FINDREC</code> used as <code>case</code> expressions are previously defined symbolic constants. The operations performed for each <code>case</code> are wrapped inside a function. <pre><code>char ch = getch();\nswitch (ch) {\n    case 'E' : statement1; break;\n    case 'H' : statement2; break;\n    default : statement3;\n}\n</code></pre> There cannot be more than one <code>case</code> expression with the same numerical value in a <code>switch</code> statement. This results in a compile-time error. <p>A <code>switch</code> statement can form the body of another <code>switch</code> statement or a loop statement:</p> <p></p><pre><code>#include &lt;stdio.h&gt;\n// #include &lt;conio.h&gt; (Assuming getch() is available)\n#include &lt;stdlib.h&gt; // for rand() and srand()\n#include &lt;time.h&gt; // for time()\n#define ESC 0x1B\nint getch_mock() { return getchar(); } // Mock function for standard C environment\nint main()\n{\n    int ch;\n    srand(time(NULL)); // Seed the random number generator\n    while ((ch = getch_mock()) != ESC)\n        switch (rand() % 7 + 1) {\n            case 1: printf(\"Monday\\n\"); break;\n            case 2: printf(\"Tuesday\\n\"); break;\n            case 3: printf(\"Wednesday\\n\"); break;\n            case 4: printf(\"Thursday\\n\"); break;\n            case 5: printf(\"Friday\\n\"); break;\n            case 6: printf(\"Saturday\\n\"); break;\n            case 7: printf(\"Sunday\\n\");\n        }\n    return 0;\n}\n</code></pre> In the <code>main</code> function above, the <code>switch</code> statement forms the body of the outer <code>while</code> loop. Since the <code>switch</code> statement is the only statement in the loop body, there is no need to block the outer <code>while</code> loop. However, blocking the <code>while</code> loop would not cause an error. But the <code>break</code> statement inside the <code>case</code> expressions only exits the <code>switch</code> statement. The <code>goto</code> statement can be used inside the <code>case</code> expression to exit the <code>while</code> loop as well. <p>Now, examine the following program. A function named <code>display_date</code> is defined in the program. The function prints a date information received as day, month, and year values in the following English format to the screen: </p><pre><code>#include &lt;stdio.h&gt;\nvoid display_date(int day, int month, int year)\n{\n    printf(\"%d\", day);\n    switch (day) {\n        case 1 :\n        case 21 :\n        case 31 : printf(\"st \"); break;\n        case 2 :\n        case 22 : printf(\"nd \"); break;\n        case 3 :\n        case 23 : printf(\"rd \"); break;\n        default : printf(\"th \");\n    }\n    switch (month) {\n        case 1 : printf(\"Jan \"); break;\n        case 2 : printf(\"Feb \"); break;\n        case 3 : printf(\"Mar \"); break;\n        case 4 : printf(\"Apr \"); break;\n        case 5 : printf(\"May \"); break;\n        case 6 : printf(\"Jun \"); break;\n        case 7 : printf(\"Jul \"); break;\n        case 8 : printf(\"Aug \"); break;\n        case 9 : printf(\"Sep \"); break;\n        case 10: printf(\"Oct \"); break;\n        case 11: printf(\"Nov \"); break;\n        case 12: printf(\"Dec \");\n    }\n    printf(\"%d\", year);\n}\nint main()\n{\n    int day, month, year;\n    int n = 20;\n    while (n-- &gt; 0) {\n        printf(\"enter date as day month year : \");\n        scanf(\"%d%d%d\", &amp;day, &amp;month, &amp;year);\n        display_date(day, month, year);\n        putchar('\\n');\n    }\n    return 0;\n}\n</code></pre> Two separate <code>switch</code> statements are used in the function's definition. The first <code>switch</code> statement prints the suffixes (th, st, nd, rd) following the day value, while the second <code>switch</code> statement prints the month abbreviations (Jan, Feb, Mar.). <p>One of the statements following the <code>case</code> expressions does not have to be a <code>break</code> statement. In some cases, the <code>break</code> statement is deliberately omitted, and it is specifically desired that the statements inside the following cases also be executed when an appropriate <code>case</code> expression is found. Compile and run the following program: </p><pre><code>#include &lt;stdio.h&gt;\nint isleap(int y)\n{\n    return y % 4 == 0 &amp;&amp; (y % 100 != 0 || y % 400 == 0);\n}\nint day_of_year(int day, int month, int year)\n{\n    int sum = day;\n    switch (month - 1) {\n        case 11: sum += 30;\n        case 10: sum += 31;\n        case 9 : sum += 30;\n        case 8 : sum += 31;\n        case 7 : sum += 31;\n        case 6 : sum += 30;\n        case 5 : sum += 31;\n        case 4 : sum += 30;\n        case 3 : sum += 31;\n        case 2 : sum += 28 + isleap(year);\n        case 1 : sum += 31;\n    }\n    return sum;\n}\nint main()\n{\n    int day, month, year;\n    int n = 5;\n    while (n-- &gt; 0) {\n        printf(\"enter date as day month year : \");\n        scanf(\"%d%d%d\", &amp;day, &amp;month, &amp;year);\n        printf(\"it is the %d. day of the year %d!\\n\", day_of_year(day, month,\n            year), year);\n    }\n    return 0;\n}\n</code></pre> The <code>day_of_year</code> function calculates which day of the relevant year the date information received as day, month, and year values corresponds to and returns this value. Examine the <code>switch</code> statement used in the function carefully. The value one less than the month value received from outside is used inside the <code>switch</code> parenthesis. No <code>break</code> statement is used inside any case. When an appropriate <code>case</code> expression is found, all the statements inside the cases located below it are also executed. Thus, the information of how many days each month lower than the month value received from outside has is added to the <code>sum</code> variable, which holds the total number of days."},{"location":"c/19_goto_statement/","title":"goto Statement","text":""},{"location":"c/19_goto_statement/#the-goto-statement","title":"The <code>goto</code> Statement","text":"<p>As in other programming languages, the program flow in the C language can be directed to another point in the source code unconditionally. This is done with the <code>goto</code> statement in C:</p> <p>The general syntax of the <code>goto</code> statement is as follows: </p><pre><code>    goto label;\n    ....\n    label:\n        statement;\n</code></pre> <code>goto</code> is one of the 32 keywords in the C language. A label is a name given by the programmer. It must, of course, be chosen in accordance with the naming rules. The program flow is directed to the point where this label is placed. The label can be placed anywhere within the function where the <code>goto</code> keyword is used. The <code>:</code> token must be placed after the label name. The statement following the label is also part of the <code>goto</code> control statement's syntax. The absence of a statement after the label is a syntax error. <p>There is no requirement for the label to be placed at a source code point later than the <code>goto</code> keyword. The label can also be defined before the <code>goto</code> keyword: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    /***/\n    goto JUMP;\n    /***/\nJUMP:\n    printf(\"arrived here with the goto statement\\n\");\n    return 0;\n}\n</code></pre> In the program above, the label is placed after the <code>goto</code> keyword. <pre><code>int main()\n{\nJUMP:\n    printf(\"point to be reached with the goto statement\\n\");\n    /***/\n    goto JUMP;\n    /***/\n    return 0;\n}\n</code></pre> In the program above, the label is placed before the <code>goto</code> keyword. <p><code>goto</code> labels are conventionally written in uppercase and aligned to the first column. This makes them stand out more in the source code.</p> <p><code>goto</code> labels can be placed anywhere before a statement within a function. That is, the label can be placed above or below the <code>goto</code> keyword, provided it is within the same function. With this feature, <code>goto</code> labels create a new scope rule. A name, no matter where it is defined within a function, is known everywhere within that function. This scope rule is called \"function scope.\"</p> <p><code>goto</code> labels are not added to the namespace of the block they are in. <code>goto</code> label names are evaluated in a separate namespace. A local variable can have the same name as a <code>goto</code> label within a block: </p><pre><code>void func()\n{\n    int x;\n    goto x; // Jumps to the label named 'x'\nx: // This is the label\n    x = 20; // This is the local variable 'x'\n}\n</code></pre> The use of the <code>goto</code> statement is not recommended in structured programming technique. This is because the use of the <code>goto</code> statement gives rise to some disadvantages: <ol> <li>The <code>goto</code> statement impairs program readability. When the person reading the code encounters a <code>goto</code> statement, they must search for and find the label within the function and continue reading the program from that point.</li> <li>It is more difficult to modify a program that uses <code>goto</code> statements or to try to develop the program by making additions. If a change is made at any point in the program, and if other places in the program jump to the point where the change was made using <code>goto</code> statements, changes may also be required at those points. That is, the <code>goto</code> statement increases the dependency of program segments on each other, which is generally undesirable.</li> </ol> <p>Despite these drawbacks, in some situations, the use of the <code>goto</code> statement, far from impairing program readability, helps create a structure that is more readable than other options:</p> <p>If there are multiple nested loops, and while in one of the inner loops, it is desired to exit all the loops at once, the <code>goto</code> statement should be used.</p> <p>The following code snippet contains three nested loops. Inside the innermost loop, the <code>test_func</code> function is called, and its return value is checked. If the function returns the value 0, the program flow is directed outside all loops with the <code>goto</code> statement: </p><pre><code>#include &lt;stdio.h&gt;\nint test_func(int val);\nint main()\n{\n    int i, j, k;\n    for (i = 0; i &lt; 100; ++i) {\n        for (j = 0; j &lt; 100; ++j) {\n            for (k = 0; k &lt; 20; ++k) {\n                /*...*/\n                if (!test_func(k))\n                    goto BREAK; // Jumps out of all loops\n                /*...*/\n            }\n        }\n    }\nBREAK:\n    printf(\"first statement outside the loop\\n\");\n    return 0;\n}\n</code></pre> Three separate loop statements are located within the function above. An inner function call performs a test operation, and if the test result is negative, the program flow is directed to the point after the outermost loop statement. <p>Otherwise, the same goal could only be achieved by using a flag variable. It would be necessary to check whether the value of the variable used as a flag was changed at the exit of every loop. </p><pre><code>#include &lt;stdio.h&gt;\n#define BREAK 0\n#define NO_BREAK 1\nint test_func(int val);\nint main()\n{\n    int i, j, k;\n    int flag = NO_BREAK;\n    for (i = 0; i &lt; 100; ++i) {\n        for (j = 0; j &lt; 100; ++j) {\n            for (k = 0; k &lt; 20; ++k) {\n                /*...*/\n                if (!test_func(k)) {\n                    flag = BREAK;\n                    break; // Exits innermost loop\n                }\n                /*...*/\n            }\n            if (flag == BREAK)\n                break; // Exits middle loop\n        }\n        if (flag == BREAK)\n            break; // Exits outermost loop\n    }\n    printf(\"first statement outside the loop\\n\");\n    return 0;\n}\n</code></pre> The use of the <code>goto</code> statement is better in terms of readability here. <p>In the example below, the <code>goto</code> statement is used to exit both the <code>switch</code> statement and the <code>for</code> loop that contains the <code>switch</code> statement: </p><pre><code>#define ADDREC 1\n#define LISTREC 2\n#define DELREC 3\n#define SORTREC 4\n#define EXITPROG 5\n\nint get_option(void);\nvoid add_rec(void);\nvoid list_rec(void);\nvoid del_rec(void);\nvoid sort_rec(void);\n\nint main()\n{\n    int option;\n    for (;;) { // Infinite loop\n        option = get_option();\n        switch (option) {\n            case ADDREC : add_rec(); break;\n            case LISTREC : list_rec(); break;\n            case DELREC : del_rec(); break;\n            case SORTREC : sort_rec(); break;\n            case EXITPROG : goto EXIT; // Jumps out of switch AND for loop\n        }\n    }\nEXIT:\n    return 0;\n}\n</code></pre> In the <code>main</code> function above, when the value of the variable <code>option</code> is <code>EXITPROG</code>, the program flow is sent outside the infinite loop with the <code>goto</code> statement. If the <code>break</code> statement had been used instead of the <code>goto</code> statement, only the <code>switch</code> statement would have been exited. <p>The <code>goto</code> statement can be used to jump from one point within a function to another point also within itself. Such jumps are called local jumps. Jumping from inside one function to inside another function is possible with other means. Such jumps are called non-local jumps. In the C language, non-local jumps are performed with standard functions named <code>setjmp</code> and <code>longjmp</code>. These jumps are mostly used for \"exception handling.\"</p>"},{"location":"c/1_programming_and_c/","title":"Programming and C","text":""},{"location":"c/1_programming_and_c/#programming-and-c","title":"Programming and C","text":""},{"location":"c/1_programming_and_c/#what-is-software","title":"What is Software?","text":"<p>Software is the name given to programming and the general body of related subjects. When software is mentioned, programming languages, source programs written using these languages, and various files created come to mind.</p>"},{"location":"c/1_programming_and_c/#what-is-hardware","title":"What is Hardware?","text":"<p>Hardware is the name given to the electronic part and structure of the computer.</p>"},{"location":"c/1_programming_and_c/#classification-of-software","title":"Classification of Software","text":"<p>Software can be divided into various groups according to its application areas:</p> <ol> <li> <p>Scientific and Engineering Software     Software used in solving problems in scientific fields and engineering applications. In this type of software, the amount of data is relatively low, but mathematical and statistical algorithms are used intensively. Such programs predominantly contain computation-oriented operations and intensively use the computer's Central Processing Unit (CPU). Examples of such programs include programs that analyze electronic circuits and statistical analysis packages.</p> </li> <li> <p>Application Software     Primarily database-oriented software. It generally deals with the creation, processing, and storage of data in files. Examples of this type of program include stock control programs, customer tracking programs, and accounting programs.</p> </li> <li> <p>Artificial Intelligence (AI) Software     Software that mimics human intellectual or learning behavior. Examples include robot software, programs that play chess or bridge, etc.</p> </li> <li> <p>Graphical Software     Programs where graphical operations and algorithms are used very intensively. Examples include games and animation software. These programs predominantly use the computer's graphical interface.</p> </li> <li> <p>Simulation Software     Software used to simulate a system in a computer environment.</p> </li> <li> <p>System Software     Software that manages the electronic structure of the computer. Compilers, communication programs, and operating systems are system software. For example, a word processing program is also system software. They perform lower-level operations compared to application programs.</p> </li> </ol>"},{"location":"c/1_programming_and_c/#evaluation-criteria-for-programming-languages","title":"Evaluation Criteria for Programming Languages","text":"<p>Sources mention the existence of approximately 1000 - 1500 programming languages currently in use. Why are there so many programming languages? Despite this abundance, why are new programming languages still being designed? What characteristics might make one programming language different from the other(s)? Which qualifiers can be used if one were to define a programming language? To answer these questions, there must be criteria that allow for evaluation. These criteria are briefly examined below:</p>"},{"location":"c/1_programming_and_c/#level","title":"Level","text":"<p>The level of a programming language is the measure of that programming language's proximity to human perception or the machine. A programming language is considered high-level the closer it is to human perception. Conversely, a programming language is considered low-level the closer it is to the electronic structure and operation of the computer.</p> <p>The computer's processor has an instruction set that it understands. The processor can only execute the instructions within its own instruction set. The text written in the programming language is converted into instructions in the computer processor's instruction set through some processes.</p> <p>Working with high-level languages is easy for the programmer and does not require extensive algorithm knowledge. In these languages, only what needs to be done is communicated to the program, but not how it should be done. Generally, as the level of a programming language increases, it becomes easier to learn that language and write programs in it.</p> <p>Machine language is the natural language of the computer, dependent on the computer's hardware design. Machine languages were the first languages used to get computers to perform tasks, coinciding with the development of computers. That is why machine languages are also called first-generation languages.</p> <p>Two fundamental problems were encountered when using machine language in programs. Code written in machine language consists of commands given directly to the machine's processor and hardware components. If a different CPU is used, or if the memory organization is done differently, the program no longer works; the program must be rewritten. This is because machine language is only applicable to a specific CPU or CPU series. Machine language is not portable. The other significant problem is that writing code in machine language is very cumbersome. Besides being very time-consuming and tedious to write, reading or understanding the written program is equally difficult. Especially when the program size increases, developing and expanding programs written in machine language become quite complex.</p> <p>Initially, there was only machine language. That is why machine languages are also referred to as 1st generation languages. Within the historical development of software and hardware, there is a process that extends from machine language to very high-level languages close to human perception (4th generation languages).</p> <p>In the early 1950s, efforts to eliminate the problems associated with using machine language intensified. During these years, programs written in machine language were loaded into the computer's very limited memory and executed in this way. First, a step was taken that partially eliminated the difficulty of perceiving and understanding machine language: Symbolic machine languages were developed. Symbolic machine languages (Assembly Languages) consisted of certain abbreviation words and commands that bundled a few machine instructions. The use of symbolic machine languages quickly became widespread. However, symbolic machine languages had a major disadvantage compared to machine languages. Programs written in these languages were loaded into the computer's memory like programs written in machine language, but during the execution phase, the commands of the symbolic language were translated into machine language one command at a time with the help of an interpreter program, and the resulting machine code was executed. That is, the computer first translated the program into machine language by interpreting it during the execution phase, and then executed the translated machine code. When programs were executed this way, they slowed down by almost 30 times.</p> <p>During this period, two interpreter programs notably emerged: John Mauchly's interpreter for UNIVAC 1 (1950) and the \"Speedcoding\" interpretation system written by John Backus for the IBM 701 in 1953. Although these interpreters ran very slowly compared to machine code, they increased programmer productivity. However, especially old machine language programmers argued that interpreters were too slow and that only programs written in machine language could be called real programs.</p> <p>This problem was also overcome. The idea, which was considered brilliant for its time, was: Instead of the written code being translated into machine language every time it is run, another program to be developed should translate the code written in symbolic language into machine language once, and then whenever the program is to be run, the computer should execute only the machine code without interpretation. Grace Hopper developed this idea. Grace Hopper's invention was named \"compiler.\" (Grace Hopper was also part of the team that developed the Cobol language, and she was the first to use the word \"bug.\") Programmers were now using Assembly programming languages consisting of symbolic words, the programs they wrote were converted to machine code by the compiler, and the machine code ran at full speed without losing any of its previous speed. Assembly languages took their place in history as 2nd generation languages.</p> <p>With the adoption of Assembly languages, computer usage rapidly increased. However, the fact that many commands were required to perform even the simplest operations on the computer initiated a quest to speed up and simplify the programming process, and as a result, higher-level programming languages began to be developed.</p> <p>Languages developed later than Assembly languages in the historical process and at a higher level are considered 3rd generation languages. These languages are all algorithmic languages. Few of the hundreds of high-level programming languages developed to date have survived. Almost all 3rd generation languages are derived from three main languages. These three languages, the first of the 3rd generation languages, are still in existence:</p> <p>FORTRAN (FORmula TRANslator) was developed by John Backus for IBM between 1954 and 1957 for use in engineering and scientific applications requiring complex mathematical calculations. The FORTRAN language is still used in scientific applications requiring intensive mathematical calculations. The FORTRAN language has two important versions: FORTRAN IV and FORTRAN 77. ISO and ANSI standards were accepted for a version named FORTRAN-90 in the early nineties. The FORTRAN language is considered the oldest of the 3rd generation languages.</p> <p>COBOL (COmmon Business Oriented Language) was developed in 1959 by a group consisting of computer manufacturers, private sector, and government sector computer users in America. The purpose of developing COBOL was to use a portable programming language for commercial applications requiring data management. The COBOL language is still widely used.</p> <p>ALGOL (The ALGOritmick Language) was developed by a consortium in Europe in 1958. Since IBM adopted the FORTRAN language as the common programming language to be used on its hardware, Europeans also wanted to develop an alternative language. Many design features developed in the ALGOL language are used in all modern programming languages.</p> <p>In the early 60s, work on programming languages brought the concept of structured programming to the agenda. The PASCAL language was developed by Professor Niclaus Wirth in 1971 to introduce the concept of structured programming to academic circles. The creator of the language named it after the mathematician and philosopher Blaise Pascal. This language quickly became the programming language used in universities. The fact that the Pascal language lacked some features necessary to support commercial and industrial applications limited its use. The Modula and Modula-2 languages were developed based on the Pascal language.</p> <p>The BASIC language was developed by John Kemeney and Thomas Kurtz in the mid-1960s. It is said that the name BASIC was formed from the initial letters of \"Beginner's All Purpose Symbolic Instruction Code.\" It is one of the oldest and simplest of the high-level languages. Despite all its simplicity, it has been used in many commercial applications. The BASIC language has also been standardized by ANSI. However, there are versions of the BASIC language that include additional features. For example, many features related to object-oriented programming were added to the Visual Basic language released by Microsoft. This language later took the name Visual Basic .NET. In addition, some versions of the BASIC language were generally accepted as the programming language used for writing macros that users would write for customization and automation purposes in application programs, for example, in MS Excel and MS Word programs.</p> <p>The ADA language, on the other hand, was developed starting from the 70s with the support of the U.S. Department of Defense (DoD). DoD is one of the largest computer users in the world. This institution was using a large number of different programming languages to meet different software requirements and began searching for a single language that would meet all its needs. An international competition was organized to design the language. The winning company (CII-Honeywell Bull of France) developed the Ada language as a result of its work based on the Pascal language. The documentation for the Ada language was published in 1983. The name Ada is a reference to the name of Lady Ada Lovelace, the daughter of the philosopher Lord Byron. Ada Lovelace was the assistant of Charles Babbage, who first used punched cards in calculating machines. Charles Babbage worked throughout his life on the construction of machines named \"Difference Engine\" and \"Analytical Machine\" but died before realizing these projects. Nevertheless, the designs he developed are considered the ancestors of modern computers. Ada Lovelace prepared the punched cards and algorithms to be used for Charles Babbage's machine. Lovelace is considered to have written the first computer program in the early 1800s. Ada is a general-purpose language, used in many different fields, from commercial applications to guiding rockets. One of the important features of the language is its support for real-time applications (embedded systems). Another feature is that it facilitates the writing of large programs due to its highly modular structure. However, the need for large, complex compilers has made its competition against C, Modula-2, and C++ languages difficult.</p> <p>Very high-level languages and languages where programs, generally not containing algorithmic structures, are written in a visual environment are called 4th generation languages. They are usually abbreviated as 4GL (fourth generation language). They are the languages closest to human perception. The RPG language can be considered the first of the 4th generation languages. It was developed by IBM at the request of companies, especially users of small IBM machines, who wanted an easy language for report generation.</p> <p>Programming languages can be grouped according to their levels:</p> <ul> <li>Very high-level languages or visual languages/environments (visual languages): Access, Foxpro, Paradox, Xbase, Visual Basic, Oracle Forms.</li> <li>High-level languages: Fortran, Pascal, Basic, Cobol.</li> <li>Mid-level programming languages: Ada, C. (Mid-level languages run faster because they can be translated into machine language with less loss.)</li> <li>Low-level programming languages: Symbolic machine language (Assembly language).</li> <li>Machine language: The lowest-level programming language. Pure machine language consists entirely of 1s and 0s.</li> </ul>"},{"location":"c/1_programming_and_c/#readability","title":"Readability","text":"<p>Readability is a term that means the source code can be quickly and well understood. When the readability of the source code is in question, the responsibility lies largely with the programmer who writes the program. However, as with efficiency, this feature also depends to some extent on the design of the programming language, as some languages contain structures and tools that enhance readability. The best program code is not the one \"most cleverly written but which no one can understand.\" In many cases, good programmers are unwilling to sacrifice readability for anything. This is because a readable program allows for updating even years later due to its easy comprehensibility. Readability becomes even more important in large-scale projects where many programmers work on shared code.</p> <p>Readability is one of the most emphasized concepts in C. You will see frequent mentions of readability in many subsequent sections.</p>"},{"location":"c/1_programming_and_c/#portability","title":"Portability","text":"<p>Portability means that source code written for one system can be compiled without errors and run correctly when transferred to another system. Portability also means standardization. Programming languages are standardized by ISO (International Standard Organization) and ANSI (American National Standard Institute). The C Language, whose standards were first established in 1989, is a more portable programming language than other programming languages.</p>"},{"location":"c/1_programming_and_c/#efficiency","title":"Efficiency","text":"<p>Efficiency is the characteristic of a program running fast and using less memory. The running speed and the amount of memory used by a program depend on many factors. Undoubtedly, the algorithm used also has an effect on speed and memory usage. The computer on which the program is run naturally also has an effect on speed. Efficiency can be considered a criterion related to the memory area used and the running speed when a program written in a programming language is run. When other factors that may play a role in efficiency are kept constant, it can be said that the design of the programming language used is also effective on efficiency. Viewed from this perspective, C is an efficient language.</p>"},{"location":"c/1_programming_and_c/#usage-area","title":"Usage Area","text":"<p>Some languages are designed for a specific application area. There are programming languages designed and used for system programming, artificial intelligence applications, simulation applications, database queries, and writing game programs. Other languages have a wider scope of use. For example, a language designed for use in database queries can also be used in engineering applications.</p> <p>Although the C language originated as a system programming language, its powerful structure quickly made it a general-purpose language. Pascal and BASIC, on the other hand, are much more general-purpose languages.</p> <p>C is a language whose main application area is \"system programming.\" However, programs have been written in the C language for almost all application areas.</p>"},{"location":"c/1_programming_and_c/#classification-by-application-area","title":"Classification by Application Area","text":"<p>We can also group programming languages according to their application areas:</p> <ol> <li>Scientific and Engineering Application Languages: Pascal, C, FORTRAN. The C Programming language is also used intensively in academic work at universities.</li> <li>Database Languages: XBASE (Foxpro, Dbase, CA-Clipper), Oracle Forms, Visual Foxpro.</li> <li>General-Purpose Programming Languages: Pascal, C, Basic.</li> <li>Artificial Intelligence Languages: Prolog, Lisp.</li> <li>Simulation Languages: GPSS, Simula 67.</li> <li>Macro Languages (Scripting languages): awk, Perl, Python, Tcl, JavaScript.</li> <li>System Programming Languages: Symbolic machine languages, BCPL, C, C++, occam.</li> </ol> <p>Today, we can say that almost all system software is written in the C language. For example, 80% of the UNIX operating system is written in the C language, and the rest is written in symbolic machine language. This operating system was first created at BELL Laboratories. Its source codes were not kept secret, making it possible to develop it from various branches. UNIX-based operating system applications developed later were given different names.</p> <p>C is a general-purpose system programming language that can be used in scientific and engineering fields.</p>"},{"location":"c/1_programming_and_c/#subprogramming-capability","title":"Subprogramming Capability","text":"<p>The method of breaking down problems that are difficult to solve as a whole into parts, solving these parts separately, and then connecting the parts is a frequently used method in programming. If a programming language has tools that allow this, it can be said that the programming language has subprogramming capability. Subprogramming capability means that a programming language supports writing the program in parts.</p> <p>Subprogramming is also an indispensable part of the Structured Programming Technique. Subprogramming brings some significant benefits. Subprograms reduce the size of the source code. Writing frequently repeated operations using subprograms reduces the size of the executable program code. This is because subprograms are written into the executable code only once. The program code can be made to jump to the location of the subprogram, allowing this segment to be executed multiple times.</p> <p>Subprogramming facilitates comprehension, increases readability, and also makes source code easier to test and update more easily. One of the most important benefits of subprogramming is the reusability of the created subprograms in multiple projects.</p> <p>C is a language with high subprogramming capability. Subprograms in C are called functions. Functions are the building blocks of the C language.</p>"},{"location":"c/1_programming_and_c/#ease-of-learning-and-teaching","title":"Ease of Learning and Teaching","text":"<p>The difficulty level of learning each programming language and developing applications in the learned programming language is not the same. Generally, as the level of programming languages increases, it becomes easier to learn and teach that programming language to others. An important reason for the popularity of widely used high-level programming languages today is that these languages are very easy to learn. However, gaining proficient skill by learning high-level languages often involves other difficulties. Such languages contain a large number of ready-made tools. For example, in a high-level programming environment, dozens of options may be presented to change the properties of a ready-made menu bar related to the GUI. In this case, the programmer has to learn the meaning of each option. That is, in some cases, although the increase in the level of the programming language brings a perceived convenience to the programmer, it also brings a learning burden to the programmer, especially regarding ready-made tools.</p>"},{"location":"c/1_programming_and_c/#supports-provided-for-programming-techniques","title":"Supports Provided for Programming Techniques","text":"<p>In the historical development process of programming, certain programming techniques (paradigms) have emerged. Since the sizes of programs written in the early days of programming were very small, there was little need to use a special technique when writing programs. This is because a program was small and simple enough for a single programmer to handle all aspects of it. There was no serious cost to changing a program or adding to a program.</p> <p>Technical developments in computer hardware, increased user expectations from computer programs, and the effective use of graphical interfaces have led to a gradual increase in program sizes. With the growth of programs, different techniques and methods for writing programs have been developed. Examples of these techniques include \"procedural programming,\" \"modular programming,\" \"object-based programming,\" \"object-oriented programming,\" and \"generic programming.\"</p> <p>\"Procedural programming\" and \"structured programming\" are often used interchangeably. Structured programming is a programming technique. Today, almost all programming languages are designed to support structured programming to a greater or lesser extent. The idea of structured programming was developed in the 1960s. The structured programming technique is based on four main principles:</p> <ol> <li>Divide and conquer     Programs that are difficult to write as a single whole are divided into smaller, more manageable pieces. That is, the program is divided into its smallest possible components (functional decomposition). These components are called subprograms, functions, procedures, etc. The benefits of subprogramming were explained earlier.</li> <li>Data hiding     In the structured programming technique, variables that cannot be accessed from other parts of the program and that have a limited scope, i.e., variables to be used only in a certain part of the code, can be defined. These types of variables are generally called \"local variables.\" Limiting the scope of variables reduces the risk of making errors, and also allows programs to be modified more easily and program segments to be reused in other programs. Information about how a subprogram or module performs a task is hidden from the user (client) of that subprogram or module. For the user (client), what the subprogram or module does is important, not how it does the task.</li> <li>Single entry, single exit     In languages that support the structured programming technique, there is a single entry and a single exit mechanism to enter each subprogram segment. This tool is in harmony with the top-to-bottom flow of the program. Program segments can only be entered from a single point.</li> <li>Loops, other control structures     Loops and other control statements are frequently used in the structured programming technique.</li> </ol> <p>Almost all programming languages in use today support the structured programming technique to a greater or lesser extent.</p> <p>Object-oriented programming (OOP) is also a programming technique. While the structured programming technique came to the fore in the 1960s, the object-oriented programming technique became widespread in the 1980s. This technique was developed due to the need arising from the excessive growth of source code. In the years when the C language was designed, the source codes of the largest imaginable programs were only a few thousand lines. With developments in computer hardware, increased user expectations from computer programs, and the effective use of graphical interfaces, the size of computer programs grew significantly. The size of many programs in use is measured in hundreds of thousands or even millions of lines.</p> <p>The object-oriented programming technique is designed, first and foremost, as a technique for writing large programs better. When the C language was created, the emergence of such a technique was not possible because programs were already very small by today's standards.</p> <p>In the object-oriented programming technique, the data related to the program and the code that processes this data are combined under a unit called an object. That is, the building blocks of this technique are objects. The most important difference of this technique from procedural programming is that the programmer thinks and constructs the program directly on the plane of the problem itself, rather than on the plane of the programming language. This allows a problem related to real life to be modeled much better in software.</p> <p>With the widespread adoption of the object-oriented programming technique, new versions of many programming languages have been created by adding tools that facilitate the application of this technique to their structures. For example, the C++ language was developed by making additions to the C language to enable the object-oriented programming technique to be applied. For similar purposes, the Delphi language was developed by making additions to the Pascal language, Oocobol by renewing the Cobol language, and Ada 95 by renewing the Ada language.</p> <p>Some programming languages have been designed and developed to directly support the object-oriented programming technique. Such languages are also called pure object-oriented languages. For example, Java, Eiffel, and C# are pure object-oriented languages.</p> <p>In summary, one of the most important questions to be asked about a programming language is perhaps whether that programming language has the tools to support a particular programming technique.</p> <p>The C language is a language that fully supports the procedural programming technique with its existing tools.</p>"},{"location":"c/1_programming_and_c/#inputoutput-ease","title":"Input/Output Ease","text":"<p>The ability to access sequential, indexed, and random files, and to retrieve, update, and query database records. The database programming languages (DBASE, PARADOX, etc.) have superior capabilities in this regard compared to others. This constitutes their most typical feature. However, C is a language with weak input/output ease. Special libraries must be used in C for the management of databases.</p>"},{"location":"c/1_programming_and_c/#what-kind-of-programming-language-is-c","title":"What Kind of Programming Language is C?","text":"<p>After examining the criteria, the C language can be placed in a specific position:</p> <p>C is a mid-level programming language. The level of the C language is lower compared to other structured programming languages. The C language has both the advantages of high-level languages, such as control statements and data structures, and operators that reflect machine code statements, such as bitwise operators. That is, C is a language close to both the machine's perception and human perception. This is one of the main reasons why it is preferred.</p> <p>Writing a program using the C language is much easier than writing the same program in machine language, but the efficiency of a program written in C does not decrease proportionally. C is preferable to machine language directly for many applications in terms of efficiency. Programming in the C language instead of machine language does not significantly reduce the efficiency of the created program.</p> <p>The main application area of the C language is \"System programming.\" What does system programming mean? Programs written for the management, direction, and control of hardware, which interact directly with the machine's hardware, are called system programs. For example, operating systems, compilers, interpreters, device drivers, programs related to computer communication, and automation programs are system programs.</p> <p>Before C, system programs were written in Assembly languages. Today, it can be said that the C language is almost the only option for writing system programs. Today, C codes are running everywhere, from mobile phones to airplanes.</p> <p>C is an algorithmic language. To write programs in the C language, it is not enough to know only the syntax and semantic structure of the language; general algorithm knowledge is also required.</p> <p>C is a highly portable language compared to other languages. This is because it has had generally accepted standards since 1989.</p> <p>C is a language with high expressive power and strong readability characteristics. The high readability of a text written in the C language is not due to it being a verbal language or a language close to the language used by humans.</p> <p>C is a very flexible language. It does not impose restrictions on the programmer like other languages. It better reflects the capabilities of the machine to the programmer.</p> <p>C is a powerful language, designed very well. Many of the operators and structures related to C have been adopted by other programming languages later.</p> <p>C is an efficient language. Programs written in C run fast due to the low level of the language. It can compete with Assembly languages in terms of efficiency.</p> <p>C is a natural language. C is compatible with the computer system.</p> <p>C is a small language. Writing a compiler for new systems is not difficult.</p> <p>C has a standard library. This library provides a common interface for frequently performed operations.</p> <p>Learning C is more difficult compared to other computer languages.</p> <p>The C language is integrated with the UNIX operating system. Some tools used in the UNIX operating system assume that the user knows the C language.</p> <p>Like all other computer programming languages, the C language also has its weak sides. Being a flexible and powerful language increases the programmer's risk of making errors. Mistakes made in code written in the C language can be more difficult to find than in other languages.</p>"},{"location":"c/20_random_number_generation_and_control_statements/","title":"Random Number Generation and Control Statements","text":""},{"location":"c/20_random_number_generation_and_control_statements/#random-number-generation-and-general-applications-related-to-control-statements","title":"Random Number Generation and General Applications Related to Control Statements","text":"<p>Random number generation is one of the important topics in mathematics. Random numbers, or more accurately, numbers that give the impression of randomness (pseudo-random numbers), are used in many fields such as statistics, economics, mathematics, and software.</p> <p>Random numbers are generated by a random number generator (RNG). An RNG is essentially a mathematical function. This function takes a starting value and generates a number. Then, it takes each number it has generated as a new input and generates a new number. The numbers generated by the generator are random.</p>"},{"location":"c/20_random_number_generation_and_control_statements/#the-rand-function","title":"The <code>rand</code> Function","text":"<p>The standard <code>rand</code> function generates random numbers. The declaration of this function is as follows: </p><pre><code>int rand(void);\n</code></pre> The C standards do not impose a condition on the algorithm or technique that the <code>rand</code> function will use for random number generation. This matter is left implementation-dependent, relying on the choice of the compiler writers. The declaration of the <code>rand</code> function is in <code>stdlib.h</code>, a standard header file. Therefore, this header file must be included in the source code with the <code>#include</code> preprocessor directive when the <code>rand</code> function is called. <pre><code>#include &lt;stdlib.h&gt;\n</code></pre> Each time the <code>rand</code> function is called, it returns a random integer value in the range \\([0, \\text{RAND\\_MAX}]\\). \\(\\text{RAND\\_MAX}\\) is a symbolic constant defined in the <code>stdlib.h</code> header file. The C standards require this symbolic constant to be at least 32767. Almost all compilers define the \\(\\text{RAND\\_MAX}\\) symbolic constant as 32767, which is the maximum value of the 2-byte signed <code>int</code> type: <pre><code>#define RAND_MAX 32767\n</code></pre> In the following code snippet, 10 random numbers between 0 and \\(\\text{RAND\\_MAX}\\) are generated and printed to the screen. Compile and run the program: <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nint main()\n{\n    int k;\n    for (k = 0; k &lt; 10; ++k)\n        printf(\"%d \", rand());\n    return 0;\n}\n</code></pre> The same sequence of numbers is printed to the screen every time the program created with the source code above is run. For example, when the program above was compiled and run with the Borland Turbo C 2.0 compiler under DOS, the screen output was as follows: <pre><code>346 130 10982 1090 11656 7117 17595 6415 22948 31126\n</code></pre>"},{"location":"c/20_random_number_generation_and_control_statements/#the-srand-function","title":"The <code>srand</code> Function","text":"<p>Why is the same sequence of numbers always obtained every time the created program is run? The <code>rand</code> function uses an algorithm to generate random numbers. Although this algorithm varies from compiler to compiler, the main theme used in random number generation is the same. It starts with a starting value, which is called the seed value. Some operations are performed on this value to obtain a random number. The operation performed on the seed value is then repeated on the generated random number.</p> <p>Since the same seed value will be used every time a program containing calls to the <code>rand</code> function is run, the same sequence of numbers is obtained.</p> <p>Another standard function, <code>srand</code>, is used to change the seed value of the random number generator. The declaration of the <code>srand</code> function, which is located in the <code>stdlib.h</code> header file, is as follows: </p><pre><code>void srand (unsigned seed);\n</code></pre> The value sent to the <code>srand</code> function is made the seed value of the random number generator by the function. When another seed value is sent as an argument to the <code>srand</code> function, the sequence of random numbers generated by the function changes. <p>The <code>rand</code> and <code>srand</code> functions are defined below: </p><pre><code>#define RAND_MAX 32767\nunsigned long int next = 1;\nint rand()\n{\n    next = next * 1103515245 + 12345;\n    return (unsigned int)(next / 65536) % 32768;\n}\nvoid srand(unsigned int seed)\n{\n    next = seed;\n}\n</code></pre> If the <code>srand</code> function is not called, the initial seed value is 1. <p>Recompile and run the program above by adding the <code>srand</code> function call: </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nint main()\n{\n    int k;\n    srand(100);\n    for (k = 0; k &lt; 10; ++k)\n        printf(\"%d \", rand());\n    return 0;\n}\n</code></pre> When this program was compiled and run with the Borland Turbo C 2.0 compiler under DOS, the screen output was as follows: <pre><code>1862 11548 3973 4846 9095 16503 6335 13684 21357 21505\n</code></pre> <p>However, the sequence of numbers above is still obtained every time the created program is run, right? Even if the pre-selected (default) seed value used by the <code>rand</code> function is not used, the seed value sent to the <code>srand</code> function is used every time now. Run the program a few times and see if the same sequence of numbers is always generated.</p> <p>In some situations, it is undesirable for the same random number sequence to be generated every time the program is run. For example, if the same numbers are always generated when a game program is run, the game is always played in the same way. To obtain a different number sequence every time the program runs, the <code>srand</code> function must set the random number generator's seed value to a different value every time the program runs. For this purpose, the standard <code>time</code> function is often used.</p> <p><code>time</code> is a standard C function; its declaration is in the standard header file <code>time.h</code>. We will only cover the <code>time</code> function, whose parameter is a pointer, in detail later. For now, we will examine the <code>time</code> function enough to serve our purpose. When the <code>time</code> function is sent the value 0, it returns the number of seconds that have passed since a predetermined date (01.01.1970 in most systems) until the moment the function is called. The return value of the function is a <code>long</code> type value in most compilers. If the return value of the <code>time</code> function is sent as an argument to the <code>srand</code> function in the program where random numbers will be generated, the random number generator will be initialized with a different seed value every time the program runs, due to the passage of a certain amount of time. Thus, a different number sequence is generated every time the program is run: </p><pre><code>srand(time(0));\n</code></pre> This call to the <code>srand</code> function is defined as a non-standard macro named <code>randomize</code> in most compilers: <pre><code>    randomize();\n</code></pre> This macro can also be used instead of the function call above. The topic of macros will be covered in detail later. <p>Let's modify the previously written example program above so that it generates a different number sequence every time it runs: </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\nint main()\n{\n    int k;\n    srand(time(0));\n    for (k = 0; k &lt; 10; ++k)\n        printf(\"%d \", rand());\n    return 0;\n}\n</code></pre> Sometimes, it is desired to generate random numbers in a specific range in programs. The remainder operator can be used for this purpose. Examine the following expressions: <ul> <li><code>rand() % 2</code>: Produces only the value 0 or 1.</li> <li><code>rand() % 6</code>: Produces a random value in the range 0 - 5.</li> <li><code>rand() % 6 + 1</code>: Produces a random value in the range 1 - 6. (e.g., a die roll value)</li> <li><code>rand() % 6 + 3</code>: Produces a random value in the range 3 - 8.</li> </ul> <p>However, the low-order bits of the random numbers generated by the random number generators provided by compiler programs are often not considered random. In this case, the expressions above do not provide an equal distribution for all numbers that should be generated.</p> <p>Some methods can be used to achieve a more uniform distribution:</p> <p>Instead of the expression: </p><pre><code>rand() % N\n</code></pre> the following expressions can be written: <pre><code>rand()/(RAND_MAX / N + 1)\n\n// or\n\n(int)((double)rand() / ((double)RAND_MAX + 1) * N)\n</code></pre> Or a function can be defined as follows: <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#define N 10\nint mrand()\n{\n    unsigned int x = (RAND_MAX + 1u) / N;\n    unsigned int y = x * N;\n    unsigned int r;\n    while ((r = rand()) &gt;= y)\n        ;\n    return r / x;\n}\n</code></pre> Placing the <code>srand(time(0))</code> call inside a loop is a common mistake. <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\nint zar_at() // die_roll\n{\n    srand(time(0)); // ERROR: Should be outside the loop\n    return rand() % 6 + 1 +\n        rand() % 6 + 1;\n}\nint main()\n{\n    int k;\n    for (k = 0; k &lt; 10; ++k)\n        printf(\"%d\\n\", zar_at());\n    return 0;\n}\n</code></pre> The <code>zar_at</code> function written above returns the sum of the values of two dice when a pair of dice is rolled. The <code>srand(time(0))</code> call is made inside the <code>zar_at</code> function. The <code>for</code> loop created inside the <code>main</code> function calls the <code>zar_at</code> function 10 times. The <code>time</code> function produces the same return value every time the function is called. In this case, since the same argument is passed to the <code>srand</code> function every time, the calls to the <code>rand</code> function also produce the same two numbers every time. That is, the same value is printed to the screen 10 times. The <code>srand(time(0))</code> call should have been made before the <code>for</code> loop inside the <code>main</code> function, right? <p>In the <code>main</code> function below, 10 random words consisting of letters of the English alphabet, with lengths ranging between 3 and 8 letters, are printed to the screen: </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#define TIMES 10\n#define MIN_WORD_LEN 3\n#define MAX_WORD_LEN 8\n\nvoid write_word(void)\n{\n    int len = rand() % (MAX_WORD_LEN - MIN_WORD_LEN + 1) + MIN_WORD_LEN;\n    while (len--)\n        putchar('A' + rand() % 26);\n}\nint main()\n{\n    int k;\n    srand(time(0));\n    for (k = 0; k &lt; TIMES; ++k) {\n        write_word();\n        putchar('\\n');\n    }\n    return 0;\n}\n</code></pre> Below, the generated words are now ensured not to contain vowels: <pre><code>int isvowel(int c)\n{\n    return c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n}\nvoid write_word(void)\n{\n    int len = rand() % (MAX_WORD_LEN - MIN_WORD_LEN + 1) + MIN_WORD_LEN;\n    int ch;\n    while (len--) {\n        while (isvowel(ch = rand() % 26 + 'A'))\n            ;\n        putchar(ch);\n    }\n}\n</code></pre> Below, a function named <code>print_random_date</code> is defined that prints a random date to the screen. Every time the function is called, it prints a random but valid date information between 01.01.MIN_YEAR and 31.12.MAX_YEAR to the screen: <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#define MAX_YEAR 2010\n#define MIN_YEAR 1900\n\nint isleap(int y)\n{\n    return y % 4 == 0 &amp;&amp; y % 100 != 0 || y % 400 == 0;\n}\n\nvoid print_random_date()\n{\n    int d, m, y;\n    y = rand() % (MAX_YEAR - MIN_YEAR + 1) + MIN_YEAR;\n    m = rand() % 12 + 1;\n    switch (m) {\n        case 4 : case 6 : case 9 : case 11:\n            d = rand() % 30 + 1; break;\n        case 2 : d = rand() % (isleap(y) ? 29 : 28) + 1; break;\n        default: d = rand() % 31 + 1;\n    }\n    printf(\"%d/%d/%d\\n\", d, m, y);\n}\n\nint main()\n{\n    int k;\n    srand(time(0));\n    for (k = 0; k &lt; 20; ++k)\n        print_random_date();\n    return 0;\n}\n</code></pre> Probability problems can be solved by implementing the event of probability in a computer program. If a good random number generator is used, the event of probability is simulated by a computer program, and the event is subjected to a high number of repetitions, utilizing the processing speed of the computer. Undoubtedly, the probability value for the event to be calculated depends on the number of repetitions performed and the quality of the random number generator. <p>The following code calculates the probability of getting heads in a coin toss event: </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#define TIMES 30000\n#define HEADS 1\nint main()\n{\n    int heads_counter = 0;\n    int k;\n    srand(time(0));\n    for (k = 0; k &lt; TIMES; ++k)\n        if (rand() % 2 == HEADS)\n            heads_counter++;\n    printf(\"probability of heads = %lf\", (double) heads_counter / TIMES);\n    return 0;\n}\n</code></pre> When the program above was run for different values of the \\(\\text{TIMES}\\) symbolic constant, the screen output was as follows:  <code>#define TIMES</code> Screen Output 100 probability of heads = 0.480000 500 probability of heads = 0.496000 2500 probability of heads = 0.506800 10000 probability of heads = 0.503500 30000 probability of heads = 0.502933 100000 probability of heads = 0.501450 1000000 probability of heads = 0.500198 <p>Below is another probability study being conducted:</p> <p>Craps is a dice game played with two dice, known almost all over the world. The rules of the game are as follows:</p> <p>The player rolling the dice plays against the house. If the sum of the two rolled dice is 7 or 11, the player wins. If the sum of the two rolled dice is 2, 3, or 12, the player loses. (This is called craps!)</p> <p>If the sum of the two dice is a value other than those above (i.e., 4, 5, 6, 8, 9, 10), the game continues as follows:</p> <p>The player rolls the dice again until they find the same result. If the player rolls a 7 before finding the same result, the player loses. If the player manages to roll the same result again before rolling a 7, they win.</p> <p>A few examples:</p> Player's Rolls Game Result 11 Player wins 3 Player loses 9 8 6 3 12 5 8 4 2 4 9 Player wins 6 5 8 9 2 3 7 Player loses 7 Player wins 10 4 8 11 8 3 6 5 4 9 10 Player wins <p>The following program calculates the winning probability of the player playing this game: </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#define NKEZ 1000000 // N\\_TIMES\n\nint zar_at() // die\\_roll\n{\n    int zar1 = rand() % 6 + 1;\n    int zar2 = rand() % 6 + 1;\n    return zar1 + zar2;\n}\n\n/* returns 1 if player wins, 0 if player loses */\nint oyun_devami(int zar_toplam) // continue\\_game\n{\n    int yeni_zar; // new\\_roll\n    for (;;) {\n        yeni_zar = zar_at();\n        if (yeni_zar == zar_toplam)\n            return 1;\n        if (yeni_zar == 7)\n            return 0;\n    }\n}\n\n/* returns 1 if player wins, 0 if player loses */\nint oyun() // game\n{\n    int zar_toplam; // roll\\_sum\n    zar_toplam = zar_at();\n    switch (zar_toplam) {\n        case 7 :\n        case 11: return 1;\n        case 2 :\n        case 3 :\n        case 12: return 0;\n    }\n    return oyun_devami(zar_toplam);\n}\n\nint main()\n{\n    int k;\n    int kazanma_sayisi = 0; // win\\_count\n    srand(time(0));\n    for (k = 0; k &lt; NKEZ; ++k)\n        kazanma_sayisi += oyun();\n    printf(\"winning probability = %lf\\n\", (double)kazanma_sayisi / NKEZ);\n    return 0;\n}\n</code></pre>"},{"location":"c/20_random_number_generation_and_control_statements/#random-real-number-generation","title":"Random Real Number Generation","text":"<p>There is no standard C function that generates random real numbers. However, a random real number in the range \\(0 - 1\\) can be generated using the following expression, utilizing the \\(\\text{RAND\\_MAX}\\) symbolic constant: </p><pre><code>(double)rand() / RAND_MAX\n</code></pre> Below, a function named <code>drand</code> that generates a random real number is defined. Examine the function and try to understand how it generates a random real number: <pre><code>#define PRECISION 2.82e14\n\ndouble drand()\n{\n    double sum = 0;\n    double denom = RAND_MAX + 1;\n    double need;\n    for (need = PRECISION; need &gt; 1; need /= (RAND_MAX + 1.)) {\n        sum += rand() / denom;\n        denom *= RAND_MAX + 1.;\n    }\n    return sum;\n}\n\nint main()\n{\n    int k;\n    for (k = 0; k &lt; 10; ++k)\n        printf(\"%lf\\n\", drand());\n    return 0;\n}\n</code></pre> The number \\(\\pi\\) is attempted to be found below using the method known as the Monte Carlo method. In this method, a quarter circle with a radius equal to the side length of a unit square is considered to be inside the unit square. A randomly selected point inside the unit square is either inside or outside the quarter circle. The probability of a randomly selected point being inside the quarter circle is the ratio of the area of a circle with a radius of 1 unit to the area of the square with a side of 1 unit. This is equal to the value \\(\\frac{\\pi}{4}\\). Therefore, if we take \\(n\\) random points and find how many of these points are inside the circle, 4 times the ratio of this value to the number \\(n\\) gives the number \\(\\pi\\): <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#define NTIMES 10000000\nint main()\n{\n    double x, y;\n    int k;\n    int inside_counter = 0;\n    srand(time(0));\n    for (k = 0; k &lt; NTIMES; ++k) {\n        x = (double)rand() / RAND_MAX;\n        y = (double)rand() / RAND_MAX;\n        if (x * x + y * y &lt;= 1)\n            inside_counter++;\n    }\n    printf(\"calculated pi value = %lf\\n\", 4. * inside_counter / NTIMES);\n    return 0;\n}\n</code></pre>"},{"location":"c/21_arrays/","title":"Arrays","text":""},{"location":"c/21_arrays/#arrays","title":"Arrays","text":""},{"location":"c/21_arrays/#what-is-a-data-structure","title":"What is a Data Structure?","text":"<p>Arrangements for storing logically related data concerning a topic in memory are called data structures. Data structures allow data stored in a specific order in memory to be accessed and certain operations to be performed efficiently on this data.</p>"},{"location":"c/21_arrays/#what-is-an-array","title":"What is an Array?","text":"<p>A data structure consisting of contiguous objects of the same type in memory is called an array. The most important feature of the array data structure is that data of the same type in a logical relationship are stored contiguously in memory. The benefit this provides in applications is this: Any element of the array can be accessed in constant time with the element's position information. That is, regardless of the number of elements in the array, the time to access an element whose position is known is the same. This facilitates the efficient implementation of some applications.</p>"},{"location":"c/21_arrays/#arrays-in-the-c-language","title":"Arrays in the C Language","text":"<p>In the C language, an array is a tool that allows one or more objects of the same type to be stored in memory in the form of the array data structure.</p> <p>By defining an array in C, multiple objects can be defined with a single statement. Instead of defining an array with 10 elements, it is certainly possible to define 10 separate objects with different names. But when 10 separate objects are defined, it is not a guaranteed feature that these objects will be placed contiguously in memory. However, in an array definition, it is a guaranteed feature that all objects that are elements of the array are placed contiguously in memory. Since an array is also a data type, arrays must also be defined before they are used.</p>"},{"location":"c/21_arrays/#defining-arrays","title":"Defining Arrays","text":"<p>The general form of array definitions is:</p> <pre><code>&lt;type&gt; &lt;array name&gt; [&lt;number of elements&gt;];\n</code></pre> <p>In the general form above, the square brackets do not indicate that the number of elements is optional, but that the number of elements information must be written inside the square brackets.</p> <ul> <li>type: The keyword indicating the type of the array elements.</li> <li>array name: Any name given in accordance with the naming rules.</li> <li>number of elements: Indicates how many elements the array has.</li> </ul> <p>Example array declarations: </p><pre><code>double a[20];\nint ave[10];\nchar path[80];\n</code></pre> In the definitions above: <ul> <li><code>a</code> is an array with 20 elements, each of type <code>double</code>.</li> <li><code>ave</code> is an array with 10 elements, each of type <code>int</code>.</li> <li><code>path</code> is an array with 80 elements, each of type <code>char</code>.</li> </ul> <p>The expression specifying the number of elements in the definition must be a constant expression of an integral type. In other words, the compiler must be able to obtain the value of this expression at compile time: </p><pre><code>int x = 100;\nint a[x]; /* Invalid */\nint b[5.]; /* Invalid */\nint c[10 * 20]; /* Valid */\nint d[sizeof(int) * 100]; /* Valid */\n</code></pre> The definitions of arrays <code>a</code> and <code>b</code> in the statements above are invalid. In the definition of array <code>a</code>, an expression that is not a constant expression is used as the size-specifying expression. In the definition of array <code>b</code>, the size-specifying expression is of a real number type. However, there is no error in the definition of array <code>c</code>. \\(10 * 20\\) is a constant expression. The definition of array <code>d</code> also does not cause an error because the value produced by the <code>sizeof</code> operator is obtained at compile time. <p>Symbolic constants are frequently used instead of an expression specifying the number of elements in array declarations: </p><pre><code>#define ARRAY_SIZE 100\nint a[ARRAY_SIZE];\n</code></pre> The <code>ARRAY_SIZE</code> symbolic constant can be used in place of the array size throughout the program. Thus, if a change regarding the array size is desired later in the program, only changing the value of the symbolic constant is sufficient. <p>As in other variable declarations, multiple arrays can be defined with the type-specifying word used only once, separated by the comma delimiter: </p><pre><code>int x[100], y[50], z[10];\n</code></pre> <code>x</code>, <code>y</code>, and <code>z</code> are arrays whose elements are of type <code>int</code>. <p>Arrays and other objects can be defined with a single definition statement, provided their types are the same: </p><pre><code>    int a[10], b, c;\n</code></pre> <code>a</code> is an array of 10 <code>int</code> elements, and <code>b</code> and <code>c</code> are <code>int</code> type objects. <p>Each element of an array is a separate object. Array elements can be accessed with the square bracket operator <code>[]</code>. This operator is a pointer operator. This operator will be discussed in detail in the section \"Pointers.\"</p> <p>The operand of the square bracket operator is the array name. This is actually an address information, because when an array name is subjected to an operation, it is automatically converted by the compiler into the address of the first element of the array before the operation. Inside the square brackets, there must be an integer expression indicating the index of the element of the array to be accessed.</p> <p>The first element of an array in the C language is the element with zero index.</p> <p>For a type \\(T\\), let \\(T \\ a[\\text{SIZE}]\\) be an array. The first element of such an array is \\(a[0]\\), and the last element is \\(a[\\text{SIZE} - 1]\\). Examples:</p> <ul> <li><code>a[20]</code> / The object that is the 20th indexed, i.e., 21st, element of array a /</li> <li><code>ave[0]</code> / The object that is the 0th indexed, i.e., first, element of array ave /</li> <li><code>total[j]</code> / The object that is the j-indexed element of array total /</li> </ul> <p>As seen, the terms \"the \\(n\\)-th element of an array\" and \"the \\(n\\)-indexed element of an array\" refer to different elements of the array. The \\(n\\)-indexed element of an array is the \\((n + 1)\\)-th element of that array.</p> <p>A compiler that encounters an array definition allocates space in memory for the defined array. The space to be allocated is undoubtedly:</p> \\[\\text{number of elements} \\times \\text{space occupied by one element in memory}\\] <p>in bytes. For example: </p><pre><code>    int a[5];\n</code></pre> <p>If it is assumed that the <code>int</code> type occupies 4 bytes in memory when working in the Windows operating system, the compiler allocates \\(4 \\times 5 = 20\\) bytes of space in memory for the array \\(a\\).</p> <p>The <code>++</code> or <code>--</code> operators are frequently used in array index expressions: </p><pre><code>int a[20];\nint k = 10;\nint i = 5;\n\na[k++] = 100;\n</code></pre> The statement assigns the value 100 to the 10-indexed element of the array, i.e., the 11th element of the array. The value of the variable \\(k\\) is then incremented by 1 to 11. <pre><code>    a[--i] = 200;\n</code></pre> The statement assigns the value 200 to the 4-indexed element of the array, i.e., the 5th element of the array. The value of the variable \\(i\\) is then decremented by 1 to 4. <p>With the use of the square bracket operator, any element of the array can now be used like other variables. Examine the following examples: </p><pre><code>a[0] = 1; // The value 1 is assigned to the first element of array a.\nprintf(\"%d\\n\", b[5]); // The value of the 6th element of array b is printed to the screen.\n++c[3]; // The value of the 4th element of array c is incremented by 1.\nd[2] = e[4]; // The 5th element of array e is assigned to the 3rd element of array d.\n</code></pre> <p>Loop statements are frequently used to operate on arrays. Reaching all elements of an array with the help of a loop statement is a very common situation.</p> <p>Some patterns using <code>for</code> and <code>while</code> loop statements for an array named <code>a</code> with \\(\\text{SIZE}\\) elements are shown below:</p> <p>The value 0 is assigned to all elements of array \\(a\\): </p><pre><code>for (i = 0; i &lt; SIZE; ++i)\n    a[i] = 0;\n</code></pre> The same task could undoubtedly be performed with a <code>while</code> loop statement: <pre><code>i = 0;\nwhile (i &lt; SIZE)\n    a[i++] = 0;\n</code></pre> Values are read into the elements of array \\(a\\) from the standard input unit using the standard <code>scanf</code> function below: <pre><code>for (i = 0; i &lt; SIZE; i++)\n    scanf(\"%d\", &amp;a[i]);\n</code></pre> or <pre><code>i = 0;\nwhile (i &lt; SIZE)\n    scanf(\"%d\", &amp;a[i++]);\n</code></pre> The sum of the elements of array \\(a\\) is calculated below: <pre><code>for (total = 0, i = 0; i &lt; SIZE; i++)\n    total += a[i];\n</code></pre> or <pre><code>total = 0;\ni = 0;\nwhile (i &lt; SIZE)\n    total += a[i++];\n</code></pre>"},{"location":"c/21_arrays/#array-overrun-out-of-bounds-access","title":"Array Overrun (Out-of-Bounds Access)","text":"<p>A compiler that sees an array definition allocates an area in memory large enough to hold all the array's elements: </p><pre><code>double a[10];\n</code></pre> If a definition like this is made, and it is assumed that the <code>double</code> type occupies 8 bytes in memory on the system being worked on, a total of 80 bytes of contiguous space is allocated in memory for the array \\(a\\). <p>The last element of the array is \\(a[9]\\). A very frequent mistake is accidentally assigning a value to a location in memory that has not been allocated by the compiler to access the last element of the array, i.e., overrunning the array: </p><pre><code>a[10] = 5.;\n</code></pre> The statement attempts to transfer a value to an 8-byte area whose purpose is unknown in memory, i.e., an unsafe memory region. Array overruns are not checked at compile time. Such errors are related to the program's runtime."},{"location":"c/21_arrays/#initializing-arrays","title":"Initializing Arrays","text":"<p>In variable definitions, a defined variable could be initialized with a specific value using a rule called the \"initialization syntax.\"</p> <p>Defined arrays can also be initialized: </p><pre><code>double sample[5] = {1.3, 2.5, 3.5, 5.8, 6.0};\nchar str[4] = {'d', 'i', 'z', 'i'};\nunsigned a[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n</code></pre> When arrays are initialized as above, the given values are assigned sequentially to the array elements, starting from the first element of the array. <p>It is not mandatory to initialize all elements of the array. If fewer elements are initialized than the number of elements in the array, the remaining elements are assigned the value 0. This rule applies to both local and global arrays.</p> <p>In this case, the shortest way to initialize all elements of an array to 0 is as follows: </p><pre><code>    int a[20] = {0};\n</code></pre> Only the first element of the array is given the initial value 0. In this case, the compiler generates code that automatically places the value 0 in the remaining elements of the array. <p>The expressions used to initialize array elements must be constant expressions. </p><pre><code>int a[10] = {b, b + 1, b + 2}; /* Invalid */\n</code></pre> An initialization operation like this is invalid.  <p>[The definition above is compliant with the rules of the C++ language. In C++, it is not mandatory to initialize array elements with constant expressions.]</p> <p>Giving more initial values than the array size in an array initialization operation is invalid: </p><pre><code>int b[5] = {1, 2, 3, 4, 5, 6}; /* Invalid */\n</code></pre> In the example above, although array \\(b\\) has 5 elements, 6 values are used in the initialization statement. This results in a compile-time error. <p>The array size may not be specified in the initialization operation. In this case, the compiler calculates the array length itself by counting the initial values given. It assumes that the array is opened with that size. For example: </p><pre><code>int a[] = {1, 2, 3, 4, 5};\n</code></pre> When the compiler sees the statement above, it assumes that array \\(a\\) has 5 elements. In this case, a declaration like the one above is equivalent to a declaration like the one below: <pre><code>int a[5] = {1, 2, 3, 4, 5};\n</code></pre> Other examples: <pre><code>char name[] = {'B', 'E', 'R', 'N', 'A', '\\0'};\nunsigned short count[ ] = {1, 4, 5, 7, 8, 9, 12, 15, 13, 21};\n</code></pre> The compiler assumes the size of the array <code>name</code> is 6 and the size of the array <code>count</code> is 10. <p>The initialization list for the array can be terminated with a comma token: </p><pre><code>int a[] = { 1, 4, 5, 7, 8, 9, 12, 15, 13,\n            2, 8, 9, 8, 9, 4, 15, 18, 25,\n            };\n</code></pre>"},{"location":"c/21_arrays/#local-and-global-arrays","title":"Local and Global Arrays","text":"<p>An array, like other objects, can be local or global. Local arrays are arrays defined inside blocks. Global arrays are defined in the global namespace, i.e., outside all blocks. All elements of a global array have the characteristics of global objects. That is, if the array is global, the objects that are array elements have file scope and static storage duration. If a global array is in question and initial values are not given to the array elements, the array elements are initialized with the value 0. However, when local arrays are in question, the objects that are array elements have block scope and automatic storage class in terms of lifetime. The array elements that have not been assigned a value contain garbage values.</p> <p>Write and compile the following program: </p><pre><code>#include &lt;stdio.h&gt;\n#define SIZE 10\nint g[SIZE]; // Global array\nint main()\n{\n    int y[SIZE]; // Local array\n    int i;\n    for (i = 0; i &lt; SIZE; ++i)\n        printf(\"g[%d] = %d\\n\", i, g [i]); // g elements will be 0\n    for (i = 0; i &lt; SIZE; ++i)\n        printf(\"y[%d] = %d\\n\", i, y [i]); // y elements will be garbage values\n    return 0;\n}\n</code></pre>"},{"location":"c/21_arrays/#assigning-arrays-to-each-other","title":"Assigning Arrays to Each Other","text":"<p>Array elements are objects. However, the entirety of an array cannot be treated as a single object: </p><pre><code>int a[SIZE], b[SIZE];\n</code></pre> After a definition like this, writing a statement like the following to copy the elements of array \\(b\\) to the elements of array \\(a\\) is a syntax error: <pre><code>a = b; /* Invalid */\n</code></pre> An assignment like the one above causes a compile-time error. This is because the array names \\(a\\) and \\(b\\) do not denote Lvalues (objects). The total memory space occupied by the array cannot be directly treated as a single object. That is, the elements of the array are objects, but the array itself is not an object. In C, array names are address values, of the same type as the array's type, indicating the start of the memory block where the arrays are placed. Therefore, they are not modifiable Lvalues. <p>Two arrays can only be copied to each other using a loop statement: </p><pre><code>for (i = 0; i &lt; SIZE; ++i)\n    a[i] = b[i];\n</code></pre> The loop statement above assigns the value of each element of array \\(b\\) to the corresponding indexed element of array \\(a\\). Another method for copying arrays is to use the standard C function <code>memcpy</code>. This function will be discussed in the section \"Pointers.\""},{"location":"c/21_arrays/#examples-related-to-array-usage","title":"Examples Related to Array Usage","text":"<p>If objects of the same type are defined under an array, codes that process all array elements can be easily written with the help of a loop statement. Carefully examine the following example: </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#define SIZE 10\nint main()\n{\n    int a[SIZE];\n    int sum = 0;\n    int k;\n    srand(time(0));\n    for (k = 0; k &lt; SIZE; ++k) {\n        a[k] = rand() % 100;\n        printf(\"%d \", a[k]);\n    }\n    for (k = 0; k &lt; SIZE; ++k)\n        sum += a[k];\n    printf(\"\\nsum of a elements = %d\\n\", sum);\n    return 0;\n}\n</code></pre> The first <code>for</code> loop statement in the <code>main</code> function assigns random values between 0 and 99 to the elements of array \\(a\\) with calls to the standard <code>rand</code> function. The value of each element of the array is also printed to the screen within the same loop. The subsequent second <code>for</code> statement sequentially adds the value of each element of array \\(a\\) to the variable named <code>sum</code>. <p>The following program finds the value of the smallest element in an integer array: </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#define SIZE 10\nint main()\n{\n    int a[SIZE];\n    int sum = 0;\n    int k, min;\n    srand(time(0));\n    for (k = 0; k &lt; SIZE; ++k) {\n        a[k] = rand() % 100;\n        printf(\"%d \", a[k]);\n    }\n    min = a[0];\n    for (k = 1; k &lt; SIZE; ++k)\n        if (min &gt; a[k])\n            min = a[k];\n    printf(\"\\nsmallest element = %d\\n\", min);\n    return 0;\n}\n</code></pre> You know the algorithm. The variable named <code>min</code> is defined to hold the value of the smallest element of the array. It is first assumed that the first element of the array is the smallest element of the array. Then, a <code>for</code> loop statement is used to check whether the values of the other elements of the array, starting from the 1-indexed element, are smaller than the value of the <code>min</code> variable. If the value of any element of the array is smaller than the value of the <code>min</code> variable, the value of the <code>min</code> variable is changed, and the value of the newly found element is assigned to the <code>min</code> variable. Upon loop exit, the <code>min</code> variable holds the value of the smallest element of the array, right? <p>The following program calculates the arithmetic averages of the odd and even elements of an integer array separately: </p><pre><code>#include &lt;stdio.h&gt;\n#define SIZE 10\nint main()\n{\n    int a[SIZE] = {2, 3, 1, 7, 9, 12, 4, 8, 19, 10};\n    int sum_of_odds = 0;\n    int sum_of_even = 0;\n    int no_of_odds = 0;\n    int k;\n    for (k = 0; k &lt; SIZE; ++k)\n        if (a[k] % 2) {\n            sum_of_odds += a[k];\n            no_of_odds++;\n        }\n        else\n            sum_of_even += a[k];\n    if (no_of_odds)\n        printf(\"Average of odds = %lf\\n\",(double)sum_of_odds / no_of_odds);\n    else\n        printf(\"No odd numbers in the array!\\n\");\n    if (SIZE - no_of_odds)\n        printf(\"Average of evens = %lf\\n\",(double)sum_of_even /(SIZE - no_of_odds));\n    else\n        printf(\"No even numbers in the array!\\n\");\n    return 0;\n}\n</code></pre> The following program searches within an array: <pre><code>#include &lt;stdio.h&gt;\n#define SIZE 10\nint main()\n{\n    int a[SIZE] = {2, 3, 1, 7, 9, 12, 4, 8, 19, 10};\n    int k;\n    int searched_val;\n    printf(\"enter the value to be searched : \");\n    scanf(\"%d\", &amp;searched_val);\n    for (k = 0; k &lt; SIZE; ++k)\n        if (a[k] == searched_val)\n            break;\n    if (k &lt; SIZE)\n        printf(\"a[%d] = %d\\n\", k, a[k]);\n    else\n        printf(\"searched value not found in the array!\\n\");\n    return 0;\n}\n</code></pre> The variable named <code>searched_val</code> is defined to hold the value to be searched in the array. The value of this variable is read from the keyboard using the standard <code>scanf</code> function. Then, a <code>for</code> loop is created, and the equality of each element of the array to the searched value is tested with an <code>if</code> statement located in the loop body. If any element of the array is equal to the searched value, the loop is exited with the <code>break</code> statement. If the loop variable \\(k\\) is less than the \\(\\text{SIZE}\\) value upon loop exit, the searched value has been found, i.e., the loop was exited with the <code>break</code> statement. If the loop was not exited with the <code>break</code> statement, the value of the variable \\(k\\) becomes equal to the \\(\\text{SIZE}\\) value, right? <p>If the elements of the array are unsorted, all elements of the array must be checked to conclude that a value is not in the array.</p> <p>However, if the array is sorted, the use of an algorithm called binary search allows the search operation to be performed much more efficiently:</p> <p></p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#define SIZE 100\nint main()\n{\n    int a[SIZE];\n    int k, mid, searched_val;\n    int val = 1;\n    int low = 0;\n    int high = SIZE - 1; // Correct initialization for high\n    srand(time(0));\n    for (k = 0; k &lt; SIZE; ++k) {\n        a[k] = val;\n        val += rand() % 10;\n        printf(\"%d \", a[k]);\n    }\n    printf(\"\\nenter the value to be searched : \");\n    scanf(\"%d\", &amp;searched_val);\n\n    while (low &lt;= high) {\n        mid = (low + high) / 2;\n        if (a[mid] == searched_val)\n            break;\n        if (a[mid] &gt; searched_val)\n            high = mid - 1;\n        else\n            low = mid + 1;\n    }\n    if (low &gt; high)\n        printf(\"%d value was not found in the array!\\n\", searched_val);\n    else\n        printf(\"a[%d] = %d\\n\", mid, searched_val);\n    return 0;\n}\n</code></pre> The binary search algorithm is used in the <code>main</code> function above to search within a sorted array. Since the array is sorted, looking at the middle element of the array means half of the elements in the array are now excluded from the query, right? <p>The variable <code>low</code> holds the lowest index of the array segment to be searched, and the variable <code>high</code> holds the highest index. You then see that a <code>while</code> loop is created that iterates as long as the value of <code>low</code> is less than or equal to the value of <code>high</code>. The variable <code>mid</code> holds the index of the middle element of the array segment to be searched. It is checked whether the <code>mid</code>-indexed element of the array is the searched value. If the searched value is not found, there are two possibilities: If the <code>mid</code>-indexed array element is greater than the searched value, the value of the <code>high</code> variable is made <code>mid - 1</code>. Thus, the size of the array to be searched is halved. If the <code>mid</code>-indexed array element is smaller than the searched value, the value of the <code>low</code> variable is made <code>mid + 1</code>. Thus, the size of the array to be searched is again halved.</p> <p>Upon exiting the <code>while</code> loop, if the value of <code>low</code> is greater than the value of <code>high</code>, it means the searched value was not found. Otherwise, the <code>mid</code>-indexed element of the array is the searched value.</p>"},{"location":"c/21_arrays/#sorting-arrays","title":"Sorting Arrays","text":"<p>Different algorithms can be used to sort the elements of an array from smallest to largest or from largest to smallest. Below, an array is sorted with the algorithm called \"bubble sort,\" which does not have very high perceptual complexity: </p><pre><code>#include &lt;stdio.h&gt;\n#define SIZE 10\nint main()\n{\n    int a[SIZE] = {2, 3, 1, 7, 9, 12, 4, 8, 19, 10};\n    int i, k, temp;\n    for (i = 0; i &lt; SIZE - 1; ++i)\n        for (k = 0; k &lt; SIZE - 1 - i; ++k)\n            if (a[k] &gt; a[k + 1]) {\n                temp = a[k];\n                a[k] = a[k + 1];\n                a[k + 1] = temp;\n            }\n    for (k = 0; k &lt; SIZE; ++k)\n        printf(\"%d \", a[k]);\n    return 0;\n}\n</code></pre> <p>The same algorithm could also be coded using a <code>do while</code> loop: </p><pre><code>#include &lt;stdio.h&gt;\n#define SIZE 10\n#define UNSORTED 0\n#define SORTED 1\nint main()\n{\n    int a[SIZE] = {12, 25, -34, 45, -23, 29, 12, 90, 1, 20};\n    int i, k, temp, flag;\n    do {\n        flag = SORTED;\n        for (k = 0; k &lt; SIZE - 1; ++k)\n            if (a[k] &gt; a[k + 1]) {\n                temp = a[k];\n                a[k] = a[k + 1];\n                a[k + 1] = temp;\n                flag = UNSORTED;\n            }\n    } while (flag == UNSORTED);\n    for (i = 0; i &lt; SIZE; ++i)\n        printf(\"a[%d] = %d\\n\", i, a[i]);\n    return 0;\n}\n</code></pre> The following program sorts the elements of an array from smallest to largest using the \"insertion sort\" algorithm: <pre><code>#include &lt;stdio.h&gt;\n#define SIZE 10\nint main()\n{\n    int a[SIZE] = {2, 3, 1, 7, 9, 12, 4, 8, 19, 10};\n    int i, k, temp;\n    for (i = 1; i &lt; SIZE; ++i) {\n        temp = a[i];\n        for (k = i; k &gt; 0 &amp;&amp; a[k - 1] &gt; temp; --k)\n            a[k] = a[k - 1];\n        a[k] = temp;\n    }\n    for (i = 0; i &lt; SIZE; ++i)\n        printf(\"%d \", a[i]);\n    return 0;\n}\n</code></pre> To change the sorting direction from smallest to largest to largest to smallest, it would be enough to change the inner loop as follows: <pre><code>for (k = i; k &gt; 0 &amp;&amp; array[k - 1] &lt; temp; --k)\n</code></pre> The following program uses the \"selection sort\" algorithm to sort the array from smallest to largest: <pre><code>#include &lt;stdio.h&gt;\n#define SIZE 10\nint main()\n{\n    int a[SIZE] = {2, 3, 1, 7, 9, 12, 4, 8, 19, 10};\n    int i, k, min, index;\n    for (k = 0; k &lt; SIZE; ++k) {\n        min = a[k];\n        index = k;\n        for (i = k + 1; i &lt; SIZE; ++i)\n            if (a[i] &lt; min) {\n                min = a[i];\n                index = i;\n            }\n        a[index] = a[k];\n        a[k] = min;\n    }\n    for (k = 0; k &lt; SIZE; ++k)\n        printf(\"%d \", a[k]);\n    return 0;\n}\n</code></pre> The following program places the odd-valued elements of the array at the beginning of the array in ascending order, and the even-valued elements at the end of the array in ascending order: <pre><code>#include &lt;stdio.h&gt;\n#define SIZE 10\nint main()\n{\n    int a[SIZE] = {2, 3, 1, 7, 9, 12, 4, 8, 19, 10};\n    int i, k, temp;\n    for (i = 0; i &lt; SIZE - 1; ++i)\n        for (k = 0; k &lt; SIZE - 1 - i; ++k)\n            if (a[k] % 2 == a[k + 1] % 2 &amp;&amp; a[k] &gt; a[k + 1] ||\n                a[k] % 2 == 0 &amp;&amp; a[k + 1] % 2 != 0) {\n                temp = a[k];\n                a[k] = a[k + 1];\n                a[k + 1] = temp;\n            }\n    for (k = 0; k &lt; SIZE; ++k)\n        printf(\"%d \", a[k]);\n    return 0;\n}\n</code></pre> <p>Did you notice that the <code>bubble sort</code> algorithm is used again to achieve the goal, but the condition expression tested for swapping has been changed?</p> <p>The following program reverses an array: </p><pre><code>#include &lt;stdio.h&gt;\n#define SIZE 10\nint main()\n{\n    int a[SIZE] = {2, 3, 1, 7, 9, 12, 4, 8, 19, 10};\n    int k;\n    for (k = 0; k &lt; SIZE / 2; ++k) {\n        int temp = a[k];\n        a[k] = a[SIZE - 1 - k];\n        a[SIZE - 1 - k] = temp;\n    }\n    for (k = 0; k &lt; SIZE; ++k)\n        printf(\"%d \", a[k]);\n    return 0;\n}\n</code></pre> To reverse the array, the \\(n\\)-th element from the beginning is swapped with the \\(n\\)-th element from the end within a loop that iterates half the size of the array. <p>The function named <code>urand</code> defined below generates a different random number between \\(0\\) and \\(\\text{MAX}\\) each time it is called. When the function is called after generating \\(\\text{MAX}\\) integers, it returns the value \\(-1\\) to report an error state: </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#define MAX 100\nint flags[MAX] = {0};\nint urand(void)\n{\n    int k, val;\n    for (k = 0; k &lt; MAX; ++k)\n        if (flags[k] == 0)\n            break;\n    if (k == MAX)\n        return -1;\n    while (flags[val = rand() % MAX])\n        ;\n    ++flags[val];\n    return val;\n}\nint main()\n{\n    int k;\n    srand(time(0));\n    for (k = 0; k &lt; MAX; ++k)\n        printf(\"%d \", urand());\n    printf(\"\\n\\n%d\\n\", urand());\n    return 0;\n}\n</code></pre> The function uses a global flag array named <code>flags</code> to understand whether an integer has been generated before. If the value of an element of the <code>flags</code> array is 0, it is understood that the value corresponding to that index has not yet been generated by the function. If the value of the array element is 1, it is understood that that value was generated before. <p>The <code>while (flags[val = rand() % MAX]);</code> loop is exited when the value of a randomly indexed element of the <code>flags</code> array assigned to the <code>val</code> variable is zero, right?</p> <p>The following program prints a randomly generated numerical lottery coupon to the screen: </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#define KOLON_SAYISI 8\nvoid kolon_yaz() // print\\_column\n{\n    int numaralar[50] = {0}; // numbers\n    int k, no;\n    for (k = 0; k &lt; 6; ++k) {\n        while (numaralar[no = rand() % 49 + 1])\n            ;\n        numaralar[no]++;\n    }\n    for (k = 1; k &lt; 50; ++k)\n        if (numaralar[k])\n            printf(\"%2d \", k);\n}\nint main()\n{\n    int k;\n    srand(time(0));\n    for (k = 0; k &lt; KOLON_SAYISI; ++k) {\n        printf(\"column %2d : \", k + 1);\n        kolon_yaz();\n        printf(\"\\n\");\n    }\n    return 0;\n}\n</code></pre> The <code>kolon_yaz</code> function prints a single column to the screen. You see that the local array named <code>numaralar</code> in the function is used again as a flag array. If the value of any indexed element of the array is 0, it indicates that the index value is a number that has not been generated before. The <code>while</code> loop inside the <code>for</code> loop iterates until a number that has not been generated before is found. Thus, 6 different numbers are generated by the <code>for</code> loop, which iterates 6 times. <p>The following program finds the value of the second largest element in an array: </p><pre><code>#include &lt;stdio.h&gt;\n#define SIZE 10\nint main()\n{\n    int a[SIZE] = {12, 34, 3, 56, 2, 23, 7, 18, 91, 4};\n    int k;\n    int max1 = a[0];\n    int max2 = a[1];\n    if (a[1] &gt; a[0]) {\n        max1 = a[1];\n        max2 = a[0];\n    }\n    for (k = 2; k &lt; SIZE; ++k)\n        if (a[k] &gt; max1) {\n            max2 = max1;\n            max1 = a[k];\n        }\n        else if (a[k] &gt; max2)\n            max2 = a[k];\n    printf(\"second largest value = %d\\n\", max2);\n    return 0;\n}\n</code></pre> The following program prints only the values of the unique elements in an array to the screen: <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#define SIZE 100\nint main()\n{\n    int a[SIZE];\n    int i, k;\n    int counter;\n    srand(time(0));\n    for (k = 0; k &lt; SIZE; ++k) {\n        a[k] = rand() % 30;\n        printf(\"%d \", a[k]);\n    }\n    printf(\"\\n*******************************************************\\n\");\n    for (i = 0; i &lt; SIZE; ++i) {\n        counter = 0;\n        for (k = 0; k &lt; SIZE; ++k)\n            if (a[k] == a[i])\n                if (++counter == 2)\n                    break;\n        if (counter == 1)\n            printf(\"%d \", a[i]);\n    }\n    printf(\"\\n\");\n    return 0;\n}\n</code></pre> The following program places different random values between \\(0\\) and \\(\\text{MAX}\\) into all elements of an array of \\(\\text{SIZE}\\) elements: <pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;time.h&gt;\n#define SIZE 50\n#define MAX 100\nint main()\n{\n    int a[SIZE];\n    int k;\n    srand(time(0));\n    for (k = 0; k &lt; SIZE; ++k) {\n        int val;\n        while (1) {\n            int i;\n            val = rand() % MAX;\n            for (i = 0; i &lt; k; ++i)\n                if (val == a[i])\n                    break;\n            if (i == k)\n                break;\n        }\n        a[k] = val;\n    }\n    /* array is printed */\n    for (k = 0; k &lt; SIZE; ++k)\n        printf(\"%d \", a[k]);\n    printf(\"\\n\");\n    return 0;\n}\n</code></pre> The following program merges two sorted arrays into one sorted array: <pre><code>#include &lt;stdio.h&gt;\n#define SIZE 10\nint main()\n{\n    int a[SIZE] = {2, 3, 6, 7, 8, 9, 13, 45, 78, 79};\n    int b[SIZE] = {1, 2, 4, 5, 7, 9, 10, 18, 33, 47};\n    int c[SIZE + SIZE];\n    int k;\n    int index1 = 0, index2 = 0;\n    for (k = 0; k &lt; SIZE + SIZE; ++k)\n        if (index1 == SIZE)\n            c[k] = b[index2++];\n        else if (index2 == SIZE)\n            c[k] = a[index1++];\n        else {\n            if (a[index1] &lt; b[index2])\n                c[k] = a[index1++];\n            else\n                c[k] = b[index2++];\n        }\n    for (k = 0; k &lt; SIZE + SIZE; ++k)\n        printf(\"%d \", c[k]);\n    return 0;\n}\n</code></pre>"},{"location":"c/22_character_arrays_and_strings/","title":"Character Arrays and Strings","text":""},{"location":"c/22_character_arrays_and_strings/#character-arrays-and-strings","title":"Character Arrays and Strings","text":"<p>Character arrays are arrays of type <code>char</code>. Character arrays are no different from other array types, except for some additional features. Character arrays are defined mainly to store strings (text) within them. </p><pre><code>char str[100];\n</code></pre> In the definition above, <code>str</code> is an array of 100 elements, with each element of type <code>char</code>. Storing a string in a <code>char</code> array means sequentially assigning the sequence number of one character of the string to each element of the array. Meanwhile, it is not mandatory to store a string in a <code>char</code> array; such an array can perfectly be used to store small integers. <p>Suppose the string \"Ali\" is intended to be stored in the array defined above: </p><pre><code>str[0] = 'A';\nstr[1] = 'l';\nstr[2] = 'i';\n</code></pre> Although the array is 100 characters long, shorter strings can also be stored in the array. So, how can the string stored in the array be accessed? The length information of the string is unknown. For example, suppose a loop statement like the one written below for integer arrays is used when the string is intended to be printed to the screen: <pre><code>for (k = 0; k &lt; 100; ++k)\n    putchar(s[k]);\n</code></pre> With such a loop, only the string \"Ali\" is not printed to the screen; the images of the other 97 elements of the array, i.e., garbage values, are also printed to the screen, right? <p>In the C language, the concept of a \"null character\" is utilized to perform operations on characters quickly and effectively.</p> <p>The null character is the zero-numbered character (<code>'\\x0'</code> or <code>'\\0'</code>) of the ASCII table or the character set used in the system. Therefore, its numerical value is equal to the number 0. It has no graphical representation. The null character <code>'\\0'</code> should not be confused with the character <code>'0'</code>. The code number of the character <code>'0'</code> in the ASCII character set is 48. Therefore, its integer value is 48. However, the ASCII sequence number of the character <code>'\\0'</code> is 0. Therefore, its integer value is 0. Compile and run the following program: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    printf(\"%d\\n\", '0');\n    printf(\"%d\\n\", '\\0');\n    return 0;\n}\n</code></pre> When the first <code>printf</code> function is called above, the value 48 is printed to the screen, while the value 0 is printed to the screen when the second <code>printf</code> function is called."},{"location":"c/22_character_arrays_and_strings/#initializing-character-arrays","title":"Initializing Character Arrays","text":"<p>The initialization of <code>char</code> arrays can be done in the following forms:</p> <p>As in other array types, initial values separated by commas are enclosed in curly braces: </p><pre><code>char name[7] = {'N', 'e', 'c', 'a', 't', 'i', '\\0'};\n</code></pre> As in other arrays, giving more initial values than the array size is invalid. <pre><code>char name[5] = {'N', 'e', 'c', 'a', 't', 'i'}; /* Invalid */\n</code></pre> Initial values can be given for as many elements as the array size or for fewer elements than the array size. If initial values are given for fewer elements, the uninitialized elements are initialized with the value 0, just like in other arrays. You know that the value 0 is the null character: <pre><code>char name[5] = {'A', 'l', 'i'}; // name[3] and name[4] are initialized to 0 ('\\0')\n</code></pre> The array size may not be specified when initializing <code>char</code> arrays. In this case, the compiler determines the array size by counting the initial values given. The compiler assumes the array is opened with this size. <pre><code>char name[ ] = {'A', 'l', 'i'};\n</code></pre> With the definition statement above, the compiler assumes that the <code>name</code> array is opened with 3 elements. <p>When the array size is not specified and initial values are given with comma-separated values in the definition of a <code>char</code> array, the compiler does not automatically place the null character at the end of the array. In this case, the null character that should be at the end of the string must be present in the initialization list: </p><pre><code>char name[] = {'A', 'l', 'i', '\\0'};\n</code></pre> The same situation applies when the array size is the same as the number of initial values given: <pre><code>char isim[7] = {'N', 'e', 'c', 'a', 't', 'i', '\\0'};\n</code></pre> Since initializing this way is cumbersome, a second form has been created for initialization. Character arrays can also be initialized within double quotes: <pre><code>char name[] = \"Ali\";\n</code></pre> The difference between this form and the other is that the compiler automatically places the null character at the end. <p>The compiler in the example above assumes that the <code>name</code> array is opened with 4 elements. Giving more initial values than the array size is invalid. </p><pre><code>char city[5] = \"\u0130stanbul\"; /* Invalid */\n</code></pre> There is one exception to this situation. If initial values are given within double quotes for the same number of elements as the array size, this situation is valid. The compiler does not place the null character at the end of the array in this case. <pre><code>char name[3] = \"Ali\"; /* Valid in C, Invalid in C++ */\n</code></pre> The <code>'\\0'</code> character is used to speed up operations performed on character strings. For example, when an <code>int</code> array is used, the array length must be known when performing operations on array elements using loops. But when <code>char</code> arrays are in question, it is no longer necessary to know the array length, because the <code>'\\0'</code> character will be at the end of the string, and by testing this situation with control expressions, it can be understood whether the end of the string has been reached. However, a drawback of using the <code>'\\0'</code> character as the last element of strings in character arrays is the necessity of adding an extra character, the <code>'\\0'</code> character, to the array. For this reason, a string of maximum \\(\\text{SIZE} \u2013 1\\) length can be stored in an array of \\(\\text{SIZE}\\) elements."},{"location":"c/22_character_arrays_and_strings/#standard-string-io-functions","title":"Standard String I/O Functions","text":"<p>The C language contains standard functions that read a string from the keyboard or print a string to the screen.</p>"},{"location":"c/22_character_arrays_and_strings/#the-gets-function","title":"The <code>gets</code> Function","text":"<p>The previously covered <code>getchar</code>, <code>getch</code>, and <code>getche</code> functions read a single character from the keyboard. <code>gets</code> is a standard C function used to read a character string from the keyboard. The user must press the Enter key after entering the characters from the keyboard. The function takes the name of the array where the characters to be entered from the keyboard will be placed as a parameter. As mentioned before, array names actually specify address information. The parameter of the <code>gets</code> function is actually a <code>char</code> type address. However, since the basic concepts related to pointers have not yet been explained, for now, you will only learn enough about the <code>gets</code> function to be useful to you. For example: </p><pre><code>char s[20];\ngets(s);\n</code></pre> All characters entered from the keyboard until the Enter key is pressed are placed sequentially into the <code>name</code> array (using <code>s</code> here). Suppose the string \"Necati\" is entered from the keyboard: <p>The <code>gets</code> function places the characters entered from the keyboard into the array and then places the null character at the end of the array.</p> <p>The <code>gets</code> function does not check for array overrun in any way. If more characters are entered than the number of array elements with the <code>gets</code> function, unexpected results may be encountered because the array will overrun. We will examine these kinds of situations in detail in the section \"Pointers\" under the heading \"pointer errors.\"</p> <p>Since the <code>gets</code> function adds the <code>'\\0'</code> character to the end of the array, the maximum number of characters that can be read with the <code>gets</code> function for an array of size \\(\\text{SIZE}\\) must be at most \\(\\text{SIZE} \u2013 1\\). This is because the null character also occupies memory space, just like other characters. Example: </p><pre><code>char isim[6];\ngets(isim);\n</code></pre> Suppose the name \"Necati\" is entered from the keyboard: <p>The compiler allocates 6 bytes of space in memory for this array with the definition of the <code>isim</code> array (<code>isim[0] ... isim[5]</code>).</p> <p>The <code>gets</code> function in this situation writes the <code>'\\0'</code> character to a memory cell that the compiler has not allocated for the array. Such situations are called \"off-by-one errors\" (array overrun errors). Errors that arise regarding the overrun situation are related to run time, not compile time.</p> <p>Examine the following program: </p><pre><code>#include&lt;stdio.h&gt;\n#define SIZE 100\nint main()\n{\n    char str[SIZE];\n    int ch;\n    int index = 0;\n    printf(\"enter a string: \");\n    printf(\"\\n\\n\");\n    while ((ch = getchar()) != '\\n')\n        str[index++] = ch;\n    str[index] = '\\0'; // Manually adding the null terminator\n    return 0;\n}\n</code></pre> In the <code>main</code> function above, a string entered from the keyboard is stored in the <code>str</code> array. All characters entered until the <code>'\\n'</code> character is received from the keyboard are sequentially assigned to the elements of the <code>str</code> array. When the <code>'\\n'</code> character is received from the keyboard, the <code>'\\0'</code> character is written after the last character written to the array to mark the end of the string in the array. <p>A string read from the keyboard can also be placed into a <code>char</code> array with the standard <code>scanf</code> function. The <code>%s</code> format specifier is used for this purpose. However, in this case, not all characters entered from the keyboard are placed into the array. The placement operation into the array ends with the first space character received from the keyboard. Examine the following program: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    char name[20];\n    char fname[30];\n    int no;\n    printf(\"enter name surname and number : \");\n    scanf(\"%s%s%d\", name, fname, &amp;no);\n    /***/\n    return 0;\n}\n</code></pre> Suppose the following input is made when the <code>scanf</code> function is called during the program's runtime (the <code>_</code> character indicates a space character): <pre><code>__Necati___Ergin___564\n</code></pre> <p>In this case, the string \"Necati\" is placed in the <code>name</code> array, the string \"Ergin\" is placed in the <code>fname</code> array, and the integer value 564 is placed in the variable named <code>no</code>.</p>"},{"location":"c/22_character_arrays_and_strings/#the-puts-function","title":"The <code>puts</code> Function","text":"<p><code>puts</code> is a standard C function. This function is used to print the string held in a character array to the screen. It takes the name of the character array holding the string (the array name is automatically converted to the starting address of the array by the compiler) as a parameter. The <code>puts</code> function moves the cursor to the beginning of the next line after printing the character array to the screen: </p><pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    char name[20];\n    printf(\"enter a name : \");\n    gets(name);\n    puts(name);\n    return 0;\n}\n</code></pre> In the example above, the string read from the keyboard with the <code>gets</code> function is printed to the screen with the <code>puts</code> function. <p>The standard <code>printf</code> function can also be used to print the strings held in character arrays to the screen. In this case, <code>%s</code> is used as the format specifier and is matched with the array name (the starting address of the array). </p><pre><code>printf(\"%s\\n\", name);\n</code></pre> performs the same task as: <pre><code>puts(name);\n</code></pre> However, the <code>printf</code> function does not move the cursor to the next line after printing the string held in the array to the screen (unless <code>\\n</code> is explicitly used). <p>Instead of the statement <code>puts(name);</code>, the following code snippet could also have been written: </p><pre><code>for (i = 0; name[i] != '\\0'; ++i)\n    putchar(name[i]);\nputchar('\\n');\n</code></pre> The <code>puts</code> function and the <code>printf</code> function when used with the <code>%s</code> format specifier write all characters until they encounter the null character. In this case, if the null character at the end of the string is somehow overwritten, both functions continue writing until they encounter the first null character. Examine the following program: <pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    char city[] = \"Ankara\";\n    city[6] = '!'; // Overwrites the null terminator ('\\0') at city[6]\n    puts(city);\n    return 0;\n}\n</code></pre> With the assignment <code>city[6] = '!'</code>, the null character at the end of the string \"Ankara\" is overwritten, and the character <code>!</code> is written over it. The subsequently called <code>puts</code> function prints the string: <pre><code>Ankara!\n</code></pre> to the screen and continues writing until it encounters the first null character. You will see that this situation constitutes a pointer error in the section on pointers. The <code>puts</code> and <code>printf</code> functions only consider the null character when writing character arrays. These functions are not concerned with the length of the character arrays."},{"location":"c/22_character_arrays_and_strings/#some-small-applications-related-to-character-arrays","title":"Some Small Applications Related to Character Arrays","text":"<p>The following program finds the length of the string held in a character array: </p><pre><code>#include &lt;stdio.h&gt;\n#define SIZE 100\nint main()\n{\n    char str[SIZE];\n    int k;\n    int len = 0;\n    printf (\"enter a string : \");\n    gets(str);\n    printf(\"string = (%s)\\n\", str);\n    for (k = 0; str[k] != '\\0'; ++k)\n        len++;\n    printf(\"length of the string (%s) is = %d\\n\", str, len);\n    return 0;\n}\n</code></pre> After the execution of the loop statement: <pre><code>for (k = 0; str[k] != '\\0'; ++k)\n    len++;\n</code></pre> in the program, the value of the loop variable \\(k\\) is also the length of the string, right? <p>The following program prints the string received into a <code>char</code> array to the screen in reverse: </p><pre><code>#include &lt;stdio.h&gt;\n#define SIZE 100\nint main()\n{\n    char s[SIZE];\n    int k;\n    printf(\"enter a string :\");\n    gets(s);\n    for (k = 0; s[k] != '\\0'; ++k)\n        ; // Finds the position of the null terminator\n    for (--k; k &gt;= 0; --k)\n        putchar(s[k]);\n    return 0;\n}\n</code></pre> The following program first receives a string into a character array from the keyboard. Then, the lowercase characters of the string are converted to uppercase, and the uppercase characters are converted to lowercase: <pre><code>#include &lt;stdio.h&gt;\n#include &lt;ctype.h&gt;\n#define SIZE 100\nint main()\n{\n    char str[SIZE];\n    int k;\n    printf (\"enter a string : \");\n    gets(str);\n    printf(\"string = (%s)\\n\", str);\n    for (k = 0; str[k] != '\\0'; ++k)\n        str[k] = isupper(str[k]) ? tolower(str[k]) : toupper(str[k]);\n    printf(\"converted string = (%s)\\n\", str);\n    return 0;\n}\n</code></pre> The following program reverses the string received into a character array from the keyboard: <pre><code>#include &lt;stdio.h&gt;\n#define SIZE 100\nint main()\n{\n    char str[SIZE];\n    int k, temp, len;\n    printf (\"enter a string : \");\n    gets(str);\n    for (len = 0; str[len] != '\\0'; ++len)\n        ; // Find length (len holds the index of '\\0')\n    for (k = 0; k &lt; len / 2; ++k) {\n        temp = str[k];\n        str[k] = str[len - 1 - k];\n        str[len - 1 - k] = temp;\n    }\n    printf(\"reversed string = (%s)\\n\", str);\n    return 0;\n}\n</code></pre> Examine the algorithm used in the code above. The length of the string is found with the first <code>for</code> loop. Then, a <code>for</code> loop statement that iterates half the length of the string is created. In each iteration of the loop, the \\(n\\)-th character from the beginning of the string is swapped with the \\(n\\)-th character from the end. If the string length is an odd number, the character in the middle of the string remains in place. Since the null character is \\(str[\\text{len}]\\), the last character of the string is \\(str[\\text{len} \u2013 1]\\), right? <p>The following program counts all English letters found in a string entered from the keyboard and prints how many of them there are: </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;ctype.h&gt;\n#define SIZE 500\nint main()\n{\n    char str[SIZE];\n    int letter_counter[26] = {0};\n    int k;\n    printf(\"enter a string : \");\n    gets(str);\n    for (k = 0; str[k] != '\\0'; ++k)\n        if (isalpha(str[k]))\n            letter_counter[toupper(str[k]) - 'A']++;\n    for (k = 0; k &lt; 26; ++k)\n        if (letter_counter[k])\n            printf(\"%3d of %c\\n\", letter_counter[k], 'A' + k);\n    return 0;\n}\n</code></pre> The array named <code>letter_counter</code> used in the <code>main</code> function is used as a counter array. The 1st element of the array acts as the counter for the characters 'A', 'a', the 2nd element acts as the counter for the characters 'B', 'b', and the last element acts as the counter for the characters 'Z', 'z'. This local array is zeroed out with the initialization statement. The first <code>for</code> loop statement iterates through all characters of the string, and if any character of the string is an alphabetic character, it is converted to uppercase, and the value 'A' is subtracted from this character. You see that the resulting value is used as the index for the <code>letter_counter</code> array, and the value of this indexed element of the <code>letter_counter</code> array is incremented by 1. <p>The second <code>for</code> loop statement then prints the values of the elements of the counter array that are not 0 to the screen.</p> <p>In the following program, digit characters are deleted from a string received into an array. Examine the code: </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;ctype.h&gt;\n#define SIZE 500\nint main()\n{\n    char str[SIZE];\n    int k;\n    int index = 0;\n    printf(\"enter a string : \");\n    gets(str);\n    printf(\"string = (%s)\\n\", str);\n    for (k = 0; str[k] != '\\0'; ++k)\n        if (!isdigit(str[k])) // Corrected from !isdigit[k] to !isdigit(str[k])\n            str[index++] = str[k];\n    str[index] = '\\0';\n    printf(\"string = (%s)\\n\", str);\n    return 0;\n}\n</code></pre> To delete digit characters from the string, the string is copied back to its location. However, digit characters are not copied during the copying process. The variable named <code>index</code> indicates where in the array the character will be written. If a character is not a digit character, this character is assigned to the <code>index</code>-indexed element of the array, and then the value of the <code>index</code> variable is incremented by 1. However, after exiting the <code>for</code> loop that traverses the entire string, the null character is added to the end of the string formed after the deletion operation. <p>The following program finds the total number of words in a string: </p><pre><code>#include &lt;stdio.h&gt;\n#define SIZE 200\n#define OUTWORD 0\n#define INWORD 1\n\nint is_sep(int ch)\n{\n    char seps[] = \" \\t.,;:?!\";\n    int k;\n    for (k = 0; seps[k] != '\\0'; ++k)\n        if (ch == seps[k])\n            return 1;\n    return 0;\n}\n\nint main()\n{\n    char str[SIZE];\n    int word_counter = 0;\n    int k;\n    int word_flag = OUTWORD;\n    printf(\"enter a string : \");\n    gets(str);\n    for (k = 0; str[k] != '\\0'; ++k)\n        if (is_sep(str[k]))\n            word_flag = OUTWORD;\n        else if (word_flag == OUTWORD) {\n            word_flag = INWORD;\n            word_counter++;\n        }\n    printf(\"total %d words!\\n\", word_counter);\n    return 0;\n}\n</code></pre> The <code>is_sep</code> function tests whether a character whose sequence number is passed to it is one of the separator characters that separate words. <p>The flag variable named <code>word_flag</code> defined in the <code>main</code> function indicates whether one is inside or outside a word. You see that this variable is initialized with the value OUTSIDE_WORD (<code>OUTWORD</code>).</p> <p>A <code>for</code> loop statement is used to test whether each character of the string is a separator character. If it is a separator character, the value <code>OUTWORD</code> is assigned to the <code>word_flag</code> variable. If the character is not a separator character and the flag's value is also <code>OUTWORD</code>, the value <code>INWORD</code> is assigned to the flag, and the value of the counter that holds the word count is incremented by 1.</p> <p>The following program reduces the number of consecutive identical characters in a string taken into an array to one: </p><pre><code>#include &lt;stdio.h&gt;\n#define SIZE 100\nint main()\n{\n    char str[SIZE];\n    int index = 0;\n    int k;\n    printf(\"enter a string : \");\n    gets(str);\n    // Corrected logic: start with str[0] already in place\n    for (k = 1; str[k] != '\\0'; ++k)\n        if (str[k] != str[index]) // Compare current char to the last unique char written\n            str[++index] = str[k];\n\n    // Ensure the string is terminated correctly\n    str[++index] = '\\0';\n\n    printf(\"string = (%s)\\n\", str);\n    return 0;\n}\n</code></pre>"},{"location":"c/23_sizeof_operator/","title":"sizeof Operator","text":""},{"location":"c/23_sizeof_operator/#the-sizeof-operator","title":"The <code>sizeof</code> Operator","text":"<p><code>sizeof</code> is an operator that produces the value of how many bytes the type of an expression occupies in memory. <code>sizeof</code> is a unary prefix operator.</p> <p>The operand of the <code>sizeof</code> operator can be one of the following:</p> <ol> <li> <p>Type-specifying keywords can be used as the operand. In this case, the operand must be enclosed in parentheses. Examples:     </p><pre><code>sizeof(int)\nsizeof(double)\nsizeof(long)\n</code></pre>     In this case, the operator produces the value of how many bytes the type information that is its operand occupies on the system being used. For example, on Windows or UNIX systems, the value of an expression like <code>sizeof(int)</code> is 4. </li> <li> <p>An expression can be used as the operand. In this case, enclosing the operand in parentheses is not mandatory. However, most programmers prefer to enclose the operand in parentheses for readability:     </p><pre><code>double x;\nsizeof (x)\nsizeof(17.8)\nsizeof(func())\n</code></pre>     In this case, the operator produces the value of how many bytes the type belonging to the operand expression occupies on the system being used. For example, on Windows or UNIX systems, the value of an expression like <code>sizeof(x)</code> is 8. Such an expression can naturally also be used to determine how many bytes the object \\(x\\) occupies in memory on the relevant system. The <code>sizeof</code> operator is most commonly used in this form. That is, the operand of the operator is chosen as an expression denoting an object to find out how many bytes the operand object occupies in memory. </li> <li> <p>When the <code>sizeof</code> operator takes an array name as an operand, it produces the total length of that array in bytes as its value: </p><pre><code>double a[10];\nsizeof(a)\n</code></pre>     The expression produces the value 80. <p>On the other hand, the value produced by the <code>sizeof</code> operator when it takes an element of the array as an operand is the length in bytes of the type of that array on the system being used. That is, in the example above: </p><pre><code>sizeof(a[0])\n</code></pre> The expression produces the value 8. <p>In this case, the expression:</p> \\[\\text{sizeof}(a) / \\text{sizeof}(a[0])\\] <p>gives the array size. Example:</p> \\[\\text{for } (i = 0; i &lt; \\text{sizeof}(a) / \\text{sizeof}(a[0]); ++i) \\ a[i] = 0;\\] <p>The loop above, where \\(a\\) is an array name, iterates as many times as the number of elements in array \\(a\\).</p> <p>Instead of explicitly writing the array size in the loop above, writing it in the form \\(\\text{sizeof}(a) / \\text{sizeof}(a[0])\\) might seem surprising to you. Can such a writing style have a benefit?</p> <p>You know that in array definitions, there is no need to specify the size of arrays that are initialized, and the compiler deduces the array size from the number of initial values given. Examine the following code:</p> <pre><code>#include &lt;stdio.h&gt;\nint main()\n{\n    int a[] = {2, 5, 7, 8, 9, 23, 67};\n    int k;\n    for (k = 0; k &lt; sizeof(a) / sizeof(a[0]); ++k)\n        printf(\"%d \", a[k]);\n    printf(\"\\n\");\n    return 0;\n}\n</code></pre> <p>An <code>int</code> array named \\(a\\) is defined in the <code>main</code> function above. The defined array is initialized. The compiler counts the given initial values, determines the array size as 7, and generates code accordingly. The <code>for</code> loop statement in the <code>main</code> function iterates as many times as the number of elements in the array, i.e., 7 times.</p> <p>Now assume that a change is made in the source code, and a few more elements are added to array \\(a\\):</p> <p><code>int a[] = {2, 5, 7, 8, 9, 23, 67, 34, 58, 45, 92};</code></p> <p>In this case, there is no need to make a change in the <code>for</code> loop statement. This is because the compiler calculates the array size as 11 this time. The expression \\(\\text{sizeof}(a) / \\text{sizeof}(a[0])\\) used in the <code>for</code> loop statement also produces the value 11 this time.</p> </li> </ol>"},{"location":"c/23_sizeof_operator/#precedence-of-the-sizeof-operator","title":"Precedence of the <code>sizeof</code> Operator","text":"<p>You know that all unary operators are located at the second level of the operator precedence table. <code>sizeof</code> is also an operator located at the second level.</p>"},{"location":"c/23_sizeof_operator/#sizeof-is-not-a-function","title":"<code>sizeof</code> is Not a Function","text":"<p>Since the operand of the <code>sizeof</code> operator is often written inside parentheses, the usage of the operator resembles a function call: </p><pre><code>sizeof(y)\n</code></pre> However, <code>sizeof</code> is an operator, not a function. <code>sizeof</code> is one of the 32 keywords in the C language."},{"location":"c/23_sizeof_operator/#type-of-the-value-produced-by-the-sizeof-operator","title":"Type of the Value Produced by the <code>sizeof</code> Operator","text":"<p>The value produced by the <code>sizeof</code> operator is of type <code>unsigned int</code>. Accepting the type of the value produced by the operator as <code>signed int</code> is an error. When the value produced by the operator is subjected to an operation with a negative number of type <code>signed int</code>, type conversion is performed towards the unsigned direction: </p><pre><code>-2 * sizeof(int)\n</code></pre> \\(-2\\) is a literal of type <code>signed int</code>. The value produced by the expression <code>sizeof(int)</code> is the value 4 of type <code>unsigned int</code>. With the implicit type conversion to be performed before the operation, the value \\(-2\\) is converted to the <code>unsigned int</code> type. The operation is performed in the <code>unsigned int</code> type. That is, the result of the operation is not \\(-8\\).  <p>[Actually, the value produced by the <code>sizeof</code> operator is of the standard <code>typedef</code> type called <code>size_t</code>. Standard <code>typedef</code> types are covered in the section \"Type Name Declarations and the <code>typedef</code> Specifier.\"]</p>"},{"location":"c/23_sizeof_operator/#side-effect-of-the-expression-that-is-the-operand-of-the-sizeof-operator","title":"Side Effect of the Expression That is the Operand of the <code>sizeof</code> Operator","text":"<p>The expression that is the operand of the <code>sizeof</code> operator does not exhibit a side effect. Examine the following example: </p><pre><code>#include &lt;stdio.h&gt;\nint func()\n{\n    printf(\"func()\\n\");\n    return 1;\n}\nint main()\n{\n    unsigned int x = sizeof(func()); // func() is NOT called\n    printf(\"x = %u\\n\", x); // x will be the size of int (e.g., 4)\n    return 0;\n}\n</code></pre> The <code>func</code> function is not called in the <code>main</code> function. The <code>sizeof</code> operator only looks at its operand expression as a type information. The type of the expression <code>func()</code> in the example code is the <code>int</code> type."},{"location":"c/23_sizeof_operator/#what-is-the-sizeof-operator-used-for","title":"What is the <code>sizeof</code> Operator Used For?","text":"<p>The number of bytes a specific type of object occupies in memory can vary from system to system. The only native type whose length is guaranteed is the <code>char</code> type. An object of type <code>char</code> occupies 1 byte on all systems. The fact that type lengths can differ from system to system can lead to portability problems in some applications. It can generally be said that the <code>sizeof</code> operator is used to eliminate such portability problems.</p>"},{"location":"c/2_number_systems/","title":"Number Systems","text":""},{"location":"c/2_number_systems/#number-systems-in-c","title":"Number Systems in C","text":""},{"location":"c/2_number_systems/#1-introduction-to-number-systems","title":"1. Introduction to Number Systems","text":"<p>Computers process data in the binary system. Each number system uses different symbols according to its base:</p> System Base Symbols Binary 2 0, 1 Octal 8 0\u20137 Decimal 10 0\u20139 Hexadecimal 16 0\u20139, A\u2013F <p>representing number systems </p><pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int decimal_num = 255;\n\n    // Octal (prefixed with '0')\n    int octal_num = 0377; \n\n    // Hexadecimal (prefixed with '0x' or '0X')\n    int hex_num = 0xFF; \n\n    printf(\"Decimal (10)   : %d\\n\", decimal_num);\n    printf(\"Octal (8)      : %o\\n\", octal_num);\n    printf(\"Hexadecimal(16): %X\\n\", hex_num);\n\n    // Binary literal support came with the C23 standard but is not widely adopted.\n    // printf(\"Binary (2)   : %b\\n\", 0b11111111); // Does not work in pre-C23 compilers\n\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#2-bit-byte-and-other-units","title":"2. Bit, Byte, and Other Units","text":"<ul> <li>Bit (binary digit): Smallest unit of information (0 or 1)  </li> <li>Nibble: 4 bits </li> <li>Byte: 8 bits   </li> <li>Word: 16 bits  </li> <li>Double Word (DWORD): 32 bits  </li> <li>Quad Word (QWORD): 64 bits  </li> </ul>"},{"location":"c/2_number_systems/#memory-capacity-units","title":"Memory Capacity Units","text":"Unit Equivalent Description 1 KB 1024 Bytes 2\u00b9\u2070 1 MB 1024 KB 2\u00b2\u2070 1 GB 1024 MB 2\u00b3\u2070 1 TB 1024 GB 2\u2074\u2070"},{"location":"c/2_number_systems/#memory-capacity-of-basic-data-types","title":"Memory Capacity of Basic Data Types","text":"<p>Note: The <code>sizeof</code> operator in C allows us to learn how many bytes any data type or variable occupies in memory. the return type is <code>size_t</code> (unsigned int). so i use <code>%zu</code> format for print the occupied byte. This is essential for obtaining hardware-dependent information programmatically. </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;limits.h&gt; // For CHAR_BIT\n\nint main() {\n    // CHAR_BIT gives the number of bits in a byte (usually 8).\n    printf(\"1 Byte = %d Bit\\n\", CHAR_BIT); \n\n    // Prints memory capacity in bytes\n    printf(\"Size of char: %zu Bytes\\n\", sizeof(char));\n    printf(\"Size of int: %zu Bytes\\n\", sizeof(int));\n    printf(\"Size of long long: %zu Bytes\\n\", sizeof(long long));\n\n    // Assuming a 32-bit system: int = 4 Bytes = Double Word (DWORD)\n    printf(\"Size of 4 Byte (DWORD) int: %zu Bytes\\n\", sizeof(int));\n\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#3-binary-decimal-conversions","title":"3. Binary \u2194 Decimal Conversions","text":""},{"location":"c/2_number_systems/#binary-decimal","title":"Binary \u2192 Decimal","text":"<p>Each bit is multiplied by powers of 2 and summed: 1011\u2082 = 1\u00d72\u00b3 + 0\u00d72\u00b2 + 1\u00d72\u00b9 + 1\u00d72\u2070 = 11\u2081\u2080</p>"},{"location":"c/2_number_systems/#decimal-binary","title":"Decimal \u2192 Binary","text":"<p>Divide the number by 2 repeatedly and write the remainders in reverse order: 87\u2081\u2080 \u2192 0101 0111\u2082</p> <p>Alternative method: Subtract the largest power of 2 and continue with the remainder.</p>"},{"location":"c/2_number_systems/#binary-to-decimal-conversion","title":"Binary to Decimal Conversion","text":"<p>This relies on checking an integer using bitwise AND (&amp;) and bitwise Shift (&gt;&gt;) operators. </p><pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    unsigned char binary_num = 0b10110011; // 179\n    int decimal_val = 0;\n    int power = 1;\n\n    // Convert to decimal by checking each bit\n    for (int i = 0; i &lt; 8; i++) {\n        // Check the rightmost bit (LSD) with Bitwise AND\n        if (binary_num &amp; 1) { \n            decimal_val += power;\n        }\n\n        // Shift the number one bit to the right (makes the next bit the LSB)\n        binary_num &gt;&gt;= 1; \n\n        // Increase the power of 2\n        power *= 2; \n    }\n\n    printf(\"1011 0011 (Binary) = %d (Decimal)\\n\", decimal_val); // Output: 179\n\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#4-msd-and-lsd","title":"4. MSD and LSD","text":"<ul> <li>MSD (Most Significant Digit): Leftmost bit, highest value </li> <li>LSD (Least Significant Digit): Rightmost bit, lowest value</li> </ul> <p>Example: 0101 1101 MSD = 0 LSD = 1</p> <p>For an 8-bit number: - Bit 0: LSD (rightmost) - Bit 7: MSD (leftmost)</p> <p>check the LSD </p><pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    unsigned char x = 0b01011101; // 93\n    printf(\"MSD: %d\\n\", (x &gt;&gt; 7) &amp; 1);\n    printf(\"LSD: %d\\n\", x &amp; 1);\n    return 0;\n}\n</code></pre> <p>To access the LSD (Bit 0) of an int variable, the bitwise AND operator is commonly used: </p><pre><code>int num = 87; // ...0101 0111\n// LSD check: Is the number odd or even?\nif (num &amp; 1) { // 87 &amp; 1 = 1 (Odd)\n    // LSD is 1.\n}\n</code></pre>"},{"location":"c/2_number_systems/#5-unsigned-and-signed-numbers","title":"5. Unsigned and Signed Numbers","text":""},{"location":"c/2_number_systems/#unsigned","title":"Unsigned","text":"<p>Represents only positive numbers: 0000 0000 \u2192 0 1111 1111 \u2192 255</p>"},{"location":"c/2_number_systems/#signed","title":"Signed","text":"<p>The leftmost bit is the sign bit: - 0 \u2192 Positive - 1 \u2192 Negative  </p> <p>Note: Integer types in C (e.g., int) are signed by default. Declaring them as unsigned doubles the number's range because the leftmost bit (MSB/MSD) is used as a value bit instead of a sign bit.</p> <p>Signed and Unsigned Undefined Behavior </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;limits.h&gt; // For INT_MAX\n\nint main() {\n    // Assuming a 4-byte (32-bit) system\n\n    int signed_max = INT_MAX; \n    unsigned int unsigned_num = signed_max;\n\n    // Signed int has reached its positive maximum value: 0111...111\n    printf(\"Signed Max: %d\\n\", signed_max);\n\n    // Adding 1 to Signed Max causes an overflow (Section 9: Overflow)\n    int overflow_num = signed_max + 1;\n    printf(\"Signed Overflow: %d\\n\", overflow_num); // Output: -2147483648 (Minimum negative number)\n\n    // For Unsigned int (no sign bit), this is just a value increase: 1000...000\n    printf(\"Unsigned Max + 1: %u\\n\", unsigned_num + 1); \n\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#6-ones-complement","title":"6. One\u2019s Complement","text":"<p>The one\u2019s complement of a number is obtained by inverting all its bits:</p> Original One\u2019s Complement 1011 0100 1100 0011 0011 1100 <p>1 \u2192 0, 0 \u2192 1  </p> <p>The one\u2019s complement of a number\u2019s one\u2019s complement is the number itself. </p><pre><code>#include &lt;stdio.h&gt;\n\nvoid onesComplement(unsigned char x) {\n    unsigned char result = ~x;\n    printf(\"Original: 0x%X, One's Complement: 0x%X\\n\", x, result);\n}\n\nint main() {\n    onesComplement(0b10101100);\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#7-twos-complement","title":"7. Two\u2019s Complement","text":"<p>Definition: Add 1 to the one\u2019s complement of a number.</p> Number One\u2019s Complement +1 Two\u2019s Complement 0101 1000 1010 0111 +1 1010 1000 <p>Alternative shortcut: - Go from right to left, - Copy bits until the first 1 is encountered, - Invert the remaining bits.</p> <p>Example: 1110 0100 \u2192 0001 1100</p> <p>The two\u2019s complement of a number\u2019s two\u2019s complement is the number itself.</p>"},{"location":"c/2_number_systems/#calculating-ones-and-twos-complement","title":"Calculating One's and Two's Complement","text":"<p>Note: The Bitwise NOT (~) operator in C easily calculates the One's Complement of a number. To obtain the Two's Complement, simply add 1 to the result. </p><pre><code>#include &lt;stdio.h&gt;\n\nvoid twosComplement(unsigned char x) {\n    unsigned char ones = ~x;\n    unsigned char twos = ones + 1;\n    printf(\"Original: 0x%X, Two's Complement: 0x%X\\n\", x, twos);\n}\n\nint main() {\n    twosComplement(0b01011000);\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#8-representation-of-negative-numbers","title":"8. Representation of Negative Numbers","text":"<p>Negative numbers are represented using two\u2019s complement.</p> <p>Example: Represent <code>-27</code> in 8-bit signed binary:</p> <ol> <li>Binary of 27 \u2192 <code>0001 1011</code> </li> <li>One\u2019s complement \u2192 <code>1110 0100</code> </li> <li>Add 1 \u2192 <code>1110 0101</code></li> </ol> <p>Result: -27 \u2192 1110 0101</p>"},{"location":"c/2_number_systems/#examples","title":"Examples","text":"Decimal Binary (8-bit) Description 127 0111 1111 Maximum positive -128 1000 0000 Minimum negative -1 1111 1111 All bits are 1 <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    signed char pos = 27;\n    signed char neg = -27;\n\n    printf(\"27 binary: %d\\n\", pos);\n    printf(\"-27 binary (two's complement): %d\\n\", neg);\n    printf(\"Raw bytes: 0x%X and 0x%X\\n\", (unsigned char)pos, (unsigned char)neg);\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#9-number-overflow","title":"9. Number Overflow","text":"<p>In signed systems, adding 1 to the maximum positive number wraps into the negative range:</p> <p>0111 1111 (127) +1 1000 0000 (-128)</p> <p>Similarly, subtracting 1 from -128 wraps to 127.</p>"},{"location":"c/2_number_systems/#undefined-behavior-signed-overflow","title":"Undefined Behavior (Signed Overflow)","text":"<p>Note: In C, operations that exceed the range of an integer type (e.g., a value greater than 2^31 - 1 for signed int) can lead to undefined behavior. However, the value typically wraps into the type's negative range. For unsigned integers, overflow is guaranteed and wraps back from the lowest value using modulus arithmetic.</p> <pre><code>#include &lt;stdio.h&gt;\n#include &lt;limits.h&gt;\n\nint main() {\n    int max_val = INT_MAX; \n\n    // The compiler is not required to follow a specific rule in the case of signed int overflow.\n    // On most systems, it wraps to the value -2147483648 (INT_MIN).\n    int result = max_val + 1; \n\n    printf(\"INT_MAX + 1 = %d\\n\", result); \n\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#10-hexadecimal-system","title":"10. Hexadecimal System","text":"<p>Each hex digit represents 4 bits:</p> Hex Binary Decimal 0 0000 0 1 0001 1 2 0010 2 ... ... ... A 1010 10 F 1111 15 <p>Example: 2ADF\u2081\u2086 = 0010 1010 1101 1111\u2082</p> <p>To check if a number is negative, look at the leftmost hex digit: If it is in [8\u2013F], the number is negative. </p><pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int x = 0x2ADF;  // hexadecimal literal\n    printf(\"Hex: 0x%X, Decimal: %d, Binary: \", x, x);\n\n    for (int i = 15; i &gt;= 0; i--)\n        printf(\"%d\", (x &gt;&gt; i) &amp; 1);\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#11-octal-system","title":"11. Octal System","text":"<p>Each octal digit is represented by 3 bits:</p> Octal Binary 0 000 1 001 2 010 3 011 4 100 5 101 6 110 7 111 <p>Example: 765\u2088 = 111 110 101\u2082</p> <p>ex: output formatting Note: In the printf function, we can output hexadecimal values using %x or %X, and octal values using %o. </p><pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int num = 450; // 0x1C2 in Hex, 0702 in Octal\n\n    printf(\"Decimal: %d\\n\", num);\n\n    // Hexadecimal output format\n    printf(\"Hexadecimal (Lower): %x\\n\", num); \n    printf(\"Hexadecimal (Upper): %X\\n\", num);\n\n    // Octal output format\n    printf(\"Octal: %o\\n\", num); \n\n    // Formatting with prefix 0x\n    printf(\"Hex with prefix: %#X\\n\", num); \n\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#12-representation-of-real-numbers-in-memory-ieee-754","title":"12. Representation of Real Numbers in Memory (IEEE 754)","text":"<p>Real numbers are stored in memory according to the IEEE 754 standard.</p>"},{"location":"c/2_number_systems/#single-precision-32-bit","title":"Single Precision (32-bit)","text":"<p>S EEEEEEEE FFFFFFFFFFFFFFFFFFFFFFF</p> Field Bits Description S 1 Sign bit E 8 Exponent F 23 Fraction (mantissa) <p>Formula: V = (-1)^S \u00d7 2^(E - 127) \u00d7 (1.F) Example: 0 10000001 10100000000000000000000 \u2192 +6.5</p>"},{"location":"c/2_number_systems/#double-precision-64-bit","title":"Double Precision (64-bit)","text":"<p>S EEEEEEEEEEE FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF Formula: V = (-1)^S \u00d7 2^(E - 1023) \u00d7 (1.F)</p>"},{"location":"c/2_number_systems/#13-ieee-754-special-cases","title":"13. IEEE 754 Special Cases","text":"Case E F Result 255/2047 \u22600 \u22600 NaN (Not a Number) 255/2047 =0, S=1 -\u221e 255/2047 =0, S=0 +\u221e 0 =0 +0 / -0 0 \u22600 Denormalized number <pre><code>#include &lt;stdio.h&gt;\n\nvoid printFloatBits(float f) {\n    unsigned int bits = *(unsigned int *)&amp;f;\n    printf(\"Float: %.2f\\nBits : \", f);\n    for (int i = 31; i &gt;= 0; i--) {\n        printf(\"%d\", (bits &gt;&gt; i) &amp; 1);\n        if (i == 31 || i == 23) printf(\" \");\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    float x = 6.5f;\n    float y = -6.5f;\n    printFloatBits(x);\n    printFloatBits(y);\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#additional-examples","title":"Additional examples:","text":""},{"location":"c/2_number_systems/#1-ieee-754-inspection","title":"1. IEEE 754 Inspection","text":"<p>The following code uses Pointer and Union structures to inspect how a float number is represented in memory according to the IEEE 754 standard (bit-by-bit). This is one of examples of C's low-level access power. </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt; // For uint32_t\n\n// Union is used to define different types sharing the same memory location\ntypedef union {\n    float f;\n    uint32_t u; // IEEE 754 single precision = 32 bits (4 bytes)\n} FloatConverter;\n\nvoid display_ieee754(float number) {\n    FloatConverter converter;\n    converter.f = number;\n\n    uint32_t bits = converter.u;\n\n    printf(\"Input Number (Float): %.6f\\n\", number);\n\n    // 1. Sign Bit - Bit 31\n    uint32_t sign = (bits &gt;&gt; 31) &amp; 1;\n    printf(\"1. Sign Bit (S): %u\\n\", sign);\n\n    // 2. Exponent - Bits 30 to 23 (8 bits)\n    uint32_t exponent = (bits &gt;&gt; 23) &amp; 0xFF;\n    printf(\"2. Exponent (E): %u (Hex: 0x%X)\\n\", exponent, exponent);\n\n    // 3. Fraction (Mantissa) - Bits 22 to 0 (23 bits)\n    uint32_t fraction = bits &amp; 0x7FFFFF;\n    printf(\"3. Fraction (F): 0x%X\\n\", fraction);\n\n    // Note: This operation is critical for understanding data representation at the hardware level in the C language.\n}\n\nint main() {\n    // The value 6.5f (S=0, E=10000001, F=101000...)\n    display_ieee754(6.5f); \n\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#2-binary-to-decimal","title":"2. binary to decimal","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n\nint binary_to_decimal(const char *binary) {\n    int len = strlen(binary);\n    int decimal = 0;\n    for (int i = 0; i &lt; len; i++) {\n        if (binary[len - 1 - i] == '1') {\n            decimal += pow(2, i);\n        }\n    }\n    return decimal;\n}\n\nint main(){\n    char binary[] = \"1101\"; // Example binary number\n    printf(\"Binary %s = Decimal %d\\n\", binary,binary_to_decimal(binary) );\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#3-decimal-to-binary","title":"3. decimal to binary","text":"<pre><code>#include &lt;stdio.h&gt;\n\nvoid decimalToBinary(int decimal){\n    int bits[32];\n    int index = 0;\n    while (decimal &gt; 0){\n        bits[index++] = decimal % 2;\n        decimal /= 2;\n    }\n    for (int i = index - 1; i &gt;= 0; i--){\n        printf(\"%d\", bits[i]);\n    }\n}\n\n\nint main() {\n    int n = 87;\n    printf(\"%d in binary: \", n);\n    decimalToBinary(n);\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#4-endianness-control-and-byte-order-swapping","title":"4. Endianness Control and Byte Order Swapping","text":"<p>This code demonstrates how to check a system's Endianness (byte order) using a Union and provides a portable function to swap the byte order of a 32-bit integer using Bitwise Operators. </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\n// Function to check system Endianness\n// Return 1 for Little-Endian, 0 for Big-Endian\nint check_endianness() {\n    // Union allows accessing the 32-bit integer as an array of 8-bit bytes\n    union {\n        uint32_t value; // 4-byte integer\n        uint8_t bytes[4]; // 4 1-byte integers\n    } test;\n\n    test.value = 0x01020304; // Assign a known pattern (MSB=0x01, LSB=0x04)\n\n    // Little-Endian: The least significant byte (0x04) is stored first (at index 0/lowest address).\n    // Big-Endian: The most significant byte (0x01) is stored first (at index 0/lowest address).\n\n    // Check the value of the first byte (lowest address)\n    if (test.bytes[0] == 0x04) {\n        return 1; // Little-Endian\n    } else {\n        return 0; // Big-Endian (or exotic system)\n    }\n}\n\n// Function to swap the byte order of a 32-bit integer (Endian Swap)\nuint32_t swap_endian(uint32_t val) {\n    // Uses bitwise shifts and AND masks for a portable swap operation\n\n    return ((val &amp; 0xFF000000) &gt;&gt; 24) | // Move Byte 3 (MSB) to Byte 0 (LSB) position\n           ((val &amp; 0x00FF0000) &gt;&gt; 8) |  // Move Byte 2 to Byte 1 position\n           ((val &amp; 0x0000FF00) &lt;&lt; 8) |  // Move Byte 1 to Byte 2 position\n           ((val &amp; 0x000000FF) &lt;&lt; 24); // Move Byte 0 (LSB) to Byte 3 (MSB) position\n}\n\n\nint main() {\n    uint32_t original_value = 0x1A2B3C4D; // Example value\n    uint32_t swapped_value;\n\n    printf(\"Original Value: 0x%X\\n\", original_value);\n\n    // 1. Check Endianness\n    if (check_endianness()) {\n        printf(\"System Endianness: Little-Endian\\n\");\n    } else {\n        printf(\"System Endianness: Big-Endian\\n\");\n    }\n\n    // 2. Perform Endian Swap\n    swapped_value = swap_endian(original_value);\n    printf(\"Swapped Value : 0x%X\\n\", swapped_value);\n\n    // Expected Swapped Result: 0x1A2B3C4D becomes 0x4D3C2B1A \n\n    return 0;\n}\n</code></pre>"},{"location":"c/2_number_systems/#5-interpreting-signedunsigned-integers-via-bit-pattern","title":"5. Interpreting Signed/Unsigned Integers via Bit Pattern","text":"<p>This example illustrates the difference between implicit type conversion (which may cause sign extension) and pointer casting (which reinterprets the bits in memory) for signed and unsigned integers, demonstrating how the same bit pattern can represent vastly different values. </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt;\n\nvoid analyze_conversion() {\n    // 1. Small, Negative Signed Number (8-bit)\n    int8_t signed_char_val = -10; // 8-bit Two's Complement: 1111 0110\n\n    // 2. Implicit Conversion to Wider Unsigned Type\n    // C rule: signed_char_val is first promoted to int (with sign extension), then converted to unsigned int.\n    uint32_t unsigned_int_val = signed_char_val; \n\n    // 3. Illustrating Sign Extension in Conversion\n    // The bit pattern of signed_char_val (which is 0xFFFFFFF6 as a 32-bit int) is interpreted as a uint32_t.\n    // Result is the large positive number (4294967286)\n\n    printf(\"--- Implicit Conversion of Negative Number to Wider Unsigned Type ---\\n\");\n    printf(\"Original Value (int8_t): %d\\n\", signed_char_val);\n    printf(\"Unsigned Value (uint32_t): %u\\n\", unsigned_int_val);\n\n    // Rationale: C performed sign extension:\n    // 1111 0110 (-10) -&gt; 1111 1111 1111 1111 1111 1111 1111 0110 (32-bit int)\n    // This bit pattern, when interpreted as uint32_t, becomes a large positive number.\n\n    // 4. Interpreting Bit Pattern via Pointer Casting\n    int32_t signed_int_val = -1; // 32-bit: 1111...1111\n\n    // Pointer cast: Changes the type of the memory address, does not copy the data, only reinterprets it.\n    // The bit pattern in memory remains the same.\n    uint32_t *unsigned_ptr = (uint32_t *)&amp;signed_int_val;\n\n    printf(\"\\n--- Interpretation via Pointer Casting ---\\n\");\n    printf(\"Original Value (int32_t): %d\\n\", signed_int_val);\n    // The bit pattern 0xFFFFFFFF, when interpreted as uint32_t, equals the maximum unsigned value.\n    printf(\"Pointer Interpretation (uint32_t): %u\\n\", *unsigned_ptr); \n\n    // Note: Casting the pointer provides a guaranteed way to get the unsigned counterpart of a negative number's bit pattern.\n}\n\nint main() {\n    analyze_conversion();\n    return 0;\n}\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/","title":"General Concepts and Terms","text":""},{"location":"c/3_general_concepts_and_terms/#general-concepts-and-terms","title":"General Concepts and Terms","text":""},{"location":"c/3_general_concepts_and_terms/#1-tokens-and-their-types","title":"1. Tokens and Their Types","text":"<p>The smallest meaningful parts of a source file written in a programming language are called tokens. Before a C program is compiled, it is broken down into tokens (tokenizing / lexical analysis).</p> <p>Tokens are divided into 6 basic groups:</p>"},{"location":"c/3_general_concepts_and_terms/#11-keywords","title":"1.1 Keywords","text":"<p>These are words with predefined special meanings in the C language. These words cannot be used for any other purpose (e.g., as variable names).</p>"},{"location":"c/3_general_concepts_and_terms/#c89-standard-keywords-32-in-total","title":"C89 Standard Keywords (32 in total)","text":"<pre><code>auto break case char const continue default do double else enum extern \nfloat for goto if int long register return short signed sizeof static \nstruct switch typedef union unsigned void volatile while\n</code></pre> <p>Note: - The C language is case-sensitive. - Therefore, <code>register</code> is a keyword, but <code>REGISTER</code> or <code>Register</code> can be used.</p>"},{"location":"c/3_general_concepts_and_terms/#12-identifiers","title":"1.2 Identifiers","text":"<p>These are the names given to variables, functions, macros, or constants. The validity of identifiers is defined by specific rules (for example, they must start with a letter and cannot contain spaces).</p> <pre><code>int counter;\nfloat average;\nchar name[20];\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#13-operators","title":"1.3 Operators","text":"<p>These are symbols that perform predefined operations. For example, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>&gt;=</code>, <code>&lt;=</code> are operators. There are 45 operators in the C language.</p> <p>Some operators consist of two characters and do not contain spaces: <code>++</code>, <code>--</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code></p> <p>For example, exponentiation (<code>^</code>) is not an operator in C; instead, the pow() function is used.</p> <pre><code>#include &lt;math.h&gt;\nint main() {\n    double result = pow(2, 3); // 2 to the power of 3\n}\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#14-constants","title":"1.4 Constants","text":"<p>These are atoms whose values do not change throughout the program.</p> <pre><code>int a = 10;       // 10 is an integer constant\nfloat pi = 3.14;  // 3.14 is a real number constant\nchar c = \u2018A\u2019;     // Character constant\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#15-strings","title":"1.5 Strings","text":"<p>These are fixed character sequences enclosed in double quotes. A string is treated as a single atom in a program.</p> <pre><code>printf(\u201cHello World!\u201d);\n</code></pre> <p><code>\u201cSTRINGS ARE ALSO ATOMS\u201d</code> is a string.</p>"},{"location":"c/3_general_concepts_and_terms/#16-delimiters-and-punctuation-marks","title":"1.6 Delimiters and Punctuation Marks","text":"<p>Used to separate atoms from each other. Examples: </p><pre><code>( ) , ; { } [ ] &lt; &gt; # \" '\n</code></pre> <p>Translated with DeepL.com (free version)</p>"},{"location":"c/3_general_concepts_and_terms/#2-breaking-down-a-c-program-into-its-building-blocks","title":"2. Breaking Down a C Program into Its Building Blocks","text":"<p>Example program:</p> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int number, k;\n    int total = 0;\n\n    printf(\u201cPlease enter a number\\n\u201d);\n    scanf(\u201c%d\u201d, &amp;number);\n\n    for (k = 1; k &lt;= number; ++k)\n        total += k;\n\n    printf(\u201cTotal = %d\\n\u201d, total);\n    return 0;\n}\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#the-atoms-of-this-program","title":"The atoms of this program:","text":"Type Examples Keywords include, int, for, return Names main, number, total, printf, scanf Operators =, &lt;=, ++, += Constants 0, 1 Strings \u201cplease enter a number\\n\u201d, \u201c%d\u201d, \u201ctotal = %d\\n\u201d Delimiters &lt;, &gt;, (, ), {, }, ;, ,"},{"location":"c/3_general_concepts_and_terms/#3-object","title":"3. Object","text":"<p>These are areas that occupy space in memory and whose contents can be accessed. For an expression to be considered an object, it must have a physical address in memory.</p> <pre><code>int a = 10;\nint b = 20;\nint result = a + b;\n</code></pre> <ul> <li><code>a</code>, <code>b</code>, <code>result</code> \u2192 are objects.  </li> <li><code>10</code>, <code>20</code> \u2192 are constants (not objects).</li> </ul>"},{"location":"c/3_general_concepts_and_terms/#properties-of-objects","title":"Properties of Objects","text":"Property Description Name The name given by the programmer. Value The information stored in memory by the object. Type The length and interpretation format of the object in memory. <p>Each type occupies a different amount of space in memory. For example, <code>int</code> is 4 bytes, <code>char</code> is 1 byte, <code>double</code> is 8 bytes.</p> <p>Every variable is an object, but not every object is a variable (e.g., pointers).</p>"},{"location":"c/3_general_concepts_and_terms/#4-data-types","title":"4. Data Types","text":""},{"location":"c/3_general_concepts_and_terms/#41-built-in-types","title":"4.1 Built-in Types","text":"<p>There are 11 built-in types in the C language. Examples: <code>int</code>, <code>float</code>, <code>double</code>, <code>char</code>, <code>void</code>, <code>short</code>, <code>long</code>, <code>signed</code>, <code>unsigned</code>, <code>enum</code>, <code>struct</code></p>"},{"location":"c/3_general_concepts_and_terms/#42-user-defined-types","title":"4.2 User-Defined Types","text":"<p>Programmers can define their own types using <code>struct</code>, <code>union</code>, or <code>enum</code>.</p> <pre><code>typedef struct {\n    char name[20];\n    int age;\n} Person;\n</code></pre> <p>There is no <code>bool</code> type in C89. Logical values are typically represented using <code>int</code> (<code>0</code> = false, <code>1</code> = true).</p>"},{"location":"c/3_general_concepts_and_terms/#5-scope","title":"5. Scope","text":"<p>The program area where a name can be recognized by the compiler.</p> <pre><code>int x = 10; // global scope\n\nvoid func() {\n    int y = 20; // local scope\n    printf(\u201c%d %d\u201d, x, y);\n}\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#6-storage-duration","title":"6. Storage Duration","text":"<p>The time interval during which an object exists while the program is running.</p> Type Description Automatic (auto) Defined within a function, disappears when the function ends. Static (static) Remains in memory for the duration of the program. Dynamic (malloc/free) Managed by the programmer. <pre><code>void f() {\n    static int count = 0;\n    count++;\n    printf(\u201c%d\\n\u201d, count);\n}\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#7-linkage","title":"7. Linkage","text":"<p>The ability of an object to be recognized in other modules of the program.</p> <pre><code>// file1.c\nint globalVar = 42;\n\n// file2.c\nextern int globalVar;\nprintf(\u201c%d\u201d, globalVar);\n</code></pre> <p>The <code>extern</code> keyword indicates that the variable is defined in another file.</p>"},{"location":"c/3_general_concepts_and_terms/#8-expression","title":"8. Expression","text":"<p>It is a combination of variables, operators, and constants.</p> <pre><code>a + b / 2\nc * 2\nd = h + 34\n</code></pre> <p>Every expression produces a value.</p>"},{"location":"c/3_general_concepts_and_terms/#9-left-hand-side-value-l-value-expression","title":"9. Left-Hand Side Value (L-Value expression)","text":"<p>These are expressions that represent an object in memory. They can be found on the left side of an assignment.</p> <pre><code>int a, b;\na = 17;     // \u2018a\u2019 is an l-value\nb = a + 2;  // \u2018b\u2019 is an l-value, (a + 2) is an r-value\n</code></pre> <p><code>a + b = 25;</code> \u2192 invalid because <code>(a + b)</code> does not refer to an object.</p>"},{"location":"c/3_general_concepts_and_terms/#10-right-hand-side-value-r-value-expression","title":"10. Right-Hand Side Value (R-Value expression)","text":"<p>These are expressions that do not refer to an object, but only produce a value. They can be placed on the right side of an assignment.</p> <pre><code>int a = 10;\nint b = a + 5; // (a + 5) is an r-value\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#11-constant-expressions","title":"11. Constant Expressions","text":"<p>These are expressions consisting only of constants. They can be evaluated by the compiler during the compilation phase.</p> <pre><code>#define SIZE 10\nint arr[SIZE + 5]; // the compiler can calculate this\n</code></pre> <p>Examples: </p><pre><code>10\n3.5\n10 + 20\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#12-statement","title":"12. Statement","text":"<p>In C, it means a complete command and ends with <code>;</code>.</p> <pre><code>result = number1 * number2;\n</code></pre> <p>Some statements only provide information: - Declaration statements \u2192 provide information to the compiler. - Executable statements \u2192 perform an operation.</p> <pre><code>int x;            // declaration\nx = 5;            // executable statement\nprintf(\u201c%d\u201d, x);  // executable statement\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#additional-codes","title":"Additional Codes","text":""},{"location":"c/3_general_concepts_and_terms/#1-basic-l-value-and-r-value-assignment","title":"1. Basic L-value and R-value Assignment","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int x = 10;\n    int y = 5;\n\n    // L-value: x (persistent memory location)\n    // R-value: y + 2 (temporary value calculated on the fly)\n    x = y + 2; \n\n    printf(\"x = %d, y = %d\\n\", x, y);\n    return 0;\n}\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#2-modifying-memory-via-pointer-dereference-l-value","title":"2. Modifying Memory via Pointer Dereference (L-value)","text":"<pre><code>#include &lt;stdio.h&gt;\n/*\nIf you can take the address of an expression using '&amp;', it is an **L-value**.\n*/\nint main() {\n    int x = 10;\n    // &amp;x is valid because x is an L-value\n    printf(\"Address of x: %p\\n\", (void*)&amp;x); \n\n    // printf(\"%p\", &amp;(x + 1)); // \u274c Error: (x + 1) is an R-value (temporary result)\n    return 0;\n}\n</code></pre> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int a = 10;\n    int *p = &amp;a; // p stores the address of a\n\n    *p = 25;  // *p is an L-value because it refers to memory location 'a'\n    printf(\"a = %d\\n\", a);\n    return 0;\n}\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#3-function-return-values-as-l-values-or-r-values","title":"3. Function Return Values as L-values or R-values","text":"<pre><code>#include &lt;stdio.h&gt;\n\n// Returns an R-value (a copy of the static value)\nint func1() {\n    static int x = 5;\n    return x;  \n}\n\n// Returns a pointer (an L-value address)\nint* func2() {\n    static int y = 10;\n    return &amp;y; // Returns the persistent address of 'y'\n}\n\nint main() {\n    // func1() = 20; \u274c Error: func1 returns an R-value (a temporary value)\n\n    // *func2() is an L-value because it dereferences a persistent address (the address of static int y)\n    *func2() = 30;   // \u2705 Valid: Modifies the static variable 'y'\n\n    printf(\"Value pointed to by func2(): %d\\n\", *func2()); // Output: 30\n    return 0;\n}\n</code></pre>"},{"location":"c/3_general_concepts_and_terms/#4-counter","title":"4. counter","text":"<pre><code>// counter_module.c\n\n#include &lt;stdio.h&gt;\n\n// Global 'count' variable with internal linkage (only visible in this file)\n// Static Storage Duration guaranteed.\nstatic int private_counter = 0; \n\n// Function with external linkage (visible to other files via header)\n// Increments the internal static counter\nvoid increment_counter(void) {\n    private_counter++;\n}\n\n// Function with external linkage\n// Returns the internal counter's value (R-value)\nint get_counter_value(void) {\n    return private_counter;\n}\n\n// Advanced: Returns a pointer to a static local L-value\n// The L-value itself (the static variable) has persistent storage duration.\nint* get_static_local_lvalue(void) {\n    // Static local variable: Block scope, but Static Storage Duration\n    static int persistent_config = 99; \n    return &amp;persistent_config; // Returns the address of the L-value\n}\n</code></pre> <pre><code>// counter_module.h\n\n#ifndef COUNTER_MODULE_H\n#define COUNTER_MODULE_H\n\n// Declarations (External Linkage assumed by default for functions)\nvoid increment_counter(void);\nint get_counter_value(void);\n\n// Declaration for the advanced L-value return function\nint* get_static_local_lvalue(void); \n\n// Note: The variable 'private_counter' itself is NOT declared here, \n// ensuring internal linkage and data hiding.\n\n#endif // COUNTER_MODULE_H\n</code></pre> <pre><code>// main.c\n\n#include &lt;stdio.h&gt;\n#include \"counter_module.h\" // Includes function prototypes\n\nint main() {\n    printf(\"--- Module Access and Linkage Test ---\\n\");\n\n    // 1. Storage Duration &amp; Scope Test\n\n    // Call the function to increment the hidden counter\n    increment_counter();\n    increment_counter();\n\n    // Access the value using the public getter function\n    printf(\"Counter value after 2 increments: %d\\n\", get_counter_value()); // Output: 2\n\n    // 2. L-value Manipulation Test (Advanced)\n\n    // Get the address of the static local L-value from the module\n    int *config_ptr = get_static_local_lvalue(); \n\n    // *config_ptr is an L-value expression; its address is persistent.\n    // We can directly modify the value stored at that persistent memory location.\n    *config_ptr = 500; \n\n    printf(\"Static local variable modified to: %d\\n\", *config_ptr); // Output: 500\n\n    // 3. Linkage Failure Attempt (Illustrative Note)\n\n    /* // int check_counter = private_counter; \n    // \u274c ERROR: private_counter has internal linkage and is NOT accessible here.\n    // The extern keyword would not work unless the variable was defined globally \n    // without 'static' in counter_module.c.\n    */\n\n    return 0;\n}\n</code></pre>"},{"location":"c/4_creating_a_c_program/","title":"Creating a C Program","text":""},{"location":"c/4_creating_a_c_program/#creating-a-c-program","title":"Creating a C Program","text":""},{"location":"c/4_creating_a_c_program/#1-creating-the-source-file","title":"1. Creating the Source File","text":"<p>C programs are written as text-based source files. These files are usually created using a text editor.</p> <ul> <li>Files are written according to the syntax rules of the C language.  </li> <li>Traditionally, C source files have the extension <code>.c</code>.</li> </ul> <p>For example: </p><pre><code>main.c\nmathutils.c\n</code></pre> <p>The source file contains only plain text; it cannot be run before compilation.</p>"},{"location":"c/4_creating_a_c_program/#2-compilation-stage","title":"2. Compilation Stage","text":"<p>Programs that translate a program written in one programming language into another language are called translators. In the C language, the translator that does this job is called a compiler.</p>"},{"location":"c/4_creating_a_c_program/#compilation-process","title":"Compilation Process","text":"<ul> <li>The compiler takes the source file.  </li> <li>It checks whether it complies with the syntax rules.  </li> <li>If successful, it produces an object file.  </li> <li>If unsuccessful, it gives an error or warning message.</li> </ul>"},{"location":"c/4_creating_a_c_program/#compile-time","title":"Compile Time","text":"<p>The stage during which the compiler processes the source file is called compile time. During this stage, the following types of messages may be generated:</p> Type Description Result Error message Syntax or language rule violation Compilation fails, object file is not created Warning message Potential logical error Compilation may complete, object file is produced <p>According to C standards, compilers report not only syntax errors but also potential logical errors as warnings.</p>"},{"location":"c/4_creating_a_c_program/#3-object-files","title":"3. Object Files","text":"<p>Files produced during the compilation phase are files that have been translated into machine language but cannot yet be run independently.</p> Operating System Extension Example UNIX / Linux <code>.o</code> <code>main.o</code> Windows / DOS <code>.obj</code> <code>main.obj</code> <p>Object files are usually combined during the linking phase.</p>"},{"location":"c/4_creating_a_c_program/#4-linker-program","title":"4. Linker Program","text":"<p>The linker combines one or more compiled object files to create an executable file.</p>"},{"location":"c/4_creating_a_c_program/#result-files","title":"Result Files","text":"Operating System Extension Example UNIX / Linux (usually no extension) <code>program</code> Windows <code>.exe</code> <code>program.exe</code> <p>\ud83d\udd39 The linker also incorporates external libraries (such as <code>stdio.h</code>, <code>math.h</code>) into the program.</p>"},{"location":"c/4_creating_a_c_program/#5-compiler-programs","title":"5. Compiler Programs","text":"<p>Compilers are generally designed to be run from the command line. This allows them to be easily called by other tools or IDEs.</p> Platform Compiler Executable File Microsoft Windows MSVC <code>cl.exe</code> UNIX / Linux GNU C Compiler <code>gcc</code> or <code>clang</code>"},{"location":"c/4_creating_a_c_program/#example-compilers","title":"Example Compilers","text":"<ul> <li>GCC (GNU Compiler Collection) \u2192 popular, open source.  </li> <li>Clang \u2192 a modern and fast alternative.  </li> <li>MSVC \u2192 Microsoft Visual C/C++ compiler.</li> </ul>"},{"location":"c/4_creating_a_c_program/#6-ide-integrated-development-environment","title":"6. IDE (Integrated Development Environment)","text":"<p>An IDE is not a compiler. It is a development environment that runs the compiler in the background and facilitates software development.</p> IDE Compiler Used Dev-C++ GCC Code::Blocks GCC or Clang Visual Studio MSVC MinGW GCC (for Windows) <p>An IDE can automatically perform compilation and linking operations and present error messages to the user in an easy-to-understand manner.</p>"},{"location":"c/4_creating_a_c_program/#7-preprocessor","title":"7. Preprocessor","text":"<p>In C and C++, it is a program that runs before the compilation stage. At this stage, text-based operations are performed on the source code (e.g., <code>#include</code>, <code>#define</code>).</p> <p>Before passing to the compiler, the preprocessor: - Processes macros (<code>#define</code>), - Performs file inclusions (<code>#include</code>), - Evaluates conditional compilation directives (<code>#ifdef</code>, <code>#ifndef</code>).</p> <p>The preprocessor is a separate program, but most modern compilers (e.g., GCC) call it automatically.</p>"},{"location":"c/4_creating_a_c_program/#8-general-summary-of-the-process","title":"8. General Summary of the Process","text":"<p>The C program development process goes through the following steps:</p> <pre><code>Source Code (.c)\n      \u2193\n  [Preprocessor]\n      \u2193\n  [Compiler]\n      \u2193\n  Object File (.obj / .o)\n      \u2193\n  [Linker]\n      \u2193\nExecutable Program (.exe / program)\n</code></pre>"},{"location":"c/4_creating_a_c_program/#9-example-codes","title":"9. Example codes","text":""},{"location":"c/4_creating_a_c_program/#mainc-mathutilsc-mathutilsh","title":"main.c mathutils.c mathutils.h","text":"<pre><code>// mathutils.h\n\n#ifndef MATHUTILS_H\n#define MATHUTILS_H\n\n// Function declaration with external linkage\n// Declares that a function named 'calculate_distance' is defined elsewhere.\ndouble calculate_distance(int x1, int y1, int x2, int y2);\n\n#endif // MATHUTILS_H\n</code></pre> <pre><code>// mathutils.c\n// This module provides the mathematical implementation.\n\n#include \"mathutils.h\"\n#include &lt;math.h&gt; // Required for sqrt() and pow() function definitions\n\n// Definition of the function declared in mathutils.h\ndouble calculate_distance(int x1, int y1, int x2, int y2) {\n    // Uses the standard C math library functions\n    int dx = x2 - x1;\n    int dy = y2 - y1;\n\n    // pow(base, exponent) and sqrt() are external library functions (libm.a on Unix/Linux)\n    return sqrt(pow(dx, 2) + pow(dy, 2));\n}\n</code></pre> <pre><code>// main.c\n\n#include &lt;stdio.h&gt;\n#include \"mathutils.h\" // Includes the function prototype\n\nint main() {\n    int p1_x = 10, p1_y = 20;\n    int p2_x = 40, p2_y = 60;\n    double dist;\n\n    // Call the function defined in mathutils.c\n    dist = calculate_distance(p1_x, p1_y, p2_x, p2_y);\n\n    printf(\"Distance between (%d,%d) and (%d,%d) is: %.2lf\\n\",\n           p1_x, p1_y, p2_x, p2_y, dist);\n\n    return 0;\n}\n</code></pre>"},{"location":"c/4_creating_a_c_program/#91object-files","title":"9.1.Object files","text":"<pre><code>gcc -c main.c      # -&gt;main.o\ngcc -c mathutils.c # -&gt;mathutils.o\n</code></pre>"},{"location":"c/4_creating_a_c_program/#92linkage","title":"9.2.Linkage","text":"<pre><code>gcc main.o mathutils.o -o program\n</code></pre>"},{"location":"c/4_creating_a_c_program/#93run","title":"9.3.Run","text":"<pre><code>./program\n</code></pre>"},{"location":"c/4_creating_a_c_program/#generate-object-files-link-run","title":"Generate object files + link + run","text":"<pre><code>gcc main.c mathutils.c -o program\n./program\n</code></pre>"},{"location":"c/4_creating_a_c_program/#glossary-of-terms","title":"Glossary of Terms","text":"Term English Description Source file Source file Text file written by the programmer Compiler Compiler Converts source code to machine code Object file Object file Compiled but not yet executable code Linker Linker Combines object files Preprocessor Preprocessor Performs text processing before compilation IDE Integrated Development Environment Development environment"},{"location":"c/5_data_types/","title":"Data Types","text":""},{"location":"c/5_data_types/#data-types","title":"Data Types","text":""},{"location":"c/5_data_types/#1-what-is-a-type","title":"1. What is a Type?","text":"<p>An object's type determines how that object will be represented in memory and what operations can be performed on it. Type is an essential feature of an object. An object without a type cannot be discussed.</p> <p>Based on type information, the compiler determines: - How much space the data will occupy in memory, - How the 1s and 0s in memory will be interpreted, - Which operations can be performed on that data.</p>"},{"location":"c/5_data_types/#2-grouping-types","title":"2. Grouping Types","text":"<p>Types in the C language are divided into two main groups:</p> Type Group Description 1. Built-in Types Standard types that exist by design in the C language. (e.g., <code>int</code>, <code>float</code>, <code>char</code>) 2. User-defined Types Allows the programmer to define new types. (e.g., <code>struct</code>, <code>union</code>, <code>enum</code>) <p>If the predefined types are not sufficient, the programmer can define their own type using structures such as <code>typedef</code>, <code>struct</code>, <code>enum</code>, and <code>union</code>.</p>"},{"location":"c/5_data_types/#3-integer-types","title":"3. Integer Types","text":"<p>In the C language, integer types represent negative or positive integers. There are a total of 8 integer types (including signed and unsigned versions).</p>"},{"location":"c/5_data_types/#signed-and-unsigned","title":"Signed and Unsigned","text":"<ul> <li>Signed: Can hold negative and positive values.  </li> <li>Unsigned: Holds only positive values (and zero).</li> </ul>"},{"location":"c/5_data_types/#integer-types","title":"Integer Types","text":"Type Size (byte) Value Range Description <code>signed char</code> 1 -128 \u2192 +127 1 byte, signed character type <code>unsigned char</code> 1 0 \u2192 255 1 byte, unsigned character type <code>char</code> 1 Compiler-dependent May be signed or unsigned <code>short int</code> / <code>signed short int</code> 2 -32,768 \u2192 +32,767 Short integer <code>unsigned short int</code> 2 0 \u2192 65,535 Unsigned short integer <code>int</code> / <code>signed int</code> 2 or 4 -32,768 \u2192 +32,767 (2B) or -2,147,483,648 \u2192 +2,147,483,647 (4B) System-dependent <code>unsigned int</code> 2 or 4 0 \u2192 65,535 (2B) or 0 \u2192 4,294,967,295 (4B) System dependent <code>long int</code> / <code>signed long int</code> 4 -2,147,483,648 \u2192 +2,147,483,647 Long integer <code>unsigned long int</code> 4 0 \u2192 4,294,967,295 Long unsigned integer <code>long long int</code> (C99) 8 -9,223,372,036,854,775,808 \u2192 +9,223,372,036,854,775,807 Very large integers <code>unsigned long long int</code> (C99) 8 0 \u2192 18,446,744,073,709,551,615 <p>The <code>char</code> type must be 1 byte according to the C standard.</p>"},{"location":"c/5_data_types/#4-floating-point-types","title":"4. Floating-Point Types","text":"<p>There are 3 basic types for real numbers (floating-point numbers):</p> Type Size (byte) Precision Range (approx.) Description <code>float</code> 4 6 digits 1.17 \u00d7 10\u207b\u00b3\u2078 \u2192 3.40 \u00d7 10\u00b3\u2078 Single precision <code>double</code> 8 15 digits 2.22 \u00d7 10\u207b\u00b3\u2070\u2078 \u2192 1.17 \u00d7 10\u00b3\u2070\u2078 Double precision <code>long double</code> 8 / 10 / 12 System-dependent Not portable Extended precision"},{"location":"c/5_data_types/#ieee-754-standard","title":"IEEE 754 Standard","text":"<p>In the C language, the <code>float</code> and <code>double</code> types are generally maintained according to the IEEE 754 standard.</p> Component float (32 bits) double (64 bits) Sign bit 1 bit 1 bit Exponent 8 bits 11 bits Fraction / Mantissa 23 bits 52 bits <p>This provides approximately 6 digits of precision for <code>float</code> and 15 digits for <code>double</code>.</p>"},{"location":"c/5_data_types/#5-new-types-introduced-with-c99","title":"5. New Types Introduced with C99","text":"<p>The C99 standard added complex numbers and the bool type.</p> Type Size (byte) Description <code>_Bool</code> 1 Boolean type (<code>true</code> or <code>false</code>) <code>float _Complex</code> 8 Complex number (real and imaginary parts) <code>double _Complex</code> 16 <code>long double _Complex</code> 24 <code>float _Imaginary</code> 4 Imaginary part only <code>double _Imaginary</code> 8 <code>long double _Imaginary</code> 12"},{"location":"c/5_data_types/#6-ansi-c-portability-rules","title":"6. ANSI C Portability Rules","text":"<p>According to ANSI C standards, only certain type lengths are guaranteed:</p> <ul> <li>The <code>char</code> type must always be 1 byte.  </li> <li>The <code>short</code> \u2264 <code>int</code> \u2264 <code>long</code> rule always applies. </li> <li>Each type may have a different length depending on the system's processor architecture.</li> </ul>"},{"location":"c/5_data_types/#7-processor-architecture-examples","title":"7. Processor Architecture Examples","text":""},{"location":"c/5_data_types/#in-16-bit-systems","title":"In 16-bit systems","text":"Type Size <code>char</code> 1 byte <code>int</code> 2 bytes <code>short</code> 2 bytes <code>long</code> 4 bytes"},{"location":"c/5_data_types/#in-32-bit-systems","title":"In 32-bit systems","text":"Type Size <code>char</code> 1 byte <code>int</code> 4 bytes <code>short</code> 2 bytes <code>long</code> 4 bytes"},{"location":"c/5_data_types/#8-performance-and-usage-recommendations","title":"8. Performance and Usage Recommendations","text":"<ul> <li>Integers are faster to process than floating-point numbers.   This is because floating-point numbers are encoded in memory in a special format.  </li> <li>Unnecessary use of <code>float</code> or <code>double</code> can slow down the program.</li> <li>If integers are sufficient, <code>int</code> should be preferred.  </li> <li>If a larger range is required, <code>long</code> or <code>long long</code> can be used.  </li> <li>For real numbers, <code>double</code> should generally be the default choice.</li> </ul>"},{"location":"c/5_data_types/#additional-codes","title":"Additional codes","text":""},{"location":"c/5_data_types/#1-precision-and-speed-test","title":"1. precision and speed test","text":"<p>This code demonstrates the difference in precision between float and double and measures how much faster integer arithmetic is compared to floating-point arithmetic in a simple loop. </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;time.h&gt; // For performance measurement (clock_t)\n#include &lt;limits.h&gt; // For loop limits\n\n// Test parameters\n#define ITERATIONS 100000000\n#define CLOCK_UNIT CLOCKS_PER_SEC // Defined in &lt;time.h&gt;\n\nvoid analyze_float_precision() {\n    float f = 123456789.0f; \n    double d = 123456789.0;\n\n    printf(\"--- 1. Precision Test ---\\n\");\n    // float has around 6-7 digits of precision. The last digits are lost.\n    printf(\"Float (low precision): %.2f\\n\", f); \n    // Double retains higher precision.\n    printf(\"Double (high precision): %.2f\\n\", d); \n    printf(\"\\n\");\n}\n\nvoid analyze_performance_difference() {\n    clock_t start, end;\n    double time_used;\n    long i;\n\n    printf(\"--- 2. Performance Test (Iteration Count: %d) ---\\n\", ITERATIONS);\n\n    // Integer Arithmetic Test (Fast)\n    long int_sum = 0;\n    start = clock();\n    for (i = 0; i &lt; ITERATIONS; i++) {\n        int_sum += (i &amp; 0x0F); // Simple bitwise operation to ensure constant work\n    }\n    end = clock();\n    time_used = ((double)(end - start)) / CLOCK_UNIT;\n    printf(\"Integer Time (int_sum): %.4f seconds\\n\", time_used);\n\n\n    // Floating-Point Arithmetic Test (Slower)\n    double float_sum = 0.0;\n    start = clock();\n    for (i = 0; i &lt; ITERATIONS; i++) {\n        float_sum += (i * 1.0) / 10.0; // Floating point division and addition\n    }\n    end = clock();\n    time_used = ((double)(end - start)) / CLOCK_UNIT;\n    printf(\"Float Time (float_sum): %.4f seconds\\n\", time_used);\n\n    // Note: The integer operations are expected to be significantly faster due to the CPU architecture.\n}\n\nint main() {\n    analyze_float_precision();\n    analyze_performance_difference();\n    return 0;\n}\n</code></pre>"},{"location":"c/5_data_types/#2-defining-a-portable-structure","title":"2. Defining a Portable Structure","text":"<p>This code shows that the types in C are not portable (like the size of int) and, therefore, how we construct structures with known sizes using typedef and sizeof. This is critically important, especially in Data Structures and network programming. </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdint.h&gt; // For fixed-width integer types (e.g., int32_t, uint16_t)\n\n// Define a type whose size is strictly guaranteed for portability\n// This is crucial for Data Structures that rely on fixed sizes (like network packets or file storage).\ntypedef struct {\n    // We use types from stdint.h to ensure fixed sizes regardless of the system architecture.\n    uint16_t id;    // Guaranteed 2 bytes (short)\n    int32_t count;  // Guaranteed 4 bytes (int/long)\n    double price;   // Standard 8 bytes\n} ProductData;\n\n\nint main() {\n    ProductData item;\n\n    printf(\"--- Portable Type Analysis ---\\n\");\n\n    // 1. Check fixed sizes guaranteed by stdint.h\n    printf(\"Size of uint16_t (ID): %zu bytes\\n\", sizeof(uint16_t)); \n    printf(\"Size of int32_t (Count): %zu bytes\\n\", sizeof(int32_t));\n\n    // 2. Check the size of the structure itself (may include padding/alignment)\n    printf(\"Size of ProductData Structure: %zu bytes\\n\", sizeof(ProductData));\n\n    // 3. Robustly calculate array size using sizeof (as taught in the previous section)\n    int my_array[] = {10, 20, 30, 40, 50};\n    size_t array_length = sizeof(my_array) / sizeof(my_array[0]);\n    printf(\"Calculated Array Length (Robust): %zu\\n\", array_length);\n\n    // Note: Using int32_t instead of plain int ensures the structure layout is consistent \n    // across 16-bit, 32-bit, and 64-bit systems, which is vital for DSA and I/O.\n\n    return 0;\n}\n</code></pre>"},{"location":"c/5_data_types/#3-same-bit-in-different-data-type","title":"3. same bit in different data type","text":"<pre><code>#include &lt;stdio.h&gt;\n/*\n01000001 -&gt; 65 -&gt; 'A'\nthis bit pattern can represent different data types\n*/\n\nint main() {\n    int i = 65;\n    char c = 'A';\n\n    printf(\"int olarak: %d\\n\", i);\n    printf(\"char olarak: %c\\n\", c);\n    printf(\"Bellekte ayn\u0131 de\u011feri farkl\u0131 t\u00fcrle yorumlama: %c\\n\", (char)i);\n    return 0;\n}\n</code></pre>"},{"location":"c/5_data_types/#4-for-your-computer-sizeof","title":"4. for your computer sizeof","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;limits.h&gt;\n\nint main() {\n    printf(\"char: %zu byte, [%d, %d]\\n\", sizeof(char), CHAR_MIN, CHAR_MAX);\n    printf(\"short: %zu byte, [%d, %d]\\n\", sizeof(short), SHRT_MIN, SHRT_MAX);\n    printf(\"int: %zu byte, [%d, %d]\\n\", sizeof(int), INT_MIN, INT_MAX);\n    printf(\"long: %zu byte, [%ld, %ld]\\n\", sizeof(long), LONG_MIN, LONG_MAX);\n    printf(\"long long: %zu byte, [%lld, %lld]\\n\", sizeof(long long), LLONG_MIN, LLONG_MAX);\n    return 0;\n}\n</code></pre>"},{"location":"c/5_data_types/#5-signed-unsigned","title":"5. signed unsigned","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    signed char a = -1;\n    unsigned char b = -1;\n\n    printf(\"signed char a = %d\\n\", a);\n    printf(\"unsigned char b = %u\\n\", b);\n    return 0;\n}\n</code></pre>"},{"location":"c/5_data_types/#6-float-and-double","title":"6. float and double","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    float f = 1.0 / 3.0;\n    double d = 1.0 / 3.0;\n\n    printf(\"float = %.10f\\n\", f);\n    printf(\"double = %.20lf\\n\", d);\n    return 0;\n}\n</code></pre>"},{"location":"c/5_data_types/#7-ieee-754","title":"7. IEEE 754","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    float f = -6.5f;\n    unsigned int *p = (unsigned int*)&amp;f;\n\n    printf(\"float: %f\\nbinary: \", f);\n    for (int i = 31; i &gt;= 0; i--) {\n        printf(\"%d\", (*p &gt;&gt; i) &amp; 1);\n        if (i == 31 || i == 23) printf(\" \");\n    }\n    printf(\"\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"c/5_data_types/#8-c99-bool-complex","title":"8. C99 bool complex","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdbool.h&gt;\n#include &lt;complex.h&gt;\n\nint main() {\n    bool flag = true;\n    double complex z = 2.0 + 3.0 * I;\n\n    printf(\"bool \u00f6rne\u011fi: %d\\n\", flag);\n    printf(\"complex \u00f6rne\u011fi: %.1f + %.1fi\\n\", creal(z), cimag(z));\n    return 0;\n}\n</code></pre>"},{"location":"c/5_data_types/#9-data-types-and-performance","title":"9. data types and performance","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;time.h&gt;\n\nint main() {\n    clock_t start, end;\n    int i;\n    double t;\n\n    start = clock();\n    for (i = 0; i &lt; 100000000; ++i) { int x = i * 2; }\n    end = clock();\n    t = ((double)(end - start)) / CLOCKS_PER_SEC;\n    printf(\"int i\u015flemleri: %.3f saniye\\n\", t);\n\n    start = clock();\n    for (i = 0; i &lt; 100000000; ++i) { double x = i * 2.0; }\n    end = clock();\n    t = ((double)(end - start)) / CLOCKS_PER_SEC;\n    printf(\"double i\u015flemleri: %.3f saniye\\n\", t);\n    return 0;\n}\n</code></pre>"},{"location":"c/6_declarations_and_definitions/","title":"Declarations and Definitions","text":""},{"location":"c/6_declarations_and_definitions/#declaration-and-definition","title":"Declaration and Definition","text":""},{"location":"c/6_declarations_and_definitions/#1-declaration","title":"1. Declaration","text":"<p>A declaration statement provides information to the compiler at compile time. This information relates to the type, name, and existence of the variable or function.</p> <p>Example: </p><pre><code>extern int count;\nvoid printCount();\n</code></pre> It informs the compiler that \u201cthere is an integer variable named <code>count</code> and a function named <code>printCount()</code>.\u201d However, it does not allocate memory."},{"location":"c/6_declarations_and_definitions/#2-definition","title":"2. Definition","text":"<p>Definition causes the compiler to allocate memory. Unlike declaration, definition creates a real object.</p> <p>Example: </p><pre><code>int count = 5; // Definition\n</code></pre> This statement allocates memory for the <code>count</code> variable. Every definition is a declaration; however, not every declaration is a definition.  Operation What the Compiler Does Declaration Receives information, does not allocate space Declaration Receives information and allocates space in memory"},{"location":"c/6_declarations_and_definitions/#3-variable-declaration","title":"3. Variable Declaration","text":"<p>In C, a variable must be declared before it is used. The compiler allocates the appropriate amount of memory for the variable, knowing its type and name.</p> <p>General Syntax: </p><pre><code>&lt;type-specifying words&gt; &lt;variable name&gt;;\n</code></pre> <p>Examples: </p><pre><code>int total;\nunsigned long counter;\nfloat average;\n</code></pre> <p>The semicolon (<code>;</code>) terminates the statement. In C, <code>;</code> is the \u201cperiod\u201d of the expression.</p>"},{"location":"c/6_declarations_and_definitions/#4-type-specifying-keywords","title":"4. Type-Specifying Keywords","text":"<p>Keywords that can be used: </p><pre><code>signed, unsigned, char, short, int, long, float, double\n</code></pre> All keywords are written in lowercase. The C language is case-sensitive."},{"location":"c/6_declarations_and_definitions/#equivalent-type-declarations","title":"\ud83d\udd38 Equivalent Type Declarations","text":"Type Equivalent Notations Signed character <code>signed char</code>, <code>char</code> Unsigned character <code>unsigned char</code> Signed short integer <code>short</code>, <code>signed short</code>, <code>short int</code> Unsigned short integer <code>unsigned short</code>, <code>unsigned short int</code> Signed integer <code>int</code>, <code>signed int</code>, <code>signed</code> Unsigned integer <code>unsigned</code>, <code>unsigned int</code> Long integer <code>long</code>, <code>long int</code>, <code>signed long int</code> Unsigned long integer <code>unsigned long</code>, <code>unsigned long int</code> Floating point numbers <code>float</code>, <code>double</code>, <code>long double</code>"},{"location":"c/6_declarations_and_definitions/#5-naming-rules-identifiers","title":"5. Naming Rules (Identifiers)","text":""},{"location":"c/6_declarations_and_definitions/#valid-characters","title":"Valid characters:","text":"<ul> <li><code>a-z</code>, <code>A-Z</code></li> <li><code>0-9</code></li> <li><code>_</code> (underscore)</li> </ul>"},{"location":"c/6_declarations_and_definitions/#invalid-characters","title":"Invalid characters:","text":"<p>Spaces, Turkish characters (<code>\u00e7, \u011f, \u00fc, \u00f6, \u015f, \u0131</code> etc.), <code>+</code>, <code>-</code>, <code>/</code>, <code>*</code>, <code>&amp;</code>, <code>$</code> etc.</p>"},{"location":"c/6_declarations_and_definitions/#rules","title":"Rules:","text":"<ul> <li>Names cannot start with a number.</li> <li>They can start with the <code>_</code> character.</li> <li>Keywords cannot be used as names.</li> <li>Case sensitivity matters (<code>var</code>, <code>Var</code>, <code>VAR</code> are different).</li> <li>At least 31 characters are guaranteed to be considered.</li> </ul>"},{"location":"c/6_declarations_and_definitions/#long-and-meaningful-names","title":"Long and Meaningful Names","text":"<p>Names should express the purpose of the variable: </p><pre><code>int tax_rate;\nint number_of_students;\n</code></pre> <code>_</code> or CamelCase is often used instead of spaces: <pre><code>int total_price;\nint TotalPrice;\n</code></pre>"},{"location":"c/6_declarations_and_definitions/#6-declaration-examples","title":"6. Declaration Examples","text":"<pre><code>int x;\nunsigned long int var;\ndouble MFCS;\nunsigned _result;\nsigned short total;\n</code></pre> <p>Multiple variables of the same type: </p><pre><code>unsigned char ch1, ch2, ch3, ch4;\nfloat fl1, fl2;\nint tax_rate, tax_base;\n</code></pre> <p>Defining different types on the same line is invalid: </p><pre><code>long x, int y; // Error\n</code></pre>"},{"location":"c/6_declarations_and_definitions/#keyword-order","title":"Keyword Order","text":"<pre><code>signed long int x;\nlong signed int x;\nint long signed x;\n</code></pre> All are valid, but <code>signed long int</code> is more readable."},{"location":"c/6_declarations_and_definitions/#7-locations-of-declarations-in-source-code","title":"7. Locations of Declarations in Source Code","text":"<p>Variable declarations can be made in 3 places:</p> Location Description Inside a block Local variable Outside blocks Global variable In the function parameter list Parameter declaration"},{"location":"c/6_declarations_and_definitions/#rule","title":"Rule","text":"<p>Declarations must be at the beginning of the block.</p> <pre><code>{\n    int x, y;     // Valid\n    x = 5;\n    float f;      // Invalid (there is an expression before it)\n}\n</code></pre> <p>But in a nested block: </p><pre><code>{\n    int a;\n    { float b; }  // Valid\n}\n</code></pre>"},{"location":"c/6_declarations_and_definitions/#8-null-statement","title":"8. Null Statement","text":"<p>A standalone <code>;</code> is an executable null statement. In this case, any subsequent declaration becomes invalid.</p> <pre><code>{\n    int x;;\n    int y; // Invalid\n}\n</code></pre> <p>An empty block <code>{ }</code> is also considered an executable statement.</p>"},{"location":"c/6_declarations_and_definitions/#9-initialization","title":"9. Initialization","text":"<p>When defining a variable, an initial value can be assigned. This is not an assignment, but a declaration.</p> <pre><code>int a = 20;\nint b = 10, c = 30;\n</code></pre> <p>Incorrect example: </p><pre><code>void func() {\n    int a;\n    a = 20;\n    int b; // Invalid (there is an expression before it)\n}\n</code></pre> Correct example: <pre><code>void func() {\n    int a = 20;\n    int b; // Valid\n}\n</code></pre>"},{"location":"c/6_declarations_and_definitions/#10-declaration-and-definition-in-multi-file-programs","title":"10. Declaration and Definition in Multi-File Programs","text":""},{"location":"c/6_declarations_and_definitions/#headerh","title":"header.h","text":"<pre><code>extern int count;\nvoid printCount();\n</code></pre> <code>extern</code> tells the compiler that \u201cthis variable will be defined in another file.\u201d"},{"location":"c/6_declarations_and_definitions/#mainc","title":"main.c","text":"<pre><code>#include \u201cheader.h\u201d\nint count = 5;\n\nint main() {\n    printCount();\n}\n</code></pre>"},{"location":"c/6_declarations_and_definitions/#utilc","title":"util.c","text":"<pre><code>#include \u201cheader.h\u201d\n#include &lt;stdio.h&gt;\n\nvoid printCount() {\n    printf(\u201c%d\\n\u201d, count);\n}\n</code></pre> <p><code>header.h</code> contains the declaration, <code>main.c</code> performs the definition, and <code>util.c</code> uses the declared <code>count</code>.</p>"},{"location":"c/6_declarations_and_definitions/#11-compilation-linking","title":"11. Compilation &amp; Linking","text":"<p>Compilation: </p><pre><code>gcc -c main.c   \u2192 main.o\ngcc -c util.c   \u2192 util.o\n</code></pre> Linking: <pre><code>gcc main.o util.o -o program\n</code></pre> Running: <pre><code>./program\n</code></pre> Output: <pre><code>5\n</code></pre>"},{"location":"c/6_declarations_and_definitions/#12-summary","title":"12. Summary","text":"Concept Definition Allocates Memory? Example Declaration Provides information to the compiler No <code>extern int x;</code> Definition Creates an object Yes <code>int x = 5;</code>"},{"location":"c/7_constants/","title":"Constants","text":""},{"location":"c/7_constants/#constants","title":"Constants","text":""},{"location":"c/7_constants/#1-what-is-a-constant","title":"1. What is a Constant?","text":"<p>Data is either stored within objects or written directly as constants. Constants are fixed values written directly by the programmer.</p> <p>Example: </p><pre><code>x = y + z;    // y and z are variables\nd = x + 10;   // 10 is a constant\n</code></pre> <p>The value of constants is known at compile time. This means the compiler places this value directly into the code.</p>"},{"location":"c/7_constants/#2-types-of-constants","title":"2. Types of Constants","text":"<p>Just as every object in C has a type, constants also have a type. The compiler determines the type of the constant based on its syntax.</p>"},{"location":"c/7_constants/#types","title":"Types","text":"<ul> <li>Integer constants  </li> <li>Character constants  </li> <li>Floating constants</li> </ul>"},{"location":"c/7_constants/#3-integer-constants","title":"3. Integer Constants","text":"<p>Integer constants can be one of the following types: - <code>signed int</code> - <code>unsigned int</code> - <code>signed long</code> - <code>unsigned long</code></p>"},{"location":"c/7_constants/#notation","title":"Notation","text":"Number System Notation Example Decimal <code>123</code> <code>456</code>, <code>7890</code> Octal <code>0...</code> (starts with zero) <code>0710</code>, <code>016</code> Hexadecimal <code>0x...</code> or <code>0X...</code> <code>0x1C8</code>, <code>0XFF</code> <p>In hexadecimal, digits greater than 9 are represented by the letters A\u2013F or a\u2013f.</p>"},{"location":"c/7_constants/#suffixes-used-in-integer-constants","title":"Suffixes Used in Integer Constants","text":"Suffix Meaning Example <code>u</code> / <code>U</code> Unsigned integer <code>123U</code> <code>l</code> / <code>L</code> Long integer (<code>long</code>) <code>456L</code> <code>ul</code> / <code>UL</code> Long unsigned integer (<code>unsigned long</code>) <code>789UL</code> <p>To avoid visual confusion, it is recommended to use <code>L</code> instead of <code>l</code>.</p>"},{"location":"c/7_constants/#type-determination-rules","title":"Type Determination Rules","text":"Notation Type Order <code>bb...b</code> <code>signed int</code>, <code>signed long</code>, <code>unsigned long</code> <code>0xbb...b</code> or <code>0bb...b</code> <code>signed int</code>, <code>unsigned int</code>, <code>signed long</code>, <code>unsigned long</code> <code>bb...bU</code> <code>unsigned int</code>, <code>unsigned long</code> <code>bb...bL</code> <code>signed long</code>, <code>unsigned long</code> <code>bb...bUL</code> <code>unsigned long</code> <p>The compiler selects the first type that can fit the value without overflowing from top to bottom.</p>"},{"location":"c/7_constants/#examples-for-2-byte-int-4-byte-long-systems","title":"Examples (for 2-byte int, 4-byte long systems)","text":"Notation Type <code>456</code> <code>signed int</code> <code>59654</code> <code>signed long</code> <code>0x1C8</code> <code>signed int</code> <code>987U</code> <code>unsigned int</code> <code>0XBCE1C53C</code> <code>unsigned long</code> <code>062000L</code> <code>signed long</code> <code>890765UL</code> <code>unsigned long</code>"},{"location":"c/7_constants/#4-character-constants","title":"4. Character Constants","text":"<p>They are written within single quotes <code>\u2018 \u2019</code>.</p> <p>Examples: </p><pre><code>\u2018a\u2019\n'J'\n\u20188\u2019\n':'\n\u2018\u00c7\u2019\n</code></pre> <p>A character constant is actually an integer representing the ASCII code number of that character.</p> <pre><code>char ch = \u2018a\u2019;  // ASCII 97\nch = \u2018a\u2019 + 3;   // 100 \u2192 'd'\n</code></pre>"},{"location":"c/7_constants/#escape-sequence-characters","title":"Escape Sequence Characters","text":"Constant Meaning <code>\u2018\\\\0\u2019</code> Null character <code>\u2018\\\\a\u2019</code> Bell sound <code>\u2018\\\\b\u2019</code> Backspace <code>\u2018\\\\t\u2019</code> Tab <code>\u2018\\\\n\u2019</code> Newline <code>\u2018\\\\v\u2019</code> Vertical tab <code>\u2018\\\\f\u2019</code> Form feed <code>\u2018\\\\r\u2019</code> Carriage return <code>\u2018\\\\\u2019'</code> Single quote <code>\u2018\\\\\\\"\u2019</code> Double quote <code>\u2018\\\\\\\\\u2019</code> Backslash"},{"location":"c/7_constants/#hexadecimal-and-octal-representations","title":"Hexadecimal and Octal Representations","text":"<p>Hexadecimal: </p><pre><code>\u2018\\\\x41\u2019   // \u2018A\u2019\n'\\\\xff'   // 255\n</code></pre> <p>Octal: </p><pre><code>\u2018\\\\012\u2019   // ASCII 10 (newline)\n\u2018\\\\07\u2019    // ASCII 7 (bell)\n</code></pre> <p>The same character can be expressed in different formats: </p><pre><code>\u2018\\\\x7\u2019   // hex\n\u2018\\\\07\u2019   // octal\n\u2018\\\\a\u2019    // escape \u2014 recommended format\n</code></pre> <p>The recommended format is predefined escape sequences such as <code>\u2018\\\\a\u2019</code> because they are readable and portable.</p>"},{"location":"c/7_constants/#character-encoding-information","title":"Character Encoding Information","text":"<ul> <li>The most common character set is ASCII (7-bit).  </li> <li>Some systems use EBCDIC or Unicode (UTF-16, UTF-32).  </li> <li>Unicode is designed to cover all languages.</li> </ul>"},{"location":"c/7_constants/#5-floating-constants","title":"5. Floating Constants","text":"<p>Floating constants can be of type <code>float</code>, <code>double</code>, or <code>long double</code>.</p>"},{"location":"c/7_constants/#float","title":"float","text":"<pre><code>1.31F\n10.F\n-2.456f\n</code></pre>"},{"location":"c/7_constants/#double","title":"double","text":"<pre><code>-24.5\n</code></pre>"},{"location":"c/7_constants/#long-double","title":"long double","text":"<pre><code>1.34L\n10.2L\n</code></pre>"},{"location":"c/7_constants/#scientific-notation","title":"Scientific Notation","text":"<p>Real numbers can be written in exponential form using <code>e</code> or <code>E</code>.</p> <pre><code>2.3e+04f   // 2.3 \u00d7 10^4\n1.74e-6F   // 1.74 \u00d7 10^-6\n8.e+9f     // 8 \u00d7 10^9\n</code></pre> <p>Equivalent examples: </p><pre><code>1.34E-2f == 0.0134\n-1.2E+2F == 120.0\n</code></pre>"},{"location":"c/7_constants/#6-character-constant-type","title":"6. Character Constant Type","text":"<p>In C, character constants are actually of type <code>int</code>. They behave like <code>char</code> in operations, but are treated as <code>int</code> in type conversions.</p>"},{"location":"c/7_constants/#7-summary","title":"7. Summary","text":"Type Notation Example Type Information Integer <code>125800</code> <code>signed long</code> Integer (hex) <code>0xBCE1C53C</code> <code>unsigned long</code> Character <code>\u2018A\u2019</code>, <code>\u2018\\\\n\u2019</code>, <code>\u2018\\\\x41\u2019</code> <code>int</code> Real number <code>-24.5</code>, <code>1.34L</code>, <code>2.3e+04f</code> <code>float</code>, <code>double</code>, <code>long double</code> ---"},{"location":"c/7_constants/#code-examples","title":"Code examples","text":""},{"location":"c/7_constants/#1-basics","title":"1. basics","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Onluk: %d\\n\", 42);\n    printf(\"Sekizlik: %d\\n\", 052);   // 0 ile ba\u015flarsa sekizlik \u2192 5*8 + 2 = 42\n    printf(\"Onaltilik: %d\\n\", 0x2A); // 0x ile ba\u015flarsa onalt\u0131l\u0131k \u2192 2*16 + 10 = 42\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#2-suffix","title":"2. suffix","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"int: %zu byte\\n\", sizeof(10));\n    printf(\"long: %zu byte\\n\", sizeof(10L));\n    printf(\"unsigned long: %zu byte\\n\", sizeof(10UL));\n    printf(\"long long: %zu byte\\n\", sizeof(10LL));\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#3signed-unsigned","title":"3.signed unsigned","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    signed int a = -1;\n    unsigned int b = -1;\n    printf(\"signed a = %d\\n\", a);\n    printf(\"unsigned b = %u\\n\", b);\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#4-character-constants_1","title":"4. character constants","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char ch1 = 'A';\n    char ch2 = 65; // ayn\u0131 \u015fey\n    printf(\"%c %d\\n\", ch1, ch1);\n    printf(\"%c %d\\n\", ch2, ch2);\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#5-escape-sequences","title":"5. escape sequences","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\"Sat\u0131r1\\nSat\u0131r2\\n\");     // \\n yeni sat\u0131r\n    printf(\"Sekme\\tAras\u0131\\n\");       // \\t sekme\n    printf(\"Ters B\u00f6l\u00fc: \\\\\\n\");      // \\\\ bir ters b\u00f6l\u00fc\n    printf(\"T\u0131rnak: \\\"Merhaba\\\"\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#6-character-in-numeric-process","title":"6. character in numeric process","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char a = 'a';\n    char b = a + 3;\n    printf(\"'%c' + 3 = '%c'\\n\", a, b);\n    printf(\"ASCII kodlar\u0131: %d + 3 = %d\\n\", a, b);\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#7-octal-and-hex-character-constants","title":"7. octal and hex character constants","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char x = '\\x41';  // 0x41 = 65\n    char y = '\\101';  // 0101 = 65\n    printf(\"x=%c (%d), y=%c (%d)\\n\", x, x, y, y);\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#8-reel-number-constants","title":"8. reel number constants","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    float f = 1.23F;\n    double d = 1.23;\n    long double ld = 1.23L;\n    printf(\"float: %.10f\\n\", f);\n    printf(\"double: %.10lf\\n\", d);\n    printf(\"long double: %.10Lf\\n\", ld);\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#9-scientific-notation","title":"9. scientific notation","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    double a = 1.23e3;   // 1.23 \u00d7 10^3 = 1230\n    double b = 1.23e-3;  // 1.23 \u00d7 10^-3 = 0.00123\n    printf(\"a = %f\\nb = %f\\n\", a, b);\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#10-type-conversion","title":"10. type conversion","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;float.h&gt;\n\nint main() {\n    printf(\"10 -&gt; int: %zu byte\\n\", sizeof(10));\n    printf(\"10L -&gt; long: %zu byte\\n\", sizeof(10L));\n    printf(\"10.0 -&gt; double: %zu byte\\n\", sizeof(10.0));\n    printf(\"10.0f -&gt; float: %zu byte\\n\", sizeof(10.0f));\n\n    double a = 1e39;  // float s\u0131n\u0131r\u0131n\u0131 a\u015far\n    float b = 1e39f;  // ta\u015fma (overflow)\n    printf(\"a(double) = %e\\n\", a);\n    printf(\"b(float)  = %e\\n\", b);\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#11-constant-type-determination","title":"11. Constant Type Determination","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;limits.h&gt; // For INT_MAX\n\nint main() {\n    // 1. Un-suffixed decimal constant (32-bit system)\n    int a = 2000000000;  // Type: signed int\n\n    // 2. Suffix 'L' forces the constant type to signed long\n    long b = 3000000000L; // Type: signed long (needed as 3B &gt; 2B int max)\n\n    // 3. Suffix 'U' forces the constant type to unsigned int\n    unsigned int c = 500U; // Type: unsigned int\n\n    printf(\"Value of b (long): %ld\\n\", b);\n\n    // Example of overflow (assuming 32-bit int)\n    // The constant 3000000000 is too large for signed int, so its type defaults to signed long (if it fits).\n    // If it didn't fit long, it would become unsigned long.\n\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#12-character-arithmeticinteger-promotion","title":"12. Character Arithmetic(integer promotion)","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    // 'A' is an integer constant (ASCII 65)\n    char start_char = 'A'; \n    int offset = 3; \n\n    // The character constant 'A' is promoted to an int (65) for the addition.\n    // The result (68) is then assigned back to the char variable.\n    char result = start_char + offset; // 65 + 3 = 68 ('D')\n\n    printf(\"Character constant 'A' value: %d\\n\", 'A');\n    printf(\"Result of 'A' + 3: %c\\n\", result);\n\n    return 0;\n}\n</code></pre>"},{"location":"c/7_constants/#13-floating-constant-suffix-impact","title":"13. Floating Constant Suffix Impact","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    // 1. Unsuffixed constant: Type is double (8 bytes)\n    printf(\"Size of 3.14 (Default): %zu bytes\\n\", sizeof(3.14)); \n\n    // 2. 'F' suffix: Type is float (4 bytes)\n    printf(\"Size of 3.14F (Float): %zu bytes\\n\", sizeof(3.14F)); \n\n    // 3. 'L' suffix: Type is long double (8/10/12+ bytes)\n    printf(\"Size of 3.14L (Long Double): %zu bytes\\n\", sizeof(3.14L)); \n\n    return 0;\n}\n</code></pre>"},{"location":"c/8_operators/","title":"Operators","text":""},{"location":"c/8_operators/#operators","title":"Operators","text":""},{"location":"c/8_operators/#what-is-an-operator","title":"What is an Operator?","text":"<p>Operators are atoms that perform predefined operations on objects or literals. Operators cause the microprocessor to perform an operation and, as a result, produce a value. Each operator defined in programming languages corresponds to at least one machine instruction. Although they perform similar operations, operator atoms may differ from one programming language to another.</p> <p>In the C programming language, expressions often include operators: * <code>c = a * b / 2 + 3</code> (4 operators: <code>=</code>, <code>*</code>, <code>/</code>, <code>+</code>) * <code>++x * y--</code> (3 operators: <code>++</code>, <code>*</code>, <code>--</code>) * <code>a &gt;= b</code> (1 operator: <code>&gt;=</code>)</p>"},{"location":"c/8_operators/#what-is-an-operand","title":"What is an Operand?","text":"<p>The objects or literals that operators operate on are called operands. In C, operators can be divided into three groups based on the number of operands they take:</p>"},{"location":"c/8_operators/#1-unary-operators","title":"1. Unary Operators","text":"<p>These operators take a single operand. * Example: <code>++</code> and <code>--</code> operators (<code>++x</code>).</p>"},{"location":"c/8_operators/#2-binary-operators","title":"2. Binary Operators","text":"<p>These operators take two operands. * Example: Arithmetic operators like addition (<code>+</code>) and division (<code>/</code>) (<code>x + y</code>).</p>"},{"location":"c/8_operators/#3-ternary-operator","title":"3. Ternary Operator","text":"<p>C has only one ternary operator, which is the conditional operator (<code>? :</code>).</p> <p>Operators can also be grouped based on their position relative to their operand(s):</p> <ul> <li>Postfix Operators: Placed after their operand(s).<ul> <li>Example: Postfix <code>++</code> operator (<code>x++</code>).</li> </ul> </li> <li>Prefix Operators: Placed before their operand(s).<ul> <li>Example: Logical NOT operator (<code>!x</code>).</li> </ul> </li> <li>Infix Operators: Placed between their operands.<ul> <li>Example: Arithmetic addition operator (<code>x + y</code>).</li> </ul> </li> </ul>"},{"location":"c/8_operators/#operators-producing-a-value","title":"Operators Producing a Value","text":"<p>Operators produce a value as a result of the operation they perform. The value produced by an operator can be an operand for another operator within the same expression. The value produced by the last evaluated operator in an expression becomes the value of the expression.</p> <p>The most important feature of operators is that they produce a value as a result of their operation. The programmer may or may not use the value produced by the operator.</p> <p>The produced value can be used in the following ways: * Assigned to another variable: <code>x = y + z;</code> (The value produced by <code>+</code> is assigned to <code>x</code>). * Sent as an argument to a function: <code>func(y + z);</code> (The value produced by <code>+</code> is sent to <code>func</code>). * Used to form a function's return value: </p><pre><code>int func() {\n    return (y + z); // The return value is the value produced by '+'\n}\n</code></pre> <p>Not using the value produced by an operator is not a syntax error in C, but compilers usually issue a warning to the programmer. * Example: The expression <code>x + y;</code> produces the value 30, but since it is not used, a Borland compiler might issue the warning: <code>\"code has no effect!\"</code>.</p>"},{"location":"c/8_operators/#operator-precedence-and-associativity","title":"Operator Precedence and Associativity","text":"<p>In C, expressions have types and values. The compiler determines an expression's value by: 1. Operators producing values according to their precedence order. 2. The produced values being passed as operands to operators with lower precedence. 3. The final value remaining being the value of the expression.</p> <p>Every programming language has operator precedence. Without precedence, the results of operations would vary across machines and compilers.</p> <ul> <li>C has 45 operators across 15 distinct precedence levels.</li> <li>Associativity (Precedence Direction) defines whether operators at the same precedence level are evaluated from left-to-right or right-to-left.<ul> <li>Levels 2, 13, and 14 are right associative.</li> <li>All other levels are left associative.</li> </ul> </li> </ul> <p>A single symbol can be used for multiple operators (e.g., <code>*</code> for multiplication and the indirection operator, or <code>&amp;</code> for bitwise AND and the address-of operator).</p>"},{"location":"c/8_operators/#operator-side-effects","title":"Operator Side Effects","text":"<p>While the main function of C operators is to produce a value, some operators also change the values of their operand objects. This change, which is writing a new value to the object's memory location, is called a side effect.</p> <ul> <li>Example: The assignment operator (<code>=</code>) and the increment/decrement operators (<code>++</code>, <code>--</code>) have side effects.</li> </ul>"},{"location":"c/8_operators/#constraints-on-operators","title":"Constraints on Operators","text":"<p>Programming language rules impose certain constraints on operator usage. * Constraint Example 1: The <code>++</code> operator requires its operand to be an expression that designates an object (an lvalue); otherwise, a compile-time error occurs. * Constraint Example 2: The modulus operator (<code>%</code>) requires both operands to be of an integer type (<code>char</code>, <code>short</code>, <code>int</code>, <code>long</code>); using real number types is invalid.</p>"},{"location":"c/8_operators/#classification-of-operators-by-function","title":"Classification of Operators by Function","text":"<p>Operators are classified based on the operations they perform:</p> <ul> <li>Arithmetic Operators: Addition, subtraction, multiplication, increment, decrement, and sign operators.</li> <li>Relational Operators (Comparison): Greater than, greater than or equal, less than, less than or equal, equal, not equal.</li> <li>Logical Operators: Logical AND, logical OR, logical NOT.</li> <li>Pointer Operators: Address-of, indirection (content), and subscript (<code>[]</code>) operators.</li> <li>Bitwise Operators: Bitwise NOT, bitwise shift, bitwise AND, OR, and XOR.</li> <li>Assignment Operators: Simple assignment and compound assignment operators.</li> <li>Special Purpose Operators: Conditional operator, <code>sizeof</code>, type cast operator.</li> </ul>"},{"location":"c/8_operators/#arithmetic-operators","title":"Arithmetic Operators","text":""},{"location":"c/8_operators/#addition-and-subtraction-operators","title":"Addition (<code>+</code>) and Subtraction (<code>-</code>) Operators","text":"<ul> <li>Binary, infix operators.</li> <li>Produce the sum or difference of their operands.</li> <li>No requirement for operands to be of the same type.</li> <li>Precedence level 4; left associative.</li> <li>No side effects.</li> </ul>"},{"location":"c/8_operators/#unary-sign-operators-and","title":"Unary Sign Operators (<code>-</code> and <code>+</code>)","text":"<ul> <li>Unary, prefix operators.</li> <li>Sign Minus (<code>-</code>): Produces the negative of its operand's value (compiler generates code to multiply the value by -1). It produces an rvalue (a value, not an object), so it cannot be assigned to.<ul> <li>Example: <code>-x</code> and <code>0 - (x)</code> are equivalent.</li> </ul> </li> <li>Sign Plus (<code>+</code>): Added for mathematical similarity; has no effect on its operand's value and produces the same value as its operand.<ul> <li>Example: <code>+x</code> and <code>0 + (x)</code> are equivalent.</li> </ul> </li> <li>Precedence level 2; right associative.</li> <li>No side effects.</li> </ul>"},{"location":"c/8_operators/#multiplication-and-division-operators","title":"Multiplication (<code>*</code>) and Division (<code>/</code>) Operators","text":"<ul> <li>Binary, infix operators.</li> <li>Multiplication (<code>*</code>): Produces the product of its operands.</li> <li>Division (<code>/</code>): Produces the quotient of the left operand divided by the right operand.<ul> <li>Note: If both operands are integer types, the result is an integer (integer division).</li> </ul> </li> <li>Precedence level 3; left associative.</li> <li>No side effects.</li> <li>The <code>*</code> symbol is also used as a pointer (indirection) operator, but they do not conflict because multiplication is binary while indirection is unary.</li> </ul>"},{"location":"c/8_operators/#modulus-operator","title":"Modulus (<code>%</code>) Operator","text":"<ul> <li>Binary, infix operator.</li> <li>Constraint: Both operands must be integer types (char, short, int, long). Real number types are invalid.</li> <li>Produces the remainder of the left operand divided by the right operand.</li> <li>No side effects.</li> </ul>"},{"location":"c/8_operators/#increment-and-decrement-operators","title":"Increment (<code>++</code>) and Decrement (<code>--</code>) Operators","text":"<ul> <li>Single-operand operators; can be used in prefix or postfix positions.</li> <li>Used to increase (<code>++</code>) or decrease (<code>--</code>) the value of a variable by 1.</li> <li>They have side effects (they change the value of the operand object in memory).</li> <li>Precedence level 2; higher than other arithmetic operators; right associative.</li> </ul>"},{"location":"c/8_operators/#usage","title":"Usage","text":"<ul> <li>Isolated use (<code>++c;</code> or <code>c++;</code>): No difference; both are equivalent to <code>c = c + 1;</code>.</li> <li>In expressions:<ul> <li>Prefix (<code>++x</code>): The value produced is the value after the increment/decrement.</li> <li>Postfix (<code>x++</code>): The value produced is the value before the increment/decrement; the actual change to the object's value happens after the entire expression is evaluated.</li> </ul> </li> </ul>"},{"location":"c/8_operators/#important-terms-in-c-standards","title":"Important Terms in C Standards","text":""},{"location":"c/8_operators/#behavior","title":"Behavior","text":"<p>The way a compiler interprets and understands a specific piece of code is called \"compiler behavior\".</p>"},{"location":"c/8_operators/#undefined-behavior","title":"Undefined Behavior","text":"<p>Expressions that lead to interpretation differences not explicitly specified in the standards, which can vary from compiler to compiler. Programmers should avoid them, as there is no guarantee of the outcome. Code with undefined behavior is syntactically valid. * <code>++</code>/<code>--</code> Related Undefined Behavior: If a variable is an operand of <code>++</code> or <code>--</code> in an expression, it should not appear again in that same expression.     * Example: <code>y = ++x + ++x;</code>, <code>y = ++x + x</code>, and <code>a = ++a;</code> all exhibit undefined behavior.</p>"},{"location":"c/8_operators/#unspecified-behavior","title":"Unspecified Behavior","text":"<p>Situations where the compiler can interpret the source code differently, but the options are limited. Compilers are not required to document which option they chose. Programmers should avoid code that leads to unspecified behavior.</p>"},{"location":"c/8_operators/#implementation-dependent-behavior","title":"Implementation-Dependent Behavior","text":"<p>Certain C features are left to the compiler writers' choice for flexibility (e.g., the length of <code>int</code>, whether default <code>char</code> is signed or unsigned). Compilers must document how these features were chosen.</p>"},{"location":"c/8_operators/#diagnostic-messages","title":"Diagnostic Messages","text":"<p>The notification given by the compiler about the cause of a problem when it encounters problematic code. * A warning or error message should be issued when syntactical or semantic rules are violated. Warnings are typically for minor issues that can be fixed, while errors are for larger mistakes.</p>"},{"location":"c/8_operators/#relational-operators-comparison","title":"Relational Operators (Comparison)","text":"<p>C has 6 relational operators: * <code>&lt;</code> (less than) * <code>&gt;</code> (greater than) * <code>&lt;=</code> (less than or equal) * <code>&gt;=</code> (greater than or equal) * <code>==</code> (equal) * <code>!=</code> (not equal)</p> <p>All are binary, infix operators.</p> <ul> <li>The first four (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>) are at precedence level 6.</li> <li>The last two (<code>==</code>, <code>!=</code>) are at precedence level 7.</li> <li>They have lower precedence than arithmetic operators.</li> </ul> <p>In C (unlike C++ or Java), there is no dedicated boolean data type. Relational operators produce an <code>int</code> type value: * 1 if the proposition is True. * 0 if the proposition is False.</p>"},{"location":"c/8_operators/#logical-operators","title":"Logical Operators","text":"<p>These operators perform logical operations on their operands. They interpret their operands as True or False. C has three logical operators with different precedence levels:</p> <ul> <li><code>!</code> (logical NOT)</li> <li><code>&amp;&amp;</code> (logical AND)</li> <li><code>||</code> (logical OR)</li> </ul> <p>Since C does not have a boolean type, <code>int</code> is used, where 1 is True and 0 is False. Any expression can be an operand to a logical operator. If the expression's numeric value is non-zero, it is interpreted as True (1); if it is 0, it is interpreted as False (0).</p>"},{"location":"c/8_operators/#logical-not-operator","title":"Logical NOT Operator (<code>!</code>)","text":"<ul> <li>Unary, prefix operator.</li> <li>Produces the inverse logical value of its operand.<ul> <li>If the operand is True (non-zero), it produces 0.</li> <li>If the operand is False (0), it produces 1.</li> </ul> </li> </ul>"},{"location":"c/8_operators/#logical-and-operator","title":"Logical AND Operator (<code>&amp;&amp;</code>)","text":"<ul> <li>Lower precedence than relational operators, but higher than <code>||</code>.</li> <li>Produces 1 (True) only if both operands are True; otherwise, it produces 0 (False).</li> </ul>"},{"location":"c/8_operators/#logical-or-operator","title":"Logical OR Operator (<code>||</code>)","text":"<ul> <li>Lowest precedence logical operator.</li> <li>Produces 1 (True) if at least one operand is True; produces 0 (False) only if both are False.</li> </ul>"},{"location":"c/8_operators/#short-circuit-behavior-and","title":"Short Circuit Behavior (<code>&amp;&amp;</code> and <code>||</code>)","text":"<p>C guarantees that the left operand is evaluated first for both <code>&amp;&amp;</code> and <code>||</code>. This feature, called short circuit behavior, allows for more efficient code: * <code>&amp;&amp;</code>: If the left operand is evaluated as False (0), the right operand is never evaluated. * <code>||</code>: If the left operand is evaluated as True (non-zero), the right operand is never evaluated.</p> <p>Logical operators perform their operation by first interpreting their operands as 1 or 0, but they have no side effects on the memory values of their operands.</p>"},{"location":"c/8_operators/#assignment-operators","title":"Assignment Operators","text":"<p>Assignment operators are at precedence level 14 (second lowest, only higher than the comma operator) and are right associative.</p>"},{"location":"c/8_operators/#simple-assignment-operator","title":"Simple Assignment Operator (<code>=</code>)","text":"<ul> <li>Like other operators, the assignment operator produces a value in addition to performing the assignment.</li> <li>The value produced is the value assigned to the object.</li> <li>The value produced by the assignment is not an object; therefore, expressions like <code>(b = c) = a;</code> are invalid in C.</li> <li>Its right-to-left associativity allows chained assignments like <code>a = b = c = d = 5;</code>.</li> </ul>"},{"location":"c/8_operators/#compound-assignment-operators-etc","title":"Compound Assignment Operators (<code>+=</code>, <code>-=</code>, <code>*=</code>, etc.)","text":"<p>Used when the operand being operated on and the object receiving the result are the same. * <code>&lt;object1&gt; = &lt;object1&gt; operation &lt;operand2&gt;</code> is equivalent to <code>&lt;object1&gt; operation= &lt;operand2&gt;</code>. * They are at the same precedence level as the simple assignment operator. * Preferred for readability and brevity. * Example: <code>x += 5;</code> is equivalent to <code>x = x + 5;</code>.</p> <p>All assignment operators have side effects. The side effect is the modification of the left operand's value in memory, by assigning the value of the right operand expression to the object on the left.</p>"},{"location":"c/8_operators/#comma-operator","title":"Comma Operator (<code>,</code>)","text":"<p>The comma operator combines two separate expressions into a single expression. It has the lowest precedence in C (level 15).</p> <ul> <li>The evaluation of the left operand's expression is guaranteed to occur before the evaluation of the right operand's expression.</li> <li>The value produced by the operator is the value produced by the right-hand expression. The left operand's value does not affect the result.</li> </ul>"},{"location":"c/8_operators/#precedence-operator","title":"Precedence Operator (<code>()</code>)","text":"<p>The parentheses operator is used to increase the precedence of an expression. * It is in the highest precedence group (level 1). * It follows the left-to-right associativity rule. * If the operand expression designates an object, the expression produced by the precedence operator also designates an object.</p>"},{"location":"c/8_operators/#operator-precedence-vs-order-of-execution","title":"Operator Precedence vs. Order of Execution","text":"<p>Operator precedence does not guarantee that an operation will be performed sooner by the processor. * Example: In <code>x = func1() * func2() + func3();</code>, the higher precedence of multiplication (<code>*</code>) does not guarantee that <code>func1()</code> will be called before <code>func3()</code>.</p> <p>However, the following 4 C operators do guarantee the order of operation for their operands: 1. Logical AND (<code>&amp;&amp;</code>) 2. Logical OR (<code>||</code>) 3. Conditional (<code>? :</code>) 4. Comma (<code>,</code>)</p> <p>The order is guaranteed to ensure the short circuit behavior for <code>&amp;&amp;</code>/<code>||</code>, the required evaluation of the first operand for the conditional operator, and the left-to-right execution of the comma operator.</p>"},{"location":"c/8_operators/#c-language-operator-precedence-table","title":"C Language Operator Precedence Table","text":"Level Operator Description Associativity 1 <code>()</code>, <code>[]</code>, <code>.</code>, <code>-&gt;</code> Precedence, Subscript, Structure Access left-to-right 2 <code>+</code>, <code>-</code>, <code>++</code>, <code>--</code>, <code>~</code>, <code>!</code>, <code>*</code>, <code>&amp;</code>, <code>sizeof</code>, <code>(type)</code> Unary Signs, Inc/Dec, Bitwise/Logical NOT, Indirection, Address Of, sizeof, Type Cast right-to-left 3 <code>*</code>, <code>/</code>, <code>%</code> Multiplication, Division, Modulus left-to-right 4 <code>+</code>, <code>-</code> Addition, Subtraction left-to-right 5 <code>&lt;&lt;</code>, <code>&gt;&gt;</code> Bitwise Shift Left/Right left-to-right 6 <code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code> Relational Operators left-to-right 7 <code>==</code>, <code>!=</code> Equality Operators left-to-right 8 <code>&amp;</code> Bitwise AND left-to-right 9 <code>^</code> Bitwise Exclusive OR (XOR) left-to-right 10 <code>|</code> Bitwise OR left-to-right 11 <code>&amp;&amp;</code> Logical AND left-to-right 12 <code>||</code> Logical OR left-to-right 13 <code>?:</code> Conditional Operator right-to-left 14 <code>=</code>, <code>+=</code>, <code>-=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>, <code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&amp;=</code>, <code>|=</code>, <code>^=</code> Assignment Operators (Simple &amp; Compound) right-to-left 15 <code>,</code> Comma Operator left-to-right"},{"location":"c/8_operators/#additional-examples","title":"Additional examples","text":""},{"location":"c/8_operators/#1-arithmetic-unary-side-effects","title":"1. Arithmetic, Unary &amp; Side Effects","text":"<p>This example focuses on basic arithmetic, the difference between prefix and postfix increment/decrement, and the concept of an operator producing a value and having a side effect. </p><pre><code>#include &lt;stdio.h&gt;\n\nvoid basic_operators_demo() {\n    int a = 10;\n    int b = 3;\n    int result;\n\n    printf(\"--- 1. Basic Arithmetic (Binary Infix) ---\\n\");\n    // Binary Infix Operators: +, -, *, /, %\n    printf(\"Addition: 10 + 3 = %d\\n\", a + b);     // Produces 13\n    printf(\"Division (Integer): 10 / 3 = %d\\n\", a / b); // Produces 3 (integer division)\n    printf(\"Modulus (Remainder): 10 %% 3 = %d\\n\", a % b); // Produces 1 (Constraint: requires integer types)\n\n    // Unary Prefix Operator: - (Sign Minus)\n    printf(\"Unary Minus: -10 = %d\\n\", -a); // Produces -10\n\n    printf(\"\\n--- 2. Unary Inc/Dec Operators (Side Effects) ---\\n\");\n\n    int x = 5;\n    printf(\"Initial x: %d\\n\", x); // x is 5\n\n    // Prefix Increment: ++x\n    // Action: 1. Changes x (side effect) 2. Value produced is the NEW value\n    result = ++x; \n    printf(\"Prefix ++x: Value produced = %d, x after operation = %d\\n\", result, x); // Output: 6, 6\n\n    x = 5; // Reset x\n\n    // Postfix Increment: x++\n    // Action: 1. Value produced is the OLD value 2. Changes x (side effect)\n    result = x++;\n    printf(\"Postfix x++: Value produced = %d, x after operation = %d\\n\", result, x); // Output: 5, 6\n\n    // Note: If used in isolation (e.g., x++;), prefix and postfix are functionally identical.\n}\n\n/*\nTo compile and run:\ngcc basic_operators.c -o basic_demo\n./basic_demo\n*/\n</code></pre>"},{"location":"c/8_operators/#2-relational-logical-short-circuiting","title":"2. Relational, Logical &amp; Short-Circuiting","text":"<p>This example demonstrates how Relational and Logical operators produce integer values (1 or 0) and illustrates the crucial short-circuit behavior of &amp;&amp; and || </p><pre><code>#include &lt;stdio.h&gt;\n\nint check_function(const char* name) {\n    printf(\"-&gt; Evaluating function: %s\\n\", name);\n    return 0; // Always returns 0 (False)\n}\n\nvoid intermediate_operators_demo() {\n    int val1 = 10, val2 = 20;\n\n    printf(\"--- 1. Relational Operators (Produce 1 or 0) ---\\n\");\n    // Relational Operators: &lt;, &gt;, &lt;=, &gt;=, ==, !=\n\n    // val1 &lt; val2 (10 &lt; 20) is True, so it produces 1.\n    printf(\"10 &lt; 20: %d\\n\", val1 &lt; val2); \n\n    // val1 == val2 (10 == 20) is False, so it produces 0.\n    printf(\"10 == 20: %d\\n\", val1 == val2); \n\n    printf(\"\\n--- 2. Logical Operators (!, &amp;&amp;, ||) ---\\n\");\n\n    // Logical NOT: !\n    // ! (10 &lt; 20) -&gt; ! (1) -&gt; 0\n    printf(\"! (10 &lt; 20): %d\\n\", !(val1 &lt; val2)); \n\n    // Logical AND: &amp;&amp;\n    // (10 &lt; 20) &amp;&amp; (10 != 20) -&gt; 1 &amp;&amp; 1 -&gt; 1\n    printf(\"(10 &lt; 20) &amp;&amp; (10 != 20): %d\\n\", (val1 &lt; val2) &amp;&amp; (val1 != val2)); \n\n    printf(\"\\n--- 3. Short Circuit Behavior (&amp;&amp;) ---\\n\");\n    int x = 5;\n\n    // Condition: (x is 0/False) &amp;&amp; (Call function)\n    // The left side (x != 5) is 0 (False).\n    // The right operand is NOT evaluated. The function is NOT called.\n    if ((x != 5) &amp;&amp; check_function(\"RightOperand_AND\")) {\n        // This block is skipped\n    } else {\n        printf(\"&amp;&amp; Short Circuit: Left side was False (0), RightOperand_AND was NOT called.\\n\");\n    }\n\n    printf(\"\\n--- 4. Short Circuit Behavior (||) ---\\n\");\n\n    // Condition: (x is non-zero/True) || (Call function)\n    // The left side (x == 5) is 1 (True).\n    // The right operand is NOT evaluated. The function is NOT called.\n    if ((x == 5) || check_function(\"RightOperand_OR\")) {\n        printf(\"|| Short Circuit: Left side was True (1), RightOperand_OR was NOT called.\\n\");\n    }\n}\n\n/*\nTo compile and run:\ngcc intermediate_operators.c -o intermediate_demo\n./intermediate_demo\n*/\n</code></pre>"},{"location":"c/8_operators/#3-precedence-ternary-comma-undefined-behavior","title":"3. Precedence, Ternary, Comma &amp; Undefined Behavior","text":"<p>This example explores the more complex aspects: Precedence, the ternary operator, the low-precedence comma operator, and a demonstration of an expression with Undefined Behavior (for instructional purposes, to highlight what to avoid). </p><pre><code>#include &lt;stdio.h&gt;\n\nvoid advanced_operators_demo() {\n    int a = 20, b = 5, c = 2, d;\n\n    printf(\"--- 1. Precedence and Associativity ---\\n\");\n\n    // Expression: d = a + b * c;\n    // Precedence: * (Level 3) is higher than + (Level 4).\n    // Evaluation: d = a + (b * c) -&gt; d = 20 + 10 -&gt; 30\n    d = a + b * c;\n    printf(\"a + b * c (20 + 5 * 2) = %d\\n\", d); // Output: 30\n\n    // Expression: d = (a + b) * c;\n    // Parentheses (Level 1) force a higher precedence.\n    // Evaluation: d = (20 + 5) * 2 -&gt; d = 25 * 2 -&gt; 50\n    d = (a + b) * c;\n    printf(\"(a + b) * c ( (20 + 5) * 2 ) = %d\\n\", d); // Output: 50\n\n    printf(\"\\n--- 2. Conditional (Ternary) Operator (?:) ---\\n\");\n    // The C-only Ternary Operator: &lt;condition&gt; ? &lt;value_if_true&gt; : &lt;value_if_false&gt;\n    // Right Associative (Level 13)\n\n    int max = (a &gt; b) ? a : b; // Condition (a &gt; b) is True, max gets a (20)\n    printf(\"Max of 20 and 5 is: %d\\n\", max); \n\n    int abs_val = (b &lt; 0) ? -b : b; // Condition (b &lt; 0) is False, abs_val gets b (5)\n    printf(\"Absolute value of 5 is: %d\\n\", abs_val);\n\n    printf(\"\\n--- 3. Comma Operator (,) ---\\n\");\n    // Lowest Precedence (Level 15). Guarantees left-to-right evaluation.\n    // The value produced by the whole expression is the value of the RIGHT operand.\n\n    int e = 0;\n    // (e = 10, e + 5)\n    // 1. e = 10 (Side effect: e is now 10)\n    // 2. e + 5 -&gt; 10 + 5 -&gt; 15 (Value produced by the expression is 15)\n    d = (e = 10, e + 5); \n    printf(\"Comma Operator (e = 10, e + 5): Result = %d, e value = %d\\n\", d, e); // Output: 15, 10\n\n    printf(\"\\n--- 4. WARNING: Undefined Behavior ---\\n\");\n\n    int x = 10;\n    // **DANGER!** A variable 'x' is modified by '++' and also appears elsewhere in the expression.\n    // C Standard says: \"If a side effect on a scalar object is unsequenced relative to either \n    // a second side effect on the same scalar object or a value computation using the value \n    // of the same scalar object, the behavior is undefined.\"\n    // The outcome of the following line is NOT guaranteed and should be AVOIDED.\n    // Depending on the compiler/optimization, the result could be 22, 23, or something else.\n    int result_ub = ++x + x; \n\n    printf(\"++x + x (Initial x=10). The result is: %d (!!! Undefined Behavior !!!)\\n\", result_ub);\n    printf(\"Final x value: %d\\n\", x);\n}\n\n/*\nTo compile and run:\ngcc advanced_operators.c -o advanced_demo\n./advanced_demo\n*/\n</code></pre>"},{"location":"c/9_functions/","title":"Functions","text":""},{"location":"c/9_functions/#functions","title":"Functions","text":""},{"location":"c/9_functions/#1-what-is-a-function","title":"1. What is a Function?","text":"<p>In the C language, subprograms are called functions. Unlike the concept of a function in mathematics, a function is an independent sub-block of the program.</p> <p>A function is written to perform a specific task or produce a value.</p>"},{"location":"c/9_functions/#2-benefits-of-dividing-the-program-into-functions","title":"2. Benefits of Dividing the Program into Functions","text":"<ol> <li>The code becomes shorter, the .exe file becomes smaller. </li> <li>The code becomes more readable and easier to maintain.  </li> <li>Repetitive operations are grouped in one place.  </li> <li>Debugging becomes easier.  </li> <li>Functions become reusable.</li> </ol> <p>Every C program consists of functions and contains at least one function (<code>main</code>).</p>"},{"location":"c/9_functions/#3-function-inputs-and-outputs","title":"3. Function Inputs and Outputs","text":"<ul> <li>Input: Values sent to the function \u2192 actual parameter </li> <li>Output: The value returned by the function \u2192 return value</li> </ul> <p>The purpose of a function: 1. To perform a task 2. To calculate and return a value.</p>"},{"location":"c/9_functions/#4-return-values-of-functions","title":"4. Return Values of Functions","text":"<p>A value is returned at the end of a function using the return statement.</p>"},{"location":"c/9_functions/#purposes-of-use","title":"Purposes of use","text":"<ul> <li>To return the calculated result</li> <li>To indicate whether an operation was successful</li> <li>To convey status information</li> <li>Or to return no value (<code>void</code>)</li> </ul>"},{"location":"c/9_functions/#5-function-definition","title":"5. Function Definition","text":"<p>The body of the function is defined as follows:</p> <pre><code>[return_type] function_name([parameters]) {\n    /* code */\n}\n</code></pre> <p>Example: </p><pre><code>double func() {\n    return 3.14;\n}\n</code></pre> The <code>func</code> function takes no parameters and returns a value of type <code>double</code>."},{"location":"c/9_functions/#the-void-keyword","title":"The <code>void</code> Keyword","text":"<pre><code>void hello() {\n    printf(\u201cHello!\u201d);\n}\n</code></pre> <code>void</code> \u2192 The function does not produce a return value."},{"location":"c/9_functions/#functions-without-a-specified-type","title":"Functions Without a Specified Type","text":"<pre><code>func() { }\n</code></pre> The C compiler interprets this as <code>int func()</code>. In C++, this is invalid \u2014 the type must be specified."},{"location":"c/9_functions/#6-where-functions-are-defined","title":"6. Where Functions Are Defined","text":"<p>A function cannot be defined inside another function.</p> <pre><code>double foo() {\n    int bar() { } // Invalid\n}\n</code></pre> <p>Correct usage: </p><pre><code>double foo() { }\nint bar() { }\n</code></pre>"},{"location":"c/9_functions/#7-return-statement","title":"7. <code>return</code> Statement","text":"<p>Ends the function's execution and returns a value.</p> <pre><code>return;\nreturn x * y;\nreturn (a * b - c * d);\n</code></pre> <ul> <li>If the end is reached without a <code>return</code> statement, it returns a garbage value.</li> <li><code>void</code> functions can use <code>return;</code> on its own.</li> <li>A function can only return one value.</li> </ul>"},{"location":"c/9_functions/#8-main-function","title":"8. <code>main</code> Function","text":"<pre><code>int main() {\n    return 0;\n}\n</code></pre> <ul> <li>It is the starting point of the program.  </li> <li>The return value of <code>main</code> is passed to the operating system.  </li> <li><code>0</code> \u2192 success  </li> <li>Non-zero \u2192 error</li> </ul> <p>Although <code>void main()</code> is valid, it is not recommended.</p>"},{"location":"c/9_functions/#9-function-invocation","title":"9. Function Invocation","text":"<p>Function call operator: <code>()</code></p> <pre><code>func();\nresult = calculate();\n</code></pre> <ul> <li>The code of the called function executes, then control returns to the caller.  </li> <li>The return value is an R-value.</li> </ul> <pre><code>func() = 5; // Invalid\n</code></pre>"},{"location":"c/9_functions/#10-undefined-functions","title":"10. Undefined Functions","text":"<p>A function can be called even if it is declared but not defined. There will be no compilation error, but an error will occur during the linking phase if no definition is found.</p>"},{"location":"c/9_functions/#11-parameters","title":"11. Parameters","text":"<p>These are the input variables that functions take.</p> <p></p><pre><code>int add(int a, int b) {\n    return a + b;\n}\n</code></pre> When called: <pre><code>int z = add(x, y);\n</code></pre> The values of <code>x</code> and <code>y</code> are copied to the parameters <code>a</code> and <code>b</code>, respectively."},{"location":"c/9_functions/#12-old-style","title":"12. Old Style","text":"<pre><code>double area(x, y)\ndouble x, y;\n{\n    return x * y;\n}\n</code></pre> <p>Parameter types are declared later \u2014 no longer used.</p>"},{"location":"c/9_functions/#13-new-style","title":"13. New Style","text":"<pre><code>double area(double x, double y) {\n    return x * y;\n}\n</code></pre> <p>Types are specified in parentheses \u2014 modern C standard.</p>"},{"location":"c/9_functions/#14-functions-without-parameters","title":"14. Functions Without Parameters","text":"<pre><code>int foo() { }      // or\nint foo(void) { }\n</code></pre> Both indicate that no parameters are taken."},{"location":"c/9_functions/#15-copying-arguments","title":"15. Copying Arguments","text":"<p>Functions take parameters by value.</p> <p></p><pre><code>void func(int a) { a++; }\n\nint main() {\n    int x = 10;\n    func(x);\n    printf(\u201c%d\u201d, x); // 10\n}\n</code></pre> Demonstrates: Function parameters are copies, the original value remains unchanged."},{"location":"c/9_functions/#16-function-call-forms","title":"16. Function Call Forms","text":"<ol> <li>Void function call: <pre><code>func();\n</code></pre></li> <li>Value-returning function: <pre><code>a = foo();\n</code></pre></li> <li>Call without using the value: <pre><code>foo();\n</code></pre></li> <li>Nested call: <pre><code>z = square(add(x, y));\n</code></pre></li> <li>Another call inside return: <pre><code>return add(square(a), square(b));\n</code></pre></li> </ol>"},{"location":"c/9_functions/#17-recursive-functions","title":"17. Recursive Functions","text":"<p>A function can call itself.</p> <pre><code>int factorial(int n) {\n    if (n == 0) return 1;\n    return n * factorial(n - 1);\n}\n</code></pre> <p>This feature is called recursion.</p>"},{"location":"c/9_functions/#18-summary","title":"18. Summary","text":"Concept Explanation Function Subprogram, independent code block Definition Writing the function's code Call Executing the function Parameter Data sent to the function Return value Result produced by the function <code>void</code> Function with no return value <code>main</code> Program's starting point"},{"location":"c/9_functions/#additional-examples","title":"Additional examples","text":""},{"location":"c/9_functions/#1-square","title":"1. square","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint kare(int x) {\n    return x * x;\n}\n\nint main() {\n    printf(\"5\u2019in karesi: %d\\n\", kare(5));\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#2void","title":"2.void","text":"<pre><code>#include &lt;stdio.h&gt;\n\nvoid selamla() {\n    printf(\"Merhaba!\\n\");\n}\n\nint main() {\n    selamla();\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#3-decleration-and-call","title":"3. decleration and call","text":"<pre><code>#include &lt;stdio.h&gt;\n\n// Bildirim (prototip)\nint topla(int, int);\n\nint main() {\n    int s = topla(3, 4);\n    printf(\"Toplam = %d\\n\", s);\n    return 0;\n}\n\n// Tan\u0131mlama\nint topla(int a, int b) {\n    return a + b;\n}\n</code></pre>"},{"location":"c/9_functions/#4-return-exit","title":"4. return exit","text":"<pre><code>#include &lt;stdio.h&gt;\n\nvoid bolme(int a, int b) {\n    if (b == 0) {\n        printf(\"S\u0131f\u0131ra b\u00f6lme hatas\u0131!\\n\");\n        return; // erken \u00e7\u0131k\u0131\u015f\n    }\n    printf(\"Sonu\u00e7: %d\\n\", a / b);\n}\n\nint main() {\n    bolme(10, 2);\n    bolme(5, 0);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#5-use-funcs-as-formal-parameter","title":"5. use funcs as formal parameter","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint topla(int a, int b) { return a + b; }\nint kare(int x) { return x * x; }\n\nint main() {\n    int sonuc = kare(topla(3, 2));\n    printf(\"Sonu\u00e7: %d\\n\", sonuc); // (3+2)^2 = 25\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#6-copy-parameters","title":"6. copy parameters","text":"<pre><code>#include &lt;stdio.h&gt;\n\nvoid arttir(int a) {\n    a++;\n    printf(\"\u0130\u015flev i\u00e7inde: %d\\n\", a);\n}\n\nint main() {\n    int x = 10;\n    arttir(x);\n    printf(\"Ana programda: %d\\n\", x);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#7-function-chains","title":"7. function chains","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint kare(int x) { return x * x; }\nint topla(int a, int b) { return a + b; }\n\nint main() {\n    printf(\"%d\\n\", kare(topla(3, 4))); // (3+4)^2 = 49\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#8-recursive","title":"8. recursive","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint faktoriyel(int n) {\n    if (n == 0) return 1;\n    return n * faktoriyel(n - 1);\n}\n\nint main() {\n    printf(\"5! = %d\\n\", faktoriyel(5));\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#9-function-pointer","title":"9. function pointer","text":"<pre><code>#include &lt;stdio.h&gt;\n/*\nyou can use function pointers to select functions at runtime.\nthis is show the functions can be used like data types\n*/\n\nint topla(int a, int b) { \n    return a + b; \n}\nint carp(int a, int b) { \n    return a * b; \n}\n\nint (*secim(int islem))(int, int) {\n    if (islem == 1) return topla;\n    else return carp;\n}\n\nint main() {\n    int (*f)(int, int);\n    f = secim(1);\n    printf(\"Sonu\u00e7: %d\\n\", f(3, 4)); // 7\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#functions-2","title":"Functions 2","text":""},{"location":"c/9_functions/#1-function-return-values-and-call-chains","title":"1. Function Return Values and Call Chains","text":"<p>The return value of a function can be an argument to another function. Additionally, a function can be used in another function's <code>return</code> statement.</p> <p>Example: </p><pre><code>int add(int a, int b) {\n    return a + b;\n}\n\nint square(int x) {\n    return x * x;\n}\n\nint sum_square(int a, int b) {\n    return add(square(a), square(b));\n}\n</code></pre> <p>Explanation: - <code>sum_square</code> returns the sum of the squares of two numbers. - The return values of the <code>add</code> and <code>square</code> functions are used by nesting calls. - This is possible because every function call in C produces an R-value.</p>"},{"location":"c/9_functions/#2-standard-c-functions-standard-library-functions","title":"2. Standard C Functions (Standard Library Functions)","text":"<p>Standard C functions are predefined functions that every C compiler must support. The code for these functions comes with the compiler.</p>"},{"location":"c/9_functions/#why-use-standard-functions","title":"Why Use Standard Functions?","text":"<ul> <li>Increases code portability  </li> <li>Creates a common language  </li> <li>Reduces code repetition  </li> <li>Ensures reliability (previously tested)</li> </ul>"},{"location":"c/9_functions/#example-standard-functions","title":"Example Standard Functions","text":"<p><code>printf()</code>, <code>scanf()</code>, <code>getchar()</code>, <code>putchar()</code>, <code>abs()</code>, <code>sqrt()</code>, <code>pow()</code>, <code>strlen()</code>, <code>malloc()</code>, <code>free()</code>, <code>exit()</code></p>"},{"location":"c/9_functions/#3-libraries-and-header-files","title":"3. Libraries and Header Files","text":"Component Description Header file (.h) Contains function declarations. Library (.lib / .a) Contains function definitions (compiled code). Linker Includes compiled functions into the program. <p>Example Usage: </p><pre><code>#include &lt;stdio.h&gt;  // printf, scanf\n#include &lt;math.h&gt;   // sqrt, pow\n</code></pre>"},{"location":"c/9_functions/#4-printf-function-output","title":"4. <code>printf()</code> Function (Output)","text":"<p><code>printf()</code> \u2192 Standard output function that writes data to the screen.</p> <p>Example: </p><pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int x = 25;\n    double pi = 3.1415;\n\n    printf(\u201cx = %d\\npi = %lf\\n\u201d, x, pi);\n    return 0;\n}\n</code></pre> <p>Formatting Characters: | Format | Type | Description | |:-------|:-----|:----------| | <code>%d</code> | int | Decimal system | | <code>%ld</code> | long | Decimal system | | <code>%u</code> | unsigned int | Decimal | | <code>%x</code>, <code>%X</code> | unsigned int | Hexadecimal | | <code>%o</code> | unsigned int | Octal | | <code>%f</code> | float/double | Real number (decimal) | | <code>%e</code> | float/double | Exponential notation | | <code>%c</code> | char | Character | | <code>%s</code> | string | Text |</p> <p>Escape Sequences: | Sequence | Meaning | |:------|:--------| | <code>\\n</code> | New line | | <code>\\t</code> | Tab | | <code>\\r</code> | Carriage return | | <code>\\a</code> | Bell sound | | <code>\\\"</code> | Double quote | | <code>\\\\</code> | Backslash |</p>"},{"location":"c/9_functions/#5-the-scanf-function-input","title":"5. The <code>scanf()</code> Function (Input)","text":"<p><code>scanf()</code> \u2192 Used to get data from the keyboard. The formatting characters are the same as <code>printf</code>, but it reads the data.</p> <p>Example: </p><pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    int x, y;\n    printf(\u201cEnter two numbers: \u201d);\n    scanf(\u201c%d%d\u201d, &amp;x, &amp;y);\n    printf(\u201c%d + %d = %d\\n\u201d, x, y, x + y);\n    return 0;\n}\n</code></pre> <p>Notes: - The <code>&amp;</code> operator \u2192 gives the address of the variable. - Spaces, tabs, or Enter keys don't matter; <code>scanf</code> treats them as separators.  </p>"},{"location":"c/9_functions/#6-functions-for-reading-characters-from-the-keyboard","title":"6. Functions for Reading Characters from the Keyboard","text":""},{"location":"c/9_functions/#getchar","title":"<code>getchar()</code>","text":"<ul> <li>It is a standard C function.  </li> <li>It reads one character from the keyboard.  </li> <li>The return value is the ASCII code of the character.</li> </ul> <pre><code>#include &lt;stdio.h&gt;\n\nint main() {\n    char ch;\n    printf(\u201cEnter a character: \u201d);\n    ch = getchar();\n    printf(\u201cCharacter: %c\\nASCII: %d\\n\u201d, ch, ch);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#getch-non-standard","title":"<code>getch()</code> (non-standard)","text":"<ul> <li>Available in most compilers (especially Windows <code>conio.h</code>).  </li> <li>No need to press Enter, the character is not printed on the screen.</li> </ul> <pre><code>#include &lt;conio.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\u201cPress a key...\\n\u201d);\n    getch();\n    printf(\"Okay, let's continue \\n\"0);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#getche-non-standard","title":"<code>getche()</code> (non-standard)","text":"<ul> <li>Similar to <code>getch()</code>, but the character you press appears on the screen.</li> </ul> <pre><code>#include &lt;conio.h&gt;\n#include &lt;stdio.h&gt;\n\nint main() {\n    printf(\u201cPress any key (character will appear): \u201d);\n    getche();\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#comparison-table","title":"Comparison Table","text":"Function Standard? Does it require Enter? Does the character appear? <code>getchar()</code> \u2705 \u2705 \u2705 <code>getch()</code> \u274c \u274c \u274c <code>getche()</code> \u274c \u274c \u2705"},{"location":"c/9_functions/#7-escape-sequence","title":"7. <code>%%</code> Escape Sequence","text":"<p>To print the <code>%</code> character itself in <code>printf</code>: </p><pre><code>printf(\u201c%%25\\n\u201d);  // Output: %25\n</code></pre>"},{"location":"c/9_functions/#8-benefits-of-using-standard-functions","title":"8. Benefits of Using Standard Functions","text":"<ol> <li>Portability: The code works on every system.  </li> <li>Readability: The code is simple and understandable.  </li> <li>Testing: Standard functions are reliable.  </li> <li>Time Savings: Using ready-made functions speeds up the developer.  </li> <li>Sustainability: The same function behaves the same way across different compilers.</li> </ol>"},{"location":"c/9_functions/#9-conversion-specifiers-variadic-functions-and-string-literals","title":"9. Conversion Specifiers, Variadic Functions, and String Literals","text":""},{"location":"c/9_functions/#printf-is-a-variadic-function","title":"<code>printf()</code> is a Variadic Function","text":"<p><code>printf()</code> takes a variable number of arguments:</p> <pre><code>int printf(const char *format, ...);\n</code></pre> <ul> <li>First parameter: format string (<code>const char*</code>)  </li> <li><code>...</code> : variable number of arguments  </li> </ul> <p>Functions such as <code>printf</code>, <code>scanf</code>, <code>fprintf</code>, and <code>sprintf</code> are variadic.  </p>"},{"location":"c/9_functions/#string-literals-and-0-null-byte-termination","title":"String Literals and <code>\u2018\\0\u2019</code> (Null Byte Termination)","text":"<p>In C, a character string ends with a <code>\u2018\\0\u2019</code> null byte:</p> <p></p><pre><code>char str[] = \u201cHello\u201d;\n</code></pre> How it is stored in memory: <pre><code>H e l l o \\0\n</code></pre> <p>In the call <code>printf(\u201c%s\u201d, str);</code>, <code>printf</code> prints the characters one by one and terminates the process when it encounters the <code>\u2018\\0\u2019</code> character.</p>"},{"location":"c/9_functions/#conversion-specifiers","title":"Conversion Specifiers","text":"<p>The <code>%</code> character in the format string specifies a conversion:</p> <pre><code>%[flags][width][.precision][length]specifier\n</code></pre> Specifier Type Description <code>%d</code>, <code>%i</code> int Decimal number <code>%u</code> unsigned int Decimal <code>%x</code>, <code>%X</code> unsigned int Hexadecimal <code>%f</code> double Decimal <code>%e</code>, <code>%E</code> double Exponential notation <code>%c</code> char Character <code>%s</code> char* String (C string) <code>%p</code> void* Memory address <code>%%</code> \u2014 The <code>%</code> character itself"},{"location":"c/9_functions/#flags-width-and-precision","title":"Flags, Width, and Precision","text":"Element Description Example Output <code>-</code> left alignment <code>%-5d</code>, 42 <code>42</code> <code>0</code> zero-fill <code>%05d</code>, 42 <code>00042</code> <code>+</code> show sign <code>%+d</code>, 42 <code>+42</code> <code>.precision</code> decimal places <code>%.2f</code>, 3.1415 <code>3.14</code> <code>width</code> minimum space <code>%8s</code>, \u201cC\u201d <code>\u201c       C\u201d</code>"},{"location":"c/9_functions/#example-complete-formatting","title":"Example: Complete Formatting","text":"<pre><code>#include &lt;stdio.h&gt;\nint main() {\n    printf(\u201c%-10s %04d %.3f\\n\u201d, \u201cC\u201d, 7, 3.14159);\n    return 0;\n}\n</code></pre> Output: <pre><code>C          0007 3.142\n</code></pre>"},{"location":"c/9_functions/#printf-return-value","title":"<code>printf</code> Return Value","text":"<p><code>printf()</code> returns the number of characters it prints to the screen:</p> <p></p><pre><code>int n = printf(\u201cHello!\u201d);\nprintf(\u201c\\nTotal %d characters printed.\\n\u201d, n);\n</code></pre> Output: <pre><code>Hello!\nTotal 6 characters printed.\n</code></pre>"},{"location":"c/9_functions/#puts-and-putchar","title":"<code>puts()</code> and <code>putchar()</code>","text":"Function Description <code>putchar(c)</code> Writes a single character <code>puts(str)</code> Writes a string and appends <code>\\n</code> to the end <p>Example: </p><pre><code>#include &lt;stdio.h&gt;\nint main() {\n    putchar(\u2018A\u2019);\n    puts(\u201c Hello\u201d);\n    return 0;\n}\n</code></pre> Output: <pre><code>A Hello\n</code></pre>"},{"location":"c/9_functions/#memory-safety","title":"Memory Safety","text":"<p><code>printf(\u201c%d\u201d, 3.14);</code> \u2192 \u274c Undefined behavior (UB) Because <code>%d</code> expects an integer, while <code>3.14</code> is a double type.  </p> <p>Compilers usually warn about such errors with the <code>-Wall</code> option.</p>"},{"location":"c/9_functions/#10-summary-table","title":"10. Summary Table","text":"Concept Description Variadic function <code>printf</code> takes a variable number of arguments String literal A constant string enclosed in double quotes, ending with <code>\u2018\\0\u2019</code> Conversion specifier <code>%d</code>, <code>%f</code>, <code>%s</code>, <code>%p</code>, etc. <code>printf</code> return value Number of characters written Memory safety Format and argument types must match"},{"location":"c/9_functions/#additional-examples_1","title":"Additional examples","text":""},{"location":"c/9_functions/#1-return","title":"1. return","text":"<pre><code>#include &lt;stdio.h&gt;\n\n// Temel \u00f6rnek: return de\u011feri d\u00f6nd\u00fcren/d\u00f6nd\u00fcrmeyen fonksiyonlar\n\nint square(int x) {\n    return x * x; // de\u011fer d\u00f6nd\u00fcr\u00fcr\n}\n\nvoid greet(void) {\n    printf(\"Merhaba!\\n\"); // hi\u00e7bir \u015fey d\u00f6nd\u00fcrmez\n}\n\nint main(void) {\n    greet();\n    printf(\"5'in karesi: %d\\n\", square(5));\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#2-definition-call","title":"2. definition call","text":"<pre><code>#include &lt;stdio.h&gt;\n\n// Bildirim (prototip)\nint topla(int, int);\n\nint main(void) {\n    int sonuc = topla(3, 4);\n    printf(\"Toplam = %d\\n\", sonuc);\n    return 0;\n}\n\n// Tan\u0131mlama\nint topla(int a, int b) {\n    return a + b;\n}\n</code></pre>"},{"location":"c/9_functions/#3-parameters","title":"3. parameters","text":"<pre><code>#include &lt;stdio.h&gt;\n\n// Parametre aktar\u0131m\u0131 (by value): kopya \u00fczerinden \u00e7al\u0131\u015f\u0131r\n\nvoid arttir(int a) {\n    a++;\n    printf(\"\u0130\u015flev i\u00e7inde: %d\\n\", a);\n}\n\nint main(void) {\n    int x = 10;\n    arttir(x);\n    printf(\"Ana programda: %d\\n\", x); // x de\u011fi\u015fmez\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#4-nested-calls","title":"4. nested calls","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint add(int a, int b) { return a + b; }\nint square(int x)     { return x * x; }\n\nint main(void) {\n    int sonuc = add(square(3), square(4));\n    printf(\"(3^2 + 4^2) = %d\\n\", sonuc);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#5-recursion","title":"5. recursion","text":"<pre><code>#include &lt;stdio.h&gt;\n\n// Klasik: fakt\u00f6riyel (\u00f6zyineleme)\n\nint factorial(int n) {\n    if (n == 0) return 1;\n    return n * factorial(n - 1);\n}\n\nint main(void) {\n    printf(\"5! = %d\\n\", factorial(5));\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#6-stdio_basics","title":"6. stdio_basics","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int x;\n    printf(\"Bir say\u0131 girin: \");\n    if (scanf(\"%d\", &amp;x) == 1) {\n        printf(\"Girdi\u011finiz say\u0131: %d\\n\", x);\n    } else {\n        printf(\"Ge\u00e7ersiz giri\u015f!\\n\");\n    }\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#7-conversion-specifiers","title":"7. conversion specifiers","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int i = 255;\n    double d = 3.14159;\n    char c = 'A';\n    const char *s = \"Merhaba\";\n\n    printf(\"int: %d, hex: %x, octal: %o\\n\", i, i, i);\n    printf(\"float: %.2f, scientific: %.3e\\n\", d, d);\n    printf(\"char: %c, string: %s\\n\", c, s);\n    printf(\"adres: %p\\n\", (void*)s);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#8-variadic","title":"8. variadic","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdarg.h&gt;\n\n// \u00c7ok basit bir mini printf: sadece %d destekli\nvoid mini_print(const char *fmt, ...) {\n    va_list args;\n    va_start(args, fmt);\n    while (*fmt) {\n        if (*fmt == '%' &amp;&amp; *(fmt + 1) == 'd') {\n            int val = va_arg(args, int);\n            printf(\"%d\", val);\n            fmt += 2;\n        } else {\n            putchar(*fmt++);\n        }\n    }\n    va_end(args);\n}\n\nint main(void) {\n    mini_print(\"Sonuc: %d + %d = %d\\n\", 2, 3, 5);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#9-strings","title":"9. strings","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char str[] = \"C dili\"; // '\\0' ile sonlan\u0131r\n    printf(\"Yaz\u0131: %s\\n\", str);\n\n    int i = 0;\n    while (str[i] != '\\0') {\n        printf(\"%c \", str[i]);\n        i++;\n    }\n    printf(\"\\nUzunluk: %d\\n\", i);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#10-escape-sequences","title":"10. escape sequences","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Yeni satir\\\\nve tab\\\\t\u00f6rne\u011fi\\n\");\n    printf(\"Ters b\u00f6l\u00fc: \\\\\\\\ ve t\u0131rnak: \\\\\\\" \\n\");\n    printf(\"Sekizlik: \\\\101 (A), Onalt\u0131l\u0131k: \\\\x41 (A)\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#11-stdlib_demo","title":"11. stdlib_demo","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;math.h&gt;\n#include &lt;string.h&gt;\n#include &lt;ctype.h&gt;\n\nint main(void) {\n    double x = 9.0;\n    printf(\"sqrt(%.2f) = %.2f\\n\", x, sqrt(x));\n\n    char buf[64] = \"C\";\n    const char *s2 = \" Programlama\";\n    strcat(buf, s2); // dikkat: hedef buffer yeterince b\u00fcy\u00fck olmal\u0131\n    printf(\"Birle\u015ftirme: %s\\n\", buf);\n\n    char ch = 'a';\n    printf(\"%c -&gt; %c\\n\", ch, toupper((unsigned char)ch));\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#12-printf","title":"12. printf","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"%10s\\n\", \"C\");      // sa\u011fa yasla\n    printf(\"%-10s\\n\", \"C\");     // sola yasla\n    printf(\"%04d\\n\", 7);        // s\u0131f\u0131rla doldur\n    printf(\"%+d\\n\", 42);        // i\u015faret g\u00f6ster\n    printf(\"%.3f\\n\", 3.14159);  // ondal\u0131k basamak\n    printf(\"%#x\\n\", 255);       // alternatif bi\u00e7im -&gt; 0xff\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#13-char_io","title":"13. char_io","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int ch; // getchar() int d\u00f6nd\u00fcr\u00fcr (EOF-end of file- ay\u0131rt\u0131 i\u00e7in)\n    printf(\"Bir karakter girin: \");\n    ch = getchar();\n    if (ch != EOF) {\n        printf(\"Girdi\u011finiz karakter: \");\n        putchar(ch);\n        putchar('\\n');\n    }\n    puts(\"----Program bitti.----\");\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#14-undefined-behaviour","title":"14. undefined behaviour","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    // UYARI: A\u015fa\u011f\u0131daki sat\u0131r tan\u0131ms\u0131z davran\u0131\u015ft\u0131r (UB).\n    // %d tamsay\u0131 beklerken double g\u00f6nderilirse sonu\u00e7 belirsizdir.\n    printf(\"%d\\n\", 3.14);\n\n    // Do\u011frusu:\n    printf(\"%f\\n\", 3.14);\n\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#functions-3","title":"Functions 3","text":""},{"location":"c/9_functions/#1-purpose-of-character-inputoutput-functions","title":"1. Purpose of Character Input/Output Functions","text":"<p>In the C language, character-based input/output operations are used to read a single character from the keyboard or write a single character to the screen. These functions are simpler and faster than formatted input/output (<code>printf</code>, <code>scanf</code>) operations.</p>"},{"location":"c/9_functions/#2-the-putchar-function","title":"2. The <code>putchar()</code> Function","text":"<pre><code>int putchar(int ch);\n</code></pre> <ul> <li>A standard C function.  </li> <li>Writes the character in its parameter to the location of the cursor on the screen. </li> <li>Return value: the ASCII code value of the written character. </li> <li>Its definition is in the <code>stdio.h</code> header file.</li> </ul>"},{"location":"c/9_functions/#example","title":"Example","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char ch;\n    ch = getchar();   // read a character from the keyboard\n    putchar(ch);      // write the character to the screen\n    return 0;\n}\n</code></pre> <p>The same operation could also be performed with the line <code>printf(\u201c%c\u201d, ch);</code>.</p>"},{"location":"c/9_functions/#3-the-putch-function","title":"3. The <code>putch()</code> Function","text":"<pre><code>int putch(int ch);\n</code></pre> <ul> <li>It is a non-standard function (under <code>conio.h</code>).  </li> <li>Difference from <code>putchar</code>: It writes the <code>' '</code> character only as LF (ASCII 10).</li> </ul>"},{"location":"c/9_functions/#example_1","title":"Example","text":"<pre><code>#include &lt;conio.h&gt;\nint main(void) {\n    putch(\u2018A\u2019);\n    putch(\u2018\\n\u2019);\n    putch(\u2018B\u2019);\n    return 0;\n}\n</code></pre> <p><code>A</code> and <code>B</code> appear on the screen in the same column, one below the other.</p>"},{"location":"c/9_functions/#4-the-puts-function","title":"4. The <code>puts()</code> Function","text":"<pre><code>int puts(const char *str);\n</code></pre> <ul> <li>It performs the same function as <code>printf(\u201c%s\\n\u201d, str);</code> but automatically adds <code>\\n</code>.</li> <li>It writes up to the <code>\\0</code> character.</li> </ul>"},{"location":"c/9_functions/#example_2","title":"Example","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    puts(\u201cHello World\u201d);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#5-getchar-function","title":"5. <code>getchar()</code> Function","text":"<pre><code>int getchar(void);\n</code></pre> <ul> <li>Reads one character from the keyboard.  </li> <li>Reading is completed when the Enter key is pressed.</li> <li>Return value: the ASCII value of the character (<code>int</code>).</li> </ul>"},{"location":"c/9_functions/#example_3","title":"Example","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int ch;\n    printf(\u201cEnter a character: \u201d);\n    ch = getchar();\n    printf(\u201cThe character you entered: \u201d);\n    putchar(ch);\n    putchar(\u2018\\n\u2019);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#6-getch-and-getche-functions","title":"6. <code>getch()</code> and <code>getche()</code> Functions","text":"Function Description Standard? Does it require Enter? Is the character visible? <code>getch()</code> Reads the character, does not print it to the screen \u274c \u274c \u274c <code>getche()</code> Reads the character, also prints it to the screen \u274c \u274c \u2705"},{"location":"c/9_functions/#getch-example","title":"<code>getch()</code> Example","text":"<pre><code>#include &lt;conio.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\u201cPress a key...\\n\u201d);\n    getch();\n    printf(\u201cOkay, let's continue!\\n\u201d);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#getche-example","title":"<code>getche()</code> Example","text":"<pre><code>#include &lt;conio.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\u201cPress a key (character will appear on screen): \u201d);\n    getche();\n    printf(\u201c\\nReading completed.\\n\u201d);\n    return 0;\n}\n</code></pre> <p>Both functions are located in the <code>conio.h</code> library and are not portable.</p>"},{"location":"c/9_functions/#7-gets-function-should-not-be-used","title":"7. <code>gets()</code> Function (SHOULD NOT BE USED)","text":"<pre><code>char *gets(char *str);\n</code></pre> <ul> <li>Reads a line of text from the user.  </li> <li>Takes all characters until the <code>Enter</code> key is pressed.  </li> <li>Not secure (buffer overflow risk).</li> </ul>"},{"location":"c/9_functions/#safe-alternative","title":"Safe Alternative","text":"<pre><code>fgets(str, sizeof(str), stdin);\n</code></pre>"},{"location":"c/9_functions/#safe-usage","title":"Safe Usage","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char name[20];\n    printf(\u201cEnter your name: \u201d);\n    fgets(name, sizeof(name), stdin);\n    printf(\u201cHello %s\u201d, name);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#8-function-comparison-table","title":"8. Function Comparison Table","text":"Function Task Standard Return Line Ending Note <code>putchar</code> Writes 1 character \u2705 ASCII code Manual Basic output <code>putch</code> Writes 1 character \u274c ASCII code LF (only) <code>conio.h</code> <code>puts</code> Writes string \u2705 int Automatic <code>\\n</code> Fast <code>getchar</code> Reads 1 character \u2705 ASCII code Enter required basic input <code>getch</code> Reads 1 character \u274c ASCII code Enter not required invisible on screen <code>getche</code> Reads 1 character \u274c ASCII code Enter not required visible on screen <code>gets</code> Reads string \u274c (removed in C11) pointer line end not included security risk"},{"location":"c/9_functions/#inputoutput-application","title":"Input/Output Application","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char ch;\n    printf(\u201cEnter a character (end with x): \u201d);\n    do {\n        ch = getchar();\n        putchar(ch);\n    } while (ch != \u2018x\u2019);\n    return 0;\n}\n</code></pre> Characters are printed to the screen as-is until the user enters <code>x</code>."},{"location":"c/9_functions/#10-result","title":"10. Result","text":"<ul> <li><code>putchar</code> \u2192 standard, for printing characters</li> <li><code>putch</code> \u2192 non-standard, for DOS/Windows systems  </li> <li><code>puts</code> \u2192 prints a string, adds <code>\\n</code> </li> <li><code>getchar</code> \u2192 standard, reads a character  </li> <li><code>getch</code> / <code>getche</code> \u2192 not portable  </li> <li><code>gets</code> \u2192 should not be used, use <code>fgets</code> instead</li> </ul>"},{"location":"c/9_functions/#additional-examples_2","title":"Additional examples","text":""},{"location":"c/9_functions/#1-putchar","title":"1. putchar","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char ch;\n    printf(\"Bir karakter girin: \");\n    ch = getchar();   // klavyeden tek karakter oku\n    printf(\"Ekrana yaz\u0131l\u0131yor: \");\n    putchar(ch);      // karakteri yaz\n    putchar('\\n');    // sat\u0131r sonu\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#2-puts-printf","title":"2. puts printf","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char ch;\n    printf(\"Bir karakter girin: \");\n    ch = getchar();   // klavyeden tek karakter oku\n    printf(\"Ekrana yaz\u0131l\u0131yor: \");\n    putchar(ch);      // karakteri yaz\n    putchar('\\n');    // sat\u0131r sonu\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#3-getchar","title":"3. getchar","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char ch;\n    printf(\"Bir \u015feyler yaz\u0131n (x ile \u00e7\u0131k\u0131\u015f):\\n\");\n    do {\n        ch = getchar();\n        putchar(ch);\n    } while (ch != 'x');\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#4-getch-and-getche","title":"4. getch and getche","text":"<pre><code>#include &lt;conio.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    printf(\"Bir tu\u015fa bas\u0131n (getch): \");\n    getch(); // Enter gerekmez\n    printf(\"\\ngetche test (karakter g\u00f6r\u00fcn\u00fcr): \");\n    getche(); // karakter g\u00f6r\u00fcn\u00fcr\n    printf(\"\\nTamamland\u0131.\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#5-putch","title":"5. putch","text":"<pre><code>#include &lt;conio.h&gt;\n\nint main(void) {\n    putch('A');\n    putch('\\n');\n    putch('B');\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#6-gets-and-gfets","title":"6. gets and gfets","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char ad1[20], ad2[20];\n\n    printf(\"Ad\u0131n\u0131z\u0131 (gets ile) girin: \");\n    gets(ad1);  // \u26a0\ufe0f TEHL\u0130KEL\u0130 \u2014 boyut kontrol\u00fc yok!\n\n    printf(\"Ad\u0131n\u0131z\u0131 (fgets ile) girin: \");\n    fgets(ad2, sizeof(ad2), stdin);\n\n    printf(\"\\ngets sonucu : %s\\n\", ad1);\n    printf(\"fgets sonucu: %s\\n\", ad2);\n\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#7-fgets","title":"7. fgets","text":"<pre><code>#include &lt;stdio.h&gt;\n#include &lt;string.h&gt;\n\nint main(void) {\n    char isim[30];\n    printf(\"Ad\u0131n\u0131z\u0131 girin: \");\n    fgets(isim, sizeof(isim), stdin);\n    isim[strcspn(isim, \"\\n\")] = '\\0'; // \\n karakterini sil\n    printf(\"Merhaba %s!\\n\", isim);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#8-eof_end-of-file","title":"8. EOF_end of file","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int ch;\n    printf(\"Ctrl+Z (Windows) veya Ctrl+D (Linux) ile \u00e7\u0131k\u0131n:\\n\");\n    while ((ch = getchar()) != EOF) {\n        putchar(ch);\n    }\n    printf(\"\\nEOF alg\u0131land\u0131.\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#9-getchar-ascii","title":"9. getchar ascii","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    int ch;\n    printf(\"Bir karakter girin (x ile bitir): \");\n    do {\n        ch = getchar();\n        printf(\"Karakter: %c | ASCII: %d\\n\", ch, ch);\n    } while (ch != 'x');\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#10-shadow-password","title":"10. shadow password","text":"<pre><code>#include &lt;conio.h&gt;\n#include &lt;stdio.h&gt;\n\nint main(void) {\n    char pass[20];\n    int i = 0;\n    char ch;\n\n    printf(\"\u015eifre girin: \");\n    while (i &lt; 19 &amp;&amp; (ch = getch()) != '\\r') { // '\\r' = Enter\n        pass[i++] = ch;\n        putch('*'); // maskelenmi\u015f yazd\u0131rma\n    }\n    pass[i] = '\\0';\n    printf(\"\\nGirdi\u011finiz \u015fifre: %s\\n\", pass);\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#11-write-and-read","title":"11. write and read","text":"<pre><code>#include &lt;stdio.h&gt;\n\nint main(void) {\n    char c;\n    printf(\"Metin girin ('.' ile bitir):\\n\");\n    while ((c = getchar()) != '.') {\n        if (c &gt;= 'a' &amp;&amp; c &lt;= 'z')\n            c -= 32; // k\u00fc\u00e7\u00fck \u2192 b\u00fcy\u00fck\n        putchar(c);\n    }\n    printf(\"\\nTamamland\u0131.\\n\");\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#12-definition-void-and-main","title":"12. Definition, <code>void</code> and <code>main</code>","text":"<pre><code>#include &lt;stdio.h&gt;\n\n// 1. VOID Function Definition (No return value, no parameters)\n// Purpose: To perform a specific task (printing)\nvoid print_separator() {\n    printf(\"\\n--------------------------\\n\");\n    // A void function can optionally use 'return;' to exit early.\n}\n\n// 2. Value-Returning Function Definition (Returns an int, takes no parameters)\n// Purpose: To calculate and return a value.\nint get_current_year() {\n    // Returns the calculated result (2025 in this example)\n    return 2025; \n}\n\n// 8. The main function - the program's starting point\nint main() {\n\n    // 9. Function Invocation (Void function call)\n    print_separator();\n    printf(\"C Functions: Basic Demo\\n\");\n    print_separator();\n\n    // 9. Function Invocation (Value-returning function, result used immediately)\n    printf(\"The current year is: %d\\n\", get_current_year());\n\n    // 9. Function Invocation (Value-returning function, result assigned to a variable)\n    int year = get_current_year();\n    printf(\"Year stored in variable 'year': %d\\n\", year);\n\n    // 8. The return value of main is passed to the OS (0 means success)\n    return 0; \n}\n</code></pre>"},{"location":"c/9_functions/#13-parameters-and-pass-by-value","title":"13. Parameters and Pass by-value","text":"<p>Please remember in pass by-value the arguments are copied, the original variable remains unchanged</p> <pre><code>#include &lt;stdio.h&gt;\n\n// 11. New Style Function Definition with Parameters\n// Takes two int parameters (copies) and returns their sum (int)\nint add_numbers(int a, int b) {\n    // 7. Returns the calculated result.\n    return a + b;\n}\n\n// 15. Demonstrating Copying Arguments (Pass-by-Value)\n// The parameter 'val' is a copy of the argument passed in.\nvoid try_to_change(int val) {\n    printf(\"  Inside function: Original value is %d\\n\", val);\n    val = 999; // Only changes the local copy 'val'\n    printf(\"  Inside function: Value changed to %d (local copy)\\n\", val);\n    return; // 7. Void function using 'return;'\n}\n\nint main() {\n    int x = 10;\n    int y = 20;\n\n    printf(\"--- 1. Using Parameters ---\\n\");\n\n    // 9. Function Invocation: x and y are the actual parameters.\n    // Their values (10 and 20) are copied to parameters a and b.\n    int sum_result = add_numbers(x, y); \n    printf(\"Sum of %d and %d is: %d\\n\", x, y, sum_result); // Output: 30\n\n    printf(\"\\n--- 2. Pass-by-Value (Copying Arguments) ---\\n\");\n\n    int original_value = 50;\n    printf(\"Before call: Original variable value is %d\\n\", original_value);\n\n    // 15. Call the function, passing a copy of 50.\n    try_to_change(original_value); \n\n    // The function's change to 'val' did not affect 'original_value'.\n    printf(\"After call: Original variable value remains %d\\n\", original_value); // Output: 50\n\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#14-recursion-and-nested-calls","title":"14. Recursion and Nested Calls","text":"<p>recursion (a function calling itself) and nested function calls (using one function's return value as another's input). </p><pre><code>#include &lt;stdio.h&gt;\n\n// Helper function for nested calls\nint square(int n) {\n    return n * n;\n}\n\n// 17. Recursive Function Definition: Calculates factorial\nint factorial(int n) {\n    // Base Case (Stops the recursion)\n    if (n == 0) {\n        printf(\"  [Base Case] Reached n=0, returning 1.\\n\");\n        return 1;\n    }\n\n    // Recursive Step\n    printf(\"  Calling factorial(%d) * %d...\\n\", n - 1, n);\n    // Function calling itself\n    return n * factorial(n - 1); \n}\n\n\n// Value-returning function with a function call inside its return\nint calculate_hypotenuse_squared(int a, int b) {\n    // 16. Another call inside return: Uses nested calls.\n    // square(a) and square(b) are evaluated first.\n    return add_numbers(square(a), square(b)); // Assuming add_numbers is available/defined\n}\n\n// A function defined earlier (from Intermediate Demo)\nint add_numbers(int a, int b) {\n    return a + b;\n}\n\nint main() {\n    printf(\"--- 1. Nested and Return Calls ---\\n\");\n\n    int side1 = 3;\n    int side2 = 4;\n\n    // 16. Nested call: calculate_hypotenuse_squared is called.\n    // Inside it, add_numbers is called, and inside that, square is called twice.\n    int h_squared = calculate_hypotenuse_squared(side1, side2);\n    printf(\"Side 1^2 + Side 2^2 (3^2 + 4^2) = %d\\n\", h_squared); // Output: 25\n\n    printf(\"\\n--- 2. Recursive Function (Factorial) ---\\n\");\n    int number = 4;\n    printf(\"Calculating Factorial of %d:\\n\", number);\n\n    // 17. Recursive call starts here\n    int fact_result = factorial(number); \n    printf(\"Result of 4! is: %d\\n\", fact_result); // Output: 24\n\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#15-prototypes-linking-and-return-constraints","title":"15. Prototypes, Linking, and Return Constraints","text":"<p>declarations (prototypes), the linker phase, and what happens when a function's return value is ignored or misused. </p><pre><code>#include &lt;stdio.h&gt;\n\n// 1. Function Prototype (Declaration)\n// This tells the compiler the function exists, its signature, and its return type.\n// It allows us to define the function later or in a separate file.\nint calculate_something(int x, int y); \n\n// 5. Function Without a Specified Type (Old C/Pre-ANSI C)\n// The compiler automatically assumes 'int' return type. (Not recommended).\n// 10. This is defined *before* the call, so no prototype is strictly needed.\nno_type_func() {\n    printf(\"-&gt; (Warning) Function without a specified type. Assumed 'int'.\\n\");\n    return 100;\n}\n\n// 3. Main function demonstrating function calls\nint main() {\n    int a = 10, b = 5;\n\n    printf(\"--- 1. Using and Not Using Return Values ---\\n\");\n\n    // 16. Value-returning function, result assigned. (Normal use)\n    int result = calculate_something(a, b);\n    printf(\"Result used (10 * 5) = %d\\n\", result);\n\n    // 16. Call without using the value. (Can sometimes trigger a warning)\n    calculate_something(a, b);\n    printf(\"Result not used. (Compiler might issue 'code has no effect!')\\n\");\n\n    // 9. Function Invocation: func() = 5 is Invalid (R-value constraint)\n    // The value produced by a function call is an R-value, it cannot be assigned to.\n    // Error: L-value required as left operand of assignment.\n    // (If you uncomment the line below, it will cause a compile error.)\n    // calculate_something(a, b) = 100; \n\n    // Call function with implicit 'int' return type\n    printf(\"no_type_func returned: %d\\n\", no_type_func());\n\n    return 0;\n}\n\n// 5. Function Definition (Must be defined somewhere for the linker)\nint calculate_something(int x, int y) {\n    return x * y;\n}\n\n// 10. Undefined Function Example\n// If we had a prototype for 'void linker_error();' but no definition anywhere,\n// the compiler would be happy, but the *linker* would fail.\n</code></pre>"},{"location":"c/9_functions/#16-old-style-vs-new-style-and-int-foo-vs-int-foovoid","title":"16. Old Style vs. New Style and <code>int foo()</code> vs. <code>int foo(void)</code>","text":"<p>Old Style vs. New Style and int foo() vs. int foo(void) </p><pre><code>#include &lt;stdio.h&gt;\n\n// 14. Function without Parameters (Implicit 'void') - Deprecated\n// In C, an empty parenthesis means \"takes an unspecified number of arguments.\"\n// The compiler does NOT check the number of arguments passed in the function call.\nint old_style_no_param() {\n    return 1;\n}\n\n// 14. Function without Parameters (Explicit 'void') - New Style\n// This is the correct, modern way to state a function takes NO arguments.\n// The compiler WILL issue an error if arguments are passed.\nint new_style_no_param(void) {\n    return 2;\n}\n\n// 12. Old Style Parameter Declaration (Pre-ANSI C)\n// Parameter types are listed after the function header. This is obsolete.\nint old_style_params(x, y)\nint x; \nint y; // The compiler can still compile this but throws a warning.\n{\n    printf(\"  [Old Style] Parameters: %d and %d\\n\", x, y);\n    return x - y;\n}\n\n\nint main() {\n    printf(\"--- 1. New Style vs. Old Style Parameters ---\\n\");\n\n    // 13. New Style Call: Types declared in the parentheses.\n    printf(\"New Style Subtraction (10 - 5): %d\\n\", old_style_params(10, 5));\n\n    printf(\"\\n--- 2. Parameter Constraints: () vs. (void) ---\\n\");\n\n    // Using () (unspecified)\n    printf(\"old_style_no_param() returned: %d\\n\", old_style_no_param());\n\n    // DANGER: We can call the '()' function with arguments, and the compiler\n    // may not complain, leading to Unspecified Behavior! (Value is ignored/garbage)\n    printf(\"old_style_no_param(100, 200) returned: %d\\n\", old_style_no_param(100, 200));\n\n    // Using (void)\n    printf(\"new_style_no_param(void) returned: %d\\n\", new_style_no_param());\n\n    // ERROR: If you uncomment the line below, the compiler will catch it,\n    // as the (void) parameter list explicitly states no arguments are allowed.\n    // printf(\"new_style_no_param(100) returned: %d\\n\", new_style_no_param(100));\n\n    return 0;\n}\n</code></pre>"},{"location":"c/9_functions/#17-return-flow-and-exit","title":"17. Return flow and exit","text":"<p>function exit points, including using <code>return</code> in a <code>void</code> function, and the difference between the actual return value and the OS return value. </p><pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt; // For EXIT_SUCCESS/EXIT_FAILURE\n\n// A value-returning function that might return a garbage value.\nint check_and_exit(int x) {\n    if (x &lt; 0) {\n        printf(\"Condition met, exiting early with status code 1.\\n\");\n        // We can use 'return' with a value here, but we are also\n        // using the standard library's exit function to terminate the *entire program* immediately.\n        exit(EXIT_FAILURE); // Terminates the program entirely, bypassing the return\n    }\n\n    // 7. If the end is reached without a return statement, it returns a garbage value.\n    // NOTE: Many modern compilers will issue a warning or error if a non-void\n    // function reaches the end without a return statement, but the C standard allows it.\n}\n\n\n// A void function demonstrating early exit\nvoid process_data(int data) {\n    if (data == 0) {\n        printf(\"Data is zero, cannot process. Exiting function early.\\n\");\n        // 7. return; used to end execution in a void function.\n        return; \n    }\n\n    printf(\"Data %d processed successfully.\\n\", data);\n}\n\nint main() {\n    printf(\"--- 1. Void Function Exit Flow ---\\n\");\n    process_data(10);\n    process_data(0); // This call triggers an early return\n    process_data(20); // This is executed after the early return\n\n    printf(\"\\n--- 2. main() Return Value ---\\n\");\n\n    // 8. The return value of main is passed to the operating system.\n    // A function call that returns a value (r-value)\n    int result = check_and_exit(5);\n\n    // 8. Convention: 0 for success.\n    return EXIT_SUCCESS; // which is usually 0\n\n    /*\n    If we had called check_and_exit(-1) instead, the program would have\n    terminated immediately inside that function with exit(EXIT_FAILURE),\n    and the 'return EXIT_SUCCESS' line here would never be reached.\n    */\n}\n</code></pre>"}]}